%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}
\usepackage{enumitem}
\usepackage[Bjornstrup]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\def\pageautorefname{page}

\setcounter{tocdepth}{1}


\usepackage[titles]{tocloft}
\cftsetpnumwidth {1.25cm}\cftsetrmarg{1.5cm}
\setlength{\cftchapnumwidth}{0.75cm}
\setlength{\cftsecindent}{\cftchapnumwidth}
\setlength{\cftsecnumwidth}{1.25cm}


\title{Non-reciprocal wavefields (1D) Documentation}
\date{Apr 18, 2018}
\release{28-03-2018}
\author{Christian Reinicke, Kees Wapenaar, and Evert Slob}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{p-w-domain}
\label{\detokenize{modules:p-w-domain}}\label{\detokenize{modules::doc}}\label{\detokenize{modules:welcome-to-non-reciprocal-wavefields-1d-s-documentation}}

\section{Layered\_NRM\_p\_w module}
\label{\detokenize{Layered_NRM_p_w::doc}}\label{\detokenize{Layered_NRM_p_w:module-Layered_NRM_p_w}}\label{\detokenize{Layered_NRM_p_w:layered-nrm-p-w-module}}\index{Layered\_NRM\_p\_w (module)}
Routines for modelling wavefields in 1D non-reciprocal media.

\phantomsection\label{\detokenize{Layered_NRM_p_w:module-Wavefield_NRM_p_w}}\index{Wavefield\_NRM\_p\_w (module)}\begin{quote}\begin{description}
\item[{Authors}] \leavevmode
Christian Reinicke (\sphinxhref{mailto:c.reinicke@tudelft.nl}{c.reinicke@tudelft.nl}), Kees Wapenaar (), and Evert Slob ()

\item[{Copyright}] \leavevmode
Christian Reinicke (\sphinxhref{mailto:c.reinicke@tudelft.nl}{c.reinicke@tudelft.nl}), Kees Wapenaar (), and Evert Slob ()

\end{description}\end{quote}
\index{Layered\_NRM\_p\_w (class in Layered\_NRM\_p\_w)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Layered_NRM_p_w:Layered_NRM_p_w.Layered_NRM_p_w}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Layered\_NRM\_p\_w.}}\sphinxbfcode{\sphinxupquote{Layered\_NRM\_p\_w}}}{\emph{nt}, \emph{dt}, \emph{nr=1}, \emph{dx1=1}, \emph{verbose=False}, \emph{x3vec=array({[}0.{]})}, \emph{avec=array({[}0.{]})}, \emph{bvec=array({[}0.{]})}, \emph{g1vec=array({[}0.{]})}, \emph{g3vec=array({[}0.{]})}, \emph{p1=None}, \emph{ReciprocalMedium=False}, \emph{AdjointMedium=False}}{}
Bases: {\hyperref[\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w}}}}}

is a class to model wavefields in 1.5D (non-)reciprocal media in the ray-parameter frequency domain.

The class Layered\_NRM\_p\_w defines a 1.5D (non-)reciprocal medium and a scalar wavefield. We consider a single horizontal ray-parameter ‘p1’ and all frequencies that are sampled by the given number of time samples ‘nt’ and the time sample interval ‘dt’.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{nt} : int
\begin{quote}

Number of time samples.
\end{quote}

\sphinxstylestrong{dt} : int, float
\begin{quote}

Time sample interval in seconds.
\end{quote}

\sphinxstylestrong{nr} : int, optional
\begin{quote}

Number of space samples.
\end{quote}

\sphinxstylestrong{dx1} : int, float, optional
\begin{quote}

Space sample interval.
\end{quote}

\sphinxstylestrong{verbose} : bool, optional
\begin{quote}

Set ‘verbose=True’ to receive feedback in the command line.
\end{quote}

\sphinxstylestrong{x3vec} : numpy.ndarray
\begin{quote}

Vertical spatial vector \(x_3\), for n layers ‘x3vec’ must have the shape (n,). We define the \(x_3\)-axis as downward-pointing. Implicitly, the first value on the \(x_3\)-axis is zero (not stored in ‘x3vec’).
\end{quote}

\sphinxstylestrong{avec} : numpy.ndarray
\begin{quote}

Medium parameter \(\alpha\) (real-valued), for n layers ‘avec’ must have the shape (n,).
\end{quote}

\sphinxstylestrong{bvec} : numpy.ndarray
\begin{quote}

Medium parameter \(\beta\) (real-valued), for n layers ‘bvec’ must have the shape (n,).
\end{quote}

\sphinxstylestrong{g1vec} : numpy.ndarray, optional
\begin{quote}

Medium parameter \(\gamma_1\) (real-valued for non-reciprocal media or imaginary-valued for reciprocal media), for n layers ‘g1vec’ must have the shape (n,).
\end{quote}

\sphinxstylestrong{g3vec} : numpy.ndarray, optional
\begin{quote}

Medium parameter \(\gamma_3\) (real-valued for non-reciprocal media or imaginary-valued for reciprocal media), for n layers ‘g3vec’ must have the shape (n,).
\end{quote}

\sphinxstylestrong{p1} : int, float
\begin{quote}

Horizontal ray-parameter in seconds per metre.
\end{quote}

\sphinxstylestrong{ReciprocalMedium} : bool, optional
\begin{quote}

For non-reciprocal media set ‘ReciprocalMedium=False’, for reciprocal media set ‘ReciprocalMedium=True’.
\end{quote}

\sphinxstylestrong{AdjointMedium} : bool, optional
\begin{quote}

Set ‘AdjointMedium=True’ to compute scattering coefficients and propagators in an adjoint medium \(^{(a)}\). For reciprocal media, the scattering coefficients and propagators are identical in a medium and its adjoint. We have defined the scattering and propagation in the adjoint medium only for flux-normalisation.
\end{quote}

\item[{Returns}] \leavevmode
class
\begin{quote}
\begin{description}
\item[{A class to model a wavefield in a 1.5D non-reciprocal medium in the ray-parameter frequency domain. The following instances are defined:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{x3vec}: \(x_3\).

\end{itemize}
\begin{itemize}
\item {} 
\sphinxstylestrong{avec}: \(\alpha\).

\item {} 
\sphinxstylestrong{bvec}: \(\beta\).

\item {} 
\sphinxstylestrong{g1vec}: \(\gamma_1\).

\item {} 
\sphinxstylestrong{g3vec}: \(\gamma_3\).

\item {} 
\sphinxstylestrong{p1}: Horizontal ray-parameter.

\item {} 
\sphinxstylestrong{ReciprocalMedium}: True for reciprocal media, False for non-reciprocal media.

\item {} 
\sphinxstylestrong{AdjointMedium}: If True, propagation and scatteing are defined in a medium and in its adjoint.

\item {} 
\sphinxstylestrong{p3}: Vertical ray-parameter for positive ‘p1’.

\item {} 
\sphinxstylestrong{p3n}: Vertical ray-parameter for negative ‘p1’.

\end{itemize}

\end{description}
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} \begin{description}
\item[{We format the data as described below.}] \leavevmode\begin{itemize}
\item {} 
Wavefields are saved in an array of dimensions (nf,nr) in the frequency domain and (nt,nr) in the time domain.

\item {} 
Wavefields are in the p- \(\omega\) domain.

\item {} 
The zero frequency component is placed at the first index position.

\item {} 
If the wavefield is transformed to the time domain, the zero time component is placed at the first index position, followed by nt/2-1 positive time samples and nt/2 negative time samples.

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{For evanescent waves, Kees makes a sign choice for the vertical ray-parameter,}] \leavevmode\begin{itemize}
\item {} 
\(p_3' = -j \sqrt{p_1^2 - (\alpha \beta + \gamma_1^2 + \gamma_3^2)}\).

\end{itemize}

\item[{By default, \sphinxstylestrong{NumPy} makes the oppostie sign choice, }] \leavevmode\begin{itemize}
\item {} 
\(p_3' = +j \sqrt{p_1^2 - (\alpha \beta + \gamma_1^2 + \gamma_3^2)}\).

\end{itemize}

\item[{We stick to the sign choice by \sphinxstylestrong{NumPy}. Thus, we will also change the sign choice for the propagators,}] \leavevmode\begin{itemize}
\item {} 
Kees chose: \(\tilde{w}^{\pm} = \mathrm{exp}(-j \omega p_3' \Delta x_3)\).

\item {} 
We choose: \(\tilde{w}^{\pm} = \mathrm{exp}(+j \omega p_3' \Delta x_3)\).

\end{itemize}

\end{description}

\end{itemize}
\paragraph{References}

Kees document as soon as it is published.
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{LM}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Initialise wavefield in a layered non\PYGZhy{}reciprocal medium}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{2.2}\PYG{p}{,}\PYG{l+m+mf}{3.7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p1}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{,}\PYG{n}{ReciprocalMedium}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}
\index{FocusingFunction\_p\_w() (Layered\_NRM\_p\_w.Layered\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Layered_NRM_p_w:Layered_NRM_p_w.Layered_NRM_p_w.FocusingFunction_p_w}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{FocusingFunction\_p\_w}}}{\emph{x3F}, \emph{normalisation='flux'}, \emph{InternalMultiples=True}}{}
computes the focusing functions between the top surface (\(x_3=0\)) and the focusing depth defined by the input variable ‘x3F’. We define the focusing depth just below ‘x3F’. Hence, if the focusing depth coincides with an interface the focusing function focuses below that interface.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{x3F} : int,float
\begin{quote}

Focusing depth.
\end{quote}

\sphinxstylestrong{normalisation} : str, optional
\begin{quote}

For pressure-normalisation set normalisation=’pressure’, for flux-normalisation set normalisation=’flux’. Until now, this function only models the focusing function for flux-normalisation.
\end{quote}

\sphinxstylestrong{InternalMultiples} : bool, optional
\begin{quote}

To model internal multiples set ‘InternalMultiples=True’. To ignore internal multiples set ‘InternalMultiples=False’.
\end{quote}

\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains }] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{FP}: Downgoing focusing function.

\item {} 
\sphinxstylestrong{RP}: Reflection response from above.

\item {} 
\sphinxstylestrong{TP}: Transmission response from above.

\item {} 
\sphinxstylestrong{FM}: Upgoing focusing function.

\item {} 
\sphinxstylestrong{RM}: Reflection response from below.

\item {} 
\sphinxstylestrong{TM}: Transmission response from below.

\item {} 
\sphinxstylestrong{FPa}: Downgoing focusing function (adjoint medium).

\item {} 
\sphinxstylestrong{RPa}: Reflection response from above (adjoint medium).

\item {} 
\sphinxstylestrong{TPa}: Transmission response from above (adjoint medium).

\item {} 
\sphinxstylestrong{FMa}: Upgoing focusing function (adjoint medium).

\item {} 
\sphinxstylestrong{RMa}: Reflection response from below (adjoint medium).

\item {} 
\sphinxstylestrong{TMa}: Transmission response from below (adjoint medium).

\end{itemize}

\end{description}

All medium responses are stored in arrays of shape (nf,1). The variables ‘FPa’, ‘RPa’, ‘TPa’, ‘FMa’, ‘RMa’ and ‘TMa’ are computed only if one sets ‘AdjointMedium=True’.
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} \begin{description}
\item[{The downgoing focusing funtion \(\tilde{F}_1^+\) is computed by inverting the expressions for the transmission from above \(\tilde{T}^+\):}] \leavevmode
\(\tilde{F}_{1,n}^+ = \tilde{F}_{1,n-1}^+ (\tilde{w}_n^+)^{-1} (1 - \tilde{w}_n^+ \tilde{R}_{n-1}^{\cap} \tilde{w}_n^- \tilde{r}_n^{\cup} )^{-1} (\tilde{t}_n^+)^{-1}\)

\end{description}

\item {} \begin{description}
\item[{The upgoing focusing function is computed by applying the reflection response \(R^{\cup}\) on the downgoing focusing funtion \(\tilde{F}_1^+\):}] \leavevmode
\(\tilde{F}_{1,n}^- = \tilde{R}^{\cup} \tilde{F}_{1,n}^+\).

\end{description}

\end{itemize}
\paragraph{References}

Kees document as soon as it is published.
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{LM}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(} \PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{150}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }      \PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }      \PYG{n}{g1vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.14}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }      \PYG{n}{p1}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{,}\PYG{n}{ReciprocalMedium}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{AdjointMedium}\PYG{o}{=}\PYG{k+kc}{True} \PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{GreensFunction\_p\_w() (Layered\_NRM\_p\_w.Layered\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Layered_NRM_p_w:Layered_NRM_p_w.Layered_NRM_p_w.GreensFunction_p_w}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GreensFunction\_p\_w}}}{\emph{x3R}, \emph{x3S}, \emph{normalisation='flux'}, \emph{InternalMultiples=True}}{}
computes the one-way Green’s functions for a receiver and source depth defined by the input variables ‘x3R’ and ‘x3S’. The one-way wavefields are decomposed at the receiver- and at the source-side. We define the receiver and source depths just below ‘x3R’ and ‘x3S’, respectively (this is important if the receiver or source depth coincides with an interface).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{x3R} : int,float
\begin{quote}

Receiver depth.
\end{quote}

\sphinxstylestrong{x3S} : int, float
\begin{quote}

Source depth.
\end{quote}

\sphinxstylestrong{normalisation} : str, optional
\begin{quote}

For pressure-normalisation set normalisation=’pressure’, for flux-normalisation set normalisation=’flux’.
\end{quote}

\sphinxstylestrong{InternalMultiples} : bool, optional
\begin{quote}

To model internal multiples set ‘InternalMultiples=True’. To ignore internal multiples set ‘InternalMultiples=False’.
\end{quote}

\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains }] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{GPP}: Green’s function \(G^{+,+}\) (true medium).

\item {} 
\sphinxstylestrong{GPM}: Green’s function \(G^{+,-}\) (true medium).

\item {} 
\sphinxstylestrong{GMP}: Green’s function \(G^{-,+}\) (true medium).

\item {} 
\sphinxstylestrong{GMM}: Green’s function \(G^{-,-}\) (true medium).

\item {} 
\sphinxstylestrong{GPPa}: Green’s function \(G^{+,+}\) (adjoint medium).

\item {} 
\sphinxstylestrong{GPMa}: Green’s function \(G^{+,-}\) (adjoint medium).

\item {} 
\sphinxstylestrong{GMPa}: Green’s function \(G^{-,+}\) (adjoint medium).

\item {} 
\sphinxstylestrong{GMMa}: Green’s function \(G^{-,-}\) (adjoint medium).

\end{itemize}

\end{description}

All medium responses are stored in arrays of shape (nf,1). The variables ‘GPPa’, ‘GPMa’, ‘GMPa’ and ‘GMMa’ are computed only if one sets ‘AdjointMedium=True’.
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} 
The superscript ‘+’ and ‘-‘ refer to downgoing and upgoing waves, respectively.

\item {} 
The first superscript refers to the wavefield at the receiver-side.

\item {} 
The second superscript refers to the wavefield at the source-side.

\end{itemize}
\paragraph{References}

Kees document as soon as it is published.
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{LM}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(} \PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{150}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }      \PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }      \PYG{n}{g1vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.14}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }      \PYG{n}{p1}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{,}\PYG{n}{ReciprocalMedium}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{AdjointMedium}\PYG{o}{=}\PYG{k+kc}{True} \PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{G} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{GreensFunction\PYGZus{}p\PYGZus{}w}\PYG{p}{(}\PYG{n}{x3R}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{x3S}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{normalisation}\PYG{o}{=}\PYG{n}{normalisation}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                         \PYG{n}{InternalMultiples}\PYG{o}{=}\PYG{n}{InternalMultiples}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{RT}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{RT\PYGZus{}response\PYGZus{}p\PYGZus{}w}\PYG{p}{(}\PYG{n}{normalisation}\PYG{o}{=}\PYG{n}{normalisation}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }                     \PYG{n}{InternalMultiples}\PYG{o}{=}\PYG{n}{InternalMultiples}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{RT}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{G}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GMP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{0.0}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Insert\_layer() (Layered\_NRM\_p\_w.Layered\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Layered_NRM_p_w:Layered_NRM_p_w.Layered_NRM_p_w.Insert_layer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Insert\_layer}}}{\emph{x3}, \emph{UpdateSelf=False}}{}
inserts a transparent interface at the depth level ‘x3’. If ‘x3’ coincides with an interface of the model the model’s interface is left unchanged. If ‘x3’ is a vector it is interpreted as multiple depth levels at which transparent interfaces will be inserted.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{x3} : int, float, numpy.ndarray
\begin{quote}

A depth level, or a vector of depth levels, at which a transparent interface will be inserted. The variable ‘x3’ either must be a scalar, or have the shape (n,). Each element of ‘x3’ must be real-valued and greater than, or equal to zero.
\end{quote}

\sphinxstylestrong{UpdateSelf} : bool, optional
\begin{quote}

Set ‘UpdateSelf=True’ to not only output an updated model but also update the ‘self’ parameters.
\end{quote}

\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains }] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{x3vec}: Updated depth vector.

\item {} 
\sphinxstylestrong{avec}: Updated \(\alpha\) vector.

\item {} 
\sphinxstylestrong{bvec}: Updated \(\beta\) vector.

\item {} 
\sphinxstylestrong{g1vec}: Updated \(\gamma_1\) vector.

\item {} 
\sphinxstylestrong{g3vec}: Updated \(\gamma_3\) vector.

\item {} 
\sphinxstylestrong{p3}: Updated \(p_3(p_1)\) vector.

\item {} 
\sphinxstylestrong{p3n}: Updated \(p_3(-p_1)\) vector.

\end{itemize}

\end{description}

All medium parameter vectors are stored in arrays of shape (n,).
\end{quote}

\end{description}\end{quote}
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{LM}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Initialise a wavefield in a 1D reciprocal medium}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{150}\PYG{p}{,}\PYG{l+m+mi}{200}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }     \PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g1vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }     \PYG{n}{g3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.14}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p1}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Insert a transparent layer at x3=1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{Insert\PYGZus{}layer}\PYG{p}{(}\PYG{n}{x3}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{UpdateSelf}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Updated depth vector}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x3vec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{array([  1,  10, 150, 200])}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Updated alpha vector}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{avec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{array([1, 1, 2, 3])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{L\_eigenvectors\_p\_w() (Layered\_NRM\_p\_w.Layered\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Layered_NRM_p_w:Layered_NRM_p_w.Layered_NRM_p_w.L_eigenvectors_p_w}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{L\_eigenvectors\_p\_w}}}{\emph{beta=None}, \emph{g3=None}, \emph{p3=None}, \emph{p3n=None}, \emph{normalisation='flux'}}{}
computes the eigenvector matrix ‘L’ and its inverse ‘Linv’, either in flux- or in pressure-normalisation for a single vertical ray-parameter ‘p3’ inside a homogeneous layer. If ‘AdjointMedium=True’, \sphinxstylestrong{L\_eigenvectors\_p\_w} also computes the eigenvector matrix in the adjoint medium ‘La’ and its inverse ‘Lainv’.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{beta} : int, float
\begin{quote}

Medium parameter \(\beta\)  (real-valued).
\end{quote}

\sphinxstylestrong{g3} : int, float
\begin{quote}

Medium parameter \(\gamma_3\).
\end{quote}

\sphinxstylestrong{p3} : int, float
\begin{quote}

Vertical ray-parameter \(p_3\) for a positive horizontal ray-parameter \(p_1\).
\end{quote}

\sphinxstylestrong{p3n} : int, float, optional (required if ‘AdjointMedium=True’)
\begin{quote}

Vertical ray-parameter \(p_3\) for a negative horizontal ray-parameter \(p_1\).
\end{quote}

\sphinxstylestrong{normalisation} : str, optional
\begin{quote}

For pressure-normalisation set normalisation=’pressure’, for flux-normalisation set normalisation=’flux’.
\end{quote}

\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains }] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{L}: The eigenvector matrix.

\item {} 
\sphinxstylestrong{Linv}: The inverse of the eigenvector matrix.

\item {} 
\sphinxstylestrong{La}: The eigenvector matrix (adjoint medium).

\item {} 
\sphinxstylestrong{Lainv}: The inverse of the eigenvector matrix (adjoint medium).

\end{itemize}

\end{description}

All eigenvector matrices are stored in a in a (2x2)-array.
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} 
The eigenvector matrix ‘L’ and its inverse ‘Linv’ are different for reciprocal and non-reciprocal media.

\item {} 
For reciprocal media, the eigenvectors of the adjoint medium are identical to the eigenvectors of the true medium.

\item {} 
We have defined the eigenvectors of the adjoint medium only for flux-normalisation.

\end{itemize}
\paragraph{References}

Kees document as soon as it is published.
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{LM}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Initialise wavefield in a layered non\PYGZhy{}reciprocal medium}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(} \PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024} \PYG{p}{,} \PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005} \PYG{p}{,} \PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{2.2}\PYG{p}{,}\PYG{l+m+mf}{3.7}\PYG{p}{]}\PYG{p}{)} \PYG{p}{,} \PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)} \PYG{p}{,} \PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)} \PYG{p}{,} \PYG{n}{g1vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)} \PYG{p}{,} \PYG{n}{g3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.14}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)} \PYG{p}{,} \PYG{n}{p1}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4} \PYG{p}{,} \PYG{n}{ReciprocalMedium}\PYG{o}{=}\PYG{k+kc}{False} \PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Compute eigenvectors in flux\PYGZhy{}normalisation}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Lvecs}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{L\PYGZus{}eigenvectors\PYGZus{}p\PYGZus{}w}\PYG{p}{(}\PYG{n}{beta}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{g3}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{n}{p3}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{,}\PYG{n}{normalisation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flux}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Eigenvector matrix}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{L} \PYG{o}{=} \PYG{n}{Lvecs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{([[15.8113883 +0.j, 15.8113883 +0.j],[ 0.03162278+0.j, \PYGZhy{}0.03162278+0.j]])}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Inverse eigenvector matrix}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Linv} \PYG{o}{=} \PYG{n}{Lvecs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Linv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{([[  0.03162278+0.j,  15.8113883 +0.j],[  0.03162278+0.j, \PYGZhy{}15.8113883 \PYGZhy{}0.j]])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{RT\_p\_w() (Layered\_NRM\_p\_w.Layered\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Layered_NRM_p_w:Layered_NRM_p_w.Layered_NRM_p_w.RT_p_w}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{RT\_p\_w}}}{\emph{beta\_u=None}, \emph{g3\_u=None}, \emph{p3\_u=None}, \emph{p3n\_u=None}, \emph{beta\_l=None}, \emph{g3\_l=None}, \emph{p3\_l=None}, \emph{p3n\_l=None}, \emph{normalisation='flux'}}{}
computes the scattering coefficients at an horizontal interface, either in flux- or in pressure-normalisation. The variables with subscript ‘u’ refer to the medium parameters in the upper half-space, the variables with subscript ‘l’ refer to the medium parameters in the lower half-space. We consider a single horizontal ray-parameter \(p_1\), which is associated with a vertical ray-parameter ‘p3\_u’ in the upper half-space and ‘p3\_l’ in the lower half-space. If one sets ‘AdjointMedium=True’, \sphinxstylestrong{RT\_p\_w} also computes the scattering coefficients in the adjoint medium.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{beta\_u} : int, float
\begin{quote}

Medium parameter \(\beta\) (real-valued) (upper half-space).
\end{quote}

\sphinxstylestrong{g3\_u} : int, float
\begin{quote}

Medium parameter \(\gamma_3\) (upper half-space).
\end{quote}

\sphinxstylestrong{p3\_u} : int, float
\begin{quote}

Vertical ray-parameter \(p_3\) for a positive horizontal ray-parameter \(p_1\) (upper half-space).
\end{quote}

\sphinxstylestrong{p3n\_u} : int, float, optional (required if ‘AdjointMedium=True’)
\begin{quote}

Vertical ray-parameter \(p_3\) for a negative horizontal ray-parameter \(p_1\) (upper half-space).
\end{quote}

\sphinxstylestrong{beta\_l} : int, float
\begin{quote}

Medium parameter \(\beta\) (real-valued) (lower half-space).
\end{quote}

\sphinxstylestrong{g3\_l} : int, float
\begin{quote}

Medium parameter \(\gamma_3\) (lower half-space).
\end{quote}

\sphinxstylestrong{p3\_l} : int, float
\begin{quote}

Vertical ray-parameter \(p_3\) for a positive horizontal ray-parameter \(p_1\) (lower half-space).
\end{quote}

\sphinxstylestrong{p3n\_l} : int, float, optional (required if ‘AdjointMedium=True’)
\begin{quote}

Vertical ray-parameter \(p_3\) for a negative horizontal ray-parameter \(p_1\) (lower half-space).
\end{quote}

\sphinxstylestrong{normalisation} : str, optional
\begin{quote}

For pressure-normalisation set normalisation=’pressure’, for flux-normalisation set normalisation=’flux’.
\end{quote}

\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains }] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{rP}: Reflection coefficient from above.

\item {} 
\sphinxstylestrong{tP}: Transmission coefficient from above ‘tP’.

\item {} 
\sphinxstylestrong{rM}: Reflection coefficient from below.

\item {} 
\sphinxstylestrong{tM}: Transmission coefficient from below.

\item {} 
\sphinxstylestrong{rPa}: Reflection coefficient from above (adjoint medium).

\item {} 
\sphinxstylestrong{tPa}: Transmission coefficient from above (adjoint medium).

\item {} 
\sphinxstylestrong{rMa}: Reflection coefficient from below (adjoint medium).

\item {} 
\sphinxstylestrong{tMa}: Transmission coefficient from below (adjoint medium).

\end{itemize}

\end{description}

All scattering coefficients are stored as scalars.
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}
\begin{itemize}
\item {} 
For reciprocal media, the scattering coefficients of the adjoint medium are identical to the scattering coefficients of the true medium.

\item {} 
We have defined the scattering coefficients of the adjoint medium only for flux-normalisation.

\end{itemize}
\paragraph{References}

Kees document as soon as it is published.
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{LM}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create wavefield F for positive horizontal ray\PYGZhy{}parameter p1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{2.2}\PYG{p}{,}\PYG{l+m+mf}{3.7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g1vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.14}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p1}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{,}\PYG{n}{ReciprocalMedium}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{AdjointMedium}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ScatCoeffs} \PYG{o}{=} \PYG{n}{F}\PYG{o}{.}\PYG{n}{RT\PYGZus{}p\PYGZus{}w}\PYG{p}{(}\PYG{n}{beta\PYGZus{}u}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{bvec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{g3\PYGZus{}u}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{g3vec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p3\PYGZus{}u}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{p3}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p3n\PYGZus{}u}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{p3n}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{beta\PYGZus{}l}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{bvec}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{g3\PYGZus{}l}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{g3vec}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p3\PYGZus{}l}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{p3}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p3n\PYGZus{}l}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{p3n}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{normalisation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flux}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{rplus} \PYG{o}{=} \PYG{n}{ScatCoeffs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{(0.8620013269525346+0.5069060192304582j)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Create wavefield Fn for negative horizontal ray\PYGZhy{}parameter p1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Fn}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{2.2}\PYG{p}{,}\PYG{l+m+mf}{3.7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g1vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.14}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p1}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{,}\PYG{n}{ReciprocalMedium}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}\PYG{n}{AdjointMedium}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ScatCoeffsn} \PYG{o}{=} \PYG{n}{Fn}\PYG{o}{.}\PYG{n}{RT\PYGZus{}p\PYGZus{}w}\PYG{p}{(}\PYG{n}{beta\PYGZus{}u}\PYG{o}{=}\PYG{n}{Fn}\PYG{o}{.}\PYG{n}{bvec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{g3\PYGZus{}u}\PYG{o}{=}\PYG{n}{Fn}\PYG{o}{.}\PYG{n}{g3vec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p3\PYGZus{}u}\PYG{o}{=}\PYG{n}{Fn}\PYG{o}{.}\PYG{n}{p3}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p3n\PYGZus{}u}\PYG{o}{=}\PYG{n}{Fn}\PYG{o}{.}\PYG{n}{p3n}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{beta\PYGZus{}l}\PYG{o}{=}\PYG{n}{Fn}\PYG{o}{.}\PYG{n}{bvec}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{g3\PYGZus{}l}\PYG{o}{=}\PYG{n}{Fn}\PYG{o}{.}\PYG{n}{g3vec}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p3\PYGZus{}l}\PYG{o}{=}\PYG{n}{Fn}\PYG{o}{.}\PYG{n}{p3}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{p3n\PYGZus{}l}\PYG{o}{=}\PYG{n}{Fn}\PYG{o}{.}\PYG{n}{p3n}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{n}{normalisation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flux}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} In non\PYGZhy{}reciprocal media, for flux\PYGZhy{}normalisation, the reflection coefficients}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} in true medium for positive horizontal ray\PYGZhy{}parameter p1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} and in adjoint medium for negative horizontal ray\PYGZhy{}parameter p1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} are identical:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{ScatCoeffs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{ScatCoeffsn}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rPa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{0.0}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{RT\_response\_p\_w() (Layered\_NRM\_p\_w.Layered\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Layered_NRM_p_w:Layered_NRM_p_w.Layered_NRM_p_w.RT_response_p_w}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{RT\_response\_p\_w}}}{\emph{x3vec=None}, \emph{avec=None}, \emph{bvec=None}, \emph{g1vec=None}, \emph{g3vec=None}, \emph{normalisation='flux'}, \emph{InternalMultiples=True}}{}
computes the reflection and transmission responses from above and from below. If medium parameters are given the computed responses are associated with the given parameters medium. Otherwise, the medium parameters defined in \sphinxstylestrong{Layered\_NRM\_p\_w} are used.

The medium responses are associated to measurements at \(x_3=0\) and at \(x_3=\) ‘x3vec{[}-2{]}’ \(+\epsilon\), where \(\epsilon\) is an infinitesimally small positive constant. Hence, the propagation from \(x_3=0\) to the shallowest interface is included. However, the propagation through the deepest layer is excluded.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{x3vec} : numpy.ndarray, optional
\begin{quote}

Vertical spatial vector \(x_3\), for n layers ‘x3vec’ must have the shape (n,). We define the \(x_3\)-axis as downward-pointing. Implicitly, the first value on the \(x_3\)-axis is zero (not stored in ‘x3vec’).
\end{quote}

\sphinxstylestrong{avec} : numpy.ndarray, optional
\begin{quote}

Medium parameter \(\alpha\) (real-valued), for n layers ‘avec’ must have the shape (n,).
\end{quote}

\sphinxstylestrong{bvec} : numpy.ndarray, optional
\begin{quote}

Medium parameter \(\beta\) (real-valued), for n layers ‘bvec’ must have the shape (n,).
\end{quote}

\sphinxstylestrong{g1vec} : numpy.ndarray, optional
\begin{quote}

Medium parameter \(\gamma_1\) (real-valued for non-reciprocal media or imaginary-valued for reciprocal media), for n layers ‘g1vec’ must have the shape (n,).
\end{quote}

\sphinxstylestrong{g3vec} : numpy.ndarray, optional
\begin{quote}

Medium parameter \(\gamma_3\) (real-valued for non-reciprocal media or imaginary-valued for reciprocal media), for n layers ‘g3vec’ must have the shape (n,).
\end{quote}

\sphinxstylestrong{normalisation} : str, optional
\begin{quote}

For pressure-normalisation set normalisation=’pressure’, for flux-normalisation set normalisation=’flux’.
\end{quote}

\sphinxstylestrong{InternalMultiples} : bool, optional
\begin{quote}

To model internal multiples set ‘InternalMultiples=True’. To ignore internal multiples set ‘InternalMultiples=False’.
\end{quote}

\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains }] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{RP}: Reflection response from above.

\item {} 
\sphinxstylestrong{TP}: Transmission response from above.

\item {} 
\sphinxstylestrong{RM}: Reflection response from below.

\item {} 
\sphinxstylestrong{TM}: Transmission response from below.

\item {} 
\sphinxstylestrong{RPa}: Reflection response from above (adjoint medium).

\item {} 
\sphinxstylestrong{TPa}: Transmission response from above (adjoint medium).

\item {} 
\sphinxstylestrong{RMa}: Reflection response from below (adjoint medium).

\item {} 
\sphinxstylestrong{TMa}: Transmission response from below (adjoint medium).

\end{itemize}

\end{description}

All medium responses are stored in arrays of shape (nf,1). The variables ‘RPa’, ‘TPa’, ‘RMa’ and ‘TMa’ are computed only if one sets ‘AdjointMedium=True’.
\end{quote}

\end{description}\end{quote}
\paragraph{References}

Kees document as soon as it is published.
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{LM}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Initialise a wavefield in a 1D reciprocal medium}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Here, the parameters are chosen such that the wavefield is purely propagating (not evanescent)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{l+m+mi}{500}\PYG{p}{,}\PYG{l+m+mi}{1000}\PYG{p}{,}\PYG{l+m+mi}{1010}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mf}{1.5}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g1vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{l+m+mf}{0.25}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.14}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p1}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{,}\PYG{n}{ReciprocalMedium}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Model the medium responses}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Responses}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{RT\PYGZus{}response\PYGZus{}p\PYGZus{}w}\PYG{p}{(}\PYG{n}{normalisation}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{flux}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{InternalMultiples}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Here are your first medium responses:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Rplus} \PYG{o}{=} \PYG{n}{Responses}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Tplus} \PYG{o}{=} \PYG{n}{Responses}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Verify if conservation of energy is satisfied}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{Rplus}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Rplus}\PYG{o}{+}\PYG{n}{Tplus}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{n}{Tplus}
\PYG{g+go}{([[1.+0.j], [1.+0.j], ..., [1.+0.j]])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{W\_propagators\_p\_w() (Layered\_NRM\_p\_w.Layered\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Layered_NRM_p_w:Layered_NRM_p_w.Layered_NRM_p_w.W_propagators_p_w}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{W\_propagators\_p\_w}}}{\emph{p3=None}, \emph{p3n=None}, \emph{g3=None}, \emph{dx3=None}, \emph{w=None}}{}
computes the downgoing propagator ‘wP’ and the upgoing progagator ‘wM’ for a single vertical ray-parameter ‘p3’ and a vertical distance ‘dx3’ (downward pointing \(x_3\)-axis).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{p3} : int, float
\begin{quote}

Vertical ray-parameter \(p_3\) for a positive horizontal ray-parameter \(p_1\).
\end{quote}

\sphinxstylestrong{p3n} : int, float, optional (required if ‘AdjointMedium=True’)
\begin{quote}

Vertical ray-parameter \(p_3\) for a negative horizontal ray-parameter \(p_1\).
\end{quote}

\sphinxstylestrong{g3} : int, float
\begin{quote}

Medium parameter \(\gamma_3\).
\end{quote}

\sphinxstylestrong{dx3} : int, float
\begin{quote}

Vertical propagation distance \(\Delta x_3\) (downward pointing \(x_3\)-axis).
\end{quote}

\sphinxstylestrong{w} : int, float
\begin{quote}

Frequency \(\omega\) in radians. By default the propagators are computed for all sampled (positive) frequencies.
\end{quote}

\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains }] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{wP}: Downward propagator \(\tilde{w}^+\).

\item {} 
\sphinxstylestrong{wM}: Upward propagator \(\tilde{w}^-\).

\item {} 
\sphinxstylestrong{wPa}: Downward propagator \(\tilde{w}^{+(a)}\) (adjoint medium).

\item {} 
\sphinxstylestrong{wMa}: Upward propagator \(\tilde{w}^{-(a)}\) (adjoint medium).

\end{itemize}

\end{description}

All propagators are stored either in an arrays of shape (nf,1), or as a scalar (if the variable’w’ is set). The variables ‘wPa’ and ‘wMa’ are computed only if one sets ‘AdjointMedium=True’.
\end{quote}

\end{description}\end{quote}
\paragraph{References}

Kees document as soon as it is published.
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Layered\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{LM}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{LM}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{x3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{2.2}\PYG{p}{,}\PYG{l+m+mf}{3.7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{avec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{bvec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{3.14}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g1vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.9}\PYG{p}{,}\PYG{l+m+mf}{2.1}\PYG{p}{,}\PYG{l+m+mf}{0.3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{g3vec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{1.14}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{p1}\PYG{o}{=}\PYG{l+m+mf}{2e\PYGZhy{}4}\PYG{p}{,}\PYG{n}{ReciprocalMedium}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{W}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{W\PYGZus{}propagators\PYGZus{}p\PYGZus{}w}\PYG{p}{(} \PYG{n}{p3}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{p3}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{,} \PYG{n}{p3n}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{p3n}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{,} \PYG{n}{g3}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{g3vec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{,} \PYG{n}{dx3}\PYG{o}{=}\PYG{n}{F}\PYG{o}{.}\PYG{n}{x3vec}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{F}\PYG{o}{.}\PYG{n}{x3vec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{W}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{[[ 1.00000000e+00+0.        j],[0.24690276+0.34159244j],...,[1.07001473e\PYGZhy{}192\PYGZhy{}1.48037608e\PYGZhy{}192j]]}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} The propagator has nf samples because it is computed only for positive frequencies}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{W}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{shape}
\PYG{g+go}{(513, 1)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} AdjointMedium=False, hence, we expect output \PYGZsq{}None\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{W}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wPa}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}



\section{Wavefield\_NRM\_p\_w module}
\label{\detokenize{Wavefield_NRM_p_w::doc}}\label{\detokenize{Wavefield_NRM_p_w:module-Wavefield_NRM_p_w}}\label{\detokenize{Wavefield_NRM_p_w:wavefield-nrm-p-w-module}}\index{Wavefield\_NRM\_p\_w (module)}
Routines for modelling wavefields in 1D non-reciprocal media.

\phantomsection\label{\detokenize{Wavefield_NRM_p_w:module-Wavefield_NRM_p_w}}\index{Wavefield\_NRM\_p\_w (module)}\begin{quote}\begin{description}
\item[{Authors}] \leavevmode
Christian Reinicke (\sphinxhref{mailto:c.reinicke@tudelft.nl}{c.reinicke@tudelft.nl}), Kees Wapenaar (), and Evert Slob ()

\item[{Copyright}] \leavevmode
Christian Reinicke (\sphinxhref{mailto:c.reinicke@tudelft.nl}{c.reinicke@tudelft.nl}), Kees Wapenaar (), and Evert Slob ()

\end{description}\end{quote}
\index{Wavefield\_NRM\_p\_w (class in Wavefield\_NRM\_p\_w)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Wavefield\_NRM\_p\_w.}}\sphinxbfcode{\sphinxupquote{Wavefield\_NRM\_p\_w}}}{\emph{nt}, \emph{dt}, \emph{nr=1}, \emph{dx1=1}, \emph{verbose=False}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}%
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#object}
%
\end{footnote}

is a class to define a scalar wavefield in the ray-parameter frequency domain.

The class Wavefield\_NRM\_p\_w defines the parameters of a scalar wavefield in a 1.5D (non-)reciprocal medium. We consider a single ray-parameter ‘p1’ and all frequencies that are sampled by the given number of time samples ‘nt’ and the time sample interval ‘dt’.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{nt} : int
\begin{quote}

Number of time samples.
\end{quote}

\sphinxstylestrong{dt} : int, float
\begin{quote}

Time sample interval in seconds.
\end{quote}

\sphinxstylestrong{nr} : int, optional
\begin{quote}

Number of space samples.
\end{quote}

\sphinxstylestrong{dx1} : int, float, optional
\begin{quote}

Space sample interval.
\end{quote}

\sphinxstylestrong{verbose} : bool, optional
\begin{quote}

Set ‘verbose=True’ to receive feedback in the command line.
\end{quote}

\item[{Returns}] \leavevmode
class
\begin{quote}
\begin{description}
\item[{A class to define a wavefield in a 1.5D non-reciprocal medium in the ray-parameter frequency domain. The following instances are defined:}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{nt}: Number of time samples.

\item {} 
\sphinxstylestrong{dt}: Time sample interval in seconds.

\item {} 
\sphinxstylestrong{nr}: Number of space samples.

\item {} 
\sphinxstylestrong{dx1}: Number of space samples.

\item {} 
\sphinxstylestrong{verbose}: If one sets ‘verbose=True’ feedback will be output in the command line.

\item {} 
\sphinxstylestrong{nf}: Number of positive time samples \(=0.5 nt + 1\).

\item {} 
\sphinxstylestrong{nk}: Number of positive space samples \(=0.5 nr + 1\).

\end{itemize}

\end{description}
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}
\begin{description}
\item[{We format the data as described below.}] \leavevmode\begin{itemize}
\item {} 
Wavefields are saved in an array of dimensions (nf,nr) in the frequency domain and (nt,nr) in the time domain.

\item {} 
Wavefields are in the p- \(\omega\) domain.

\item {} 
The zero frequency component is placed at the first index position.

\item {} 
If the wavefield is transformed to the time domain, the zero time component is placed at the first index position, followed by nt/2-1 positive time samples and nt/2 negative time samples.

\end{itemize}

\end{description}
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Initialise a wavefield class}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{WF}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{WF}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{)}
\end{sphinxVerbatim}
\index{Dw() (Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w.Dw}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Dw}}}{}{}
returns frequency sampling interval \(\Delta\) \(\omega\) in radians.

The frequency sampling interval is defined by the time sampling interval \(\Delta t\) and the number of time samples ‘nt’.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
float
\begin{quote}

Frequency sample interval in radians \(\Delta \omega\) \(= \frac{2 \pi}{\Delta t \; nt}\)
\end{quote}

\end{description}\end{quote}
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{WF}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{WF}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{.}\PYG{n}{Dw}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{1.227184630308513}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{PT2PW() (Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w.PT2PW}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PT2PW}}}{\emph{array\_pt}, \emph{NumPy\_fft\_Sign\_Convention=False}}{}
applies an inverse Fourier transform from the \(p_1\)-\(t\) domain to the \(p_1\)-\(\omega\) domain.

We assume that the time domain signal is real-valued (\(p_1\)-\(t\) domain). Therefore, we use the NumPy function \sphinxcode{\sphinxupquote{numpy.fft.rfft}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{array\_pt} : numpy.ndarray
\begin{quote}

Real-valued array in the \(p_1\)-\(t\) domain, shape (nt,nr).
\end{quote}

\sphinxstylestrong{NumPy\_fft\_Sign\_Convention} : bool, optional
\begin{quote}

Set ‘NumPy\_fft\_Sign\_Convention=True’ if Numpy’s sign convention is used for the Fourier transform (negative sign in the exponential of the forward Fourier transform).
\end{quote}

\item[{Returns}] \leavevmode
numpy.ndarray
\begin{quote}

Array in the \(p_1\)-\(\omega\) domain, shape (nf,nr).
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

In the sub-class \sphinxstylestrong{Layered\_NRM\_p\_w} we define the wavefield propagators with a positive sign, \(\tilde{w}^{\pm} = \mathrm{exp}(+j \omega p_3' \Delta x_3)\). Thus, we implicitly assume that the forward Fourier transfrom is defined with a positive sign in the exponential function, which is why we set by default ‘NumPy\_fft\_Sign\_Convention=False’.

\end{fulllineitems}

\index{PW2PT() (Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w.PW2PT}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{PW2PT}}}{\emph{array\_pw}, \emph{NumPy\_fft\_Sign\_Convention=False}}{}
applies an inverse Fourier transform from the \(p_1\)-\(\omega\) domain to  the \(p_1\)-\(t\) domain.

We assume that the time domain signal is real-valued (\(p_1\)-\(t\) domain). Therefore, we use the NumPy function \sphinxcode{\sphinxupquote{numpy.fft.irfft}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstylestrong{array\_pw} : numpy.ndarray
\begin{quote}

Array in the \(p_1\)-\(\omega\) domain, shape (nf,nr).
\end{quote}

\sphinxstylestrong{NumPy\_fft\_Sign\_Convention} : bool, optional
\begin{quote}

Set ‘NumPy\_fft\_Sign\_Convention=True’ if Numpy’s sign convention is used for the inverse Fourier transform (positive sign in the exponential of the inverse Fourier transform).
\end{quote}

\item[{Returns}] \leavevmode
numpy.ndarray
\begin{quote}

Real-valued array in the \(p_1\)-\(t\) domain, shape (nt,nr).
\end{quote}

\end{description}\end{quote}
\paragraph{Notes}

In the sub-class \sphinxstylestrong{Layered\_NRM\_p\_w} we define the wavefield propagators with a positive sign, \(\tilde{w}^{\pm} = \mathrm{exp}(+j \omega p_3' \Delta x_3)\). Thus, we implicitly assume that the inverse Fourier transfrom is defined with a negative sign in the exponential function, which is why we set by default ‘NumPy\_fft\_Sign\_Convention=False’.

\end{fulllineitems}

\index{T\_X\_grid() (Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w.T_X_grid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{T\_X\_grid}}}{}{}
returns two time-space meshgrids.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains a meshgrid}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{Tgrid}: with the time vector \sphinxstyleemphasis{tvec} (the zero time sample is placed in the center) along the 1st dimension, and nr copies of it along the 2nd dimension.

\item {} 
\sphinxstylestrong{Xgrid}: with the offset vector \sphinxstyleemphasis{xvec} (the zero offset sample is placed in the center) along the 2nd dimension, and nt copies of it along the 1st dimension.

\item {} 
\sphinxstylestrong{Tgridfft}: with the time vector \sphinxstyleemphasis{tvecfft} (the zero time sample is placed at the first index position) along the 1st dimension, and nr copies of it along the 2nd dimension.

\item {} 
\sphinxstylestrong{Xgridfft}: with the offset vector \sphinxstyleemphasis{xvecfft} (the zero offset sample is placed at the first index position) along the 2nd dimension, and nt copies of it along the 1st dimension.

\end{itemize}

\end{description}

All output arrays have the shape (nt,nr).
\end{quote}

\end{description}\end{quote}
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{WF}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{WF}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{nr}\PYG{o}{=}\PYG{l+m+mi}{512}\PYG{p}{,}\PYG{n}{dx1}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{.}\PYG{n}{T\PYGZus{}X\PYGZus{}grid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tgridfft}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{array([ 0.   ,  0.005,  0.01 , ..., \PYGZhy{}0.015, \PYGZhy{}0.01 , \PYGZhy{}0.005])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Tvec() (Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w.Tvec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Tvec}}}{}{}
returns a vector of all time samples \(t\) in seconds.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains the time vector, }] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{tvec}: zero time placed at the center.

\item {} 
\sphinxstylestrong{tvecfft}: zero time placed at the first index position.

\end{itemize}

\end{description}

Both vectors have the shape (nt,1).
\end{quote}

\end{description}\end{quote}
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{WF}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{WF}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{nr}\PYG{o}{=}\PYG{l+m+mi}{512}\PYG{p}{,}\PYG{n}{dx1}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{.}\PYG{n}{Tvec}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tvec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{array([[\PYGZhy{}2.56 ], ..., [ 2.555]])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{W\_X\_grid() (Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w.W_X_grid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{W\_X\_grid}}}{}{}
returns two frequency-space meshgrids.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains a meshgrid}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{Wgrid}: with the frequency vector \sphinxstyleemphasis{wvec} (the zero frequency sample is placed in the center) along the 1st dimension, and nr copies of it along the 2nd dimension.

\item {} 
\sphinxstylestrong{Xgrid}: with the offset vector \sphinxstyleemphasis{xvec} (the zero offset sample is placed in the center) along the 2nd dimension, and nt copies of it along the 1st dimension.

\item {} 
\sphinxstylestrong{Xgridfft}: with the offset vector \sphinxstyleemphasis{xvecfft} (the zero offset sample is placed at the first index position) along the 2nd dimension, and nt copies of it along the 1st dimension.

\end{itemize}

\end{description}

All output arrays have the shape (nf,nr).
\end{quote}

\end{description}\end{quote}
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{WF}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{WF}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{nr}\PYG{o}{=}\PYG{l+m+mi}{512}\PYG{p}{,}\PYG{n}{dx1}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{.}\PYG{n}{W\PYGZus{}X\PYGZus{}grid}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Wgrid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+go}{array([ 0.        ,  1.22718463,  2.45436926, ..., 628.3185307179587])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Wvec() (Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w.Wvec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Wvec}}}{}{}
returns a vector of all frequency samples \(\omega\) in radians.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
numpy.ndarray
\begin{quote}

Frequency vector, zero frequency is placed at the first index position. The vector has the shape (nf,1).
\end{quote}

\end{description}\end{quote}
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{WF}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{WF}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{.}\PYG{n}{Wvec}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{array([[0.], ..., [628.31853072]])}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Xvec() (Wavefield\_NRM\_p\_w.Wavefield\_NRM\_p\_w method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{Wavefield_NRM_p_w:Wavefield_NRM_p_w.Wavefield_NRM_p_w.Xvec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Xvec}}}{}{}
returns a vector of all spatial samples \(x\) in metres.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dict
\begin{quote}
\begin{description}
\item[{Dictionary that contains the offset vector,}] \leavevmode\begin{itemize}
\item {} 
\sphinxstylestrong{xvec}: zero offset placed at the center.

\item {} 
\sphinxstylestrong{xvecfft}: zero offset placed at the first index position.

\end{itemize}

\end{description}

Both vectors have the shape (nt,1).
\end{quote}

\end{description}\end{quote}
\paragraph{Examples}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{import} \PYG{n}{Wavefield\PYGZus{}NRM\PYGZus{}p\PYGZus{}w} \PYG{k}{as} \PYG{n}{WF}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{=}\PYG{n}{WF}\PYG{p}{(}\PYG{n}{nt}\PYG{o}{=}\PYG{l+m+mi}{1024}\PYG{p}{,}\PYG{n}{dt}\PYG{o}{=}\PYG{l+m+mf}{0.005}\PYG{p}{,}\PYG{n}{nr}\PYG{o}{=}\PYG{l+m+mi}{512}\PYG{p}{,}\PYG{n}{dx1}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{F}\PYG{o}{.}\PYG{n}{Xvec}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{xvec}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+go}{array([[\PYGZhy{}2560.], ...,[ 2550.]])}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{l}
\item {\sphinxstyleindexentry{Layered\_NRM\_p\_w}}\sphinxstyleindexpageref{Layered_NRM_p_w:\detokenize{module-Layered_NRM_p_w}}
\indexspace
\bigletter{w}
\item {\sphinxstyleindexentry{Wavefield\_NRM\_p\_w}}\sphinxstyleindexpageref{Layered_NRM_p_w:\detokenize{module-Wavefield_NRM_p_w}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\footnotesize\raggedright\printindex
\end{document}