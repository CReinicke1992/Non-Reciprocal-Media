
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Layered_NRM_k1_w module &#8212; Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Wavefield_NRM_k1_w module" href="Wavefield_NRM_k1_w.html" />
    <link rel="prev" title="k1-w-domain" href="modules.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Wavefield_NRM_k1_w.html" title="Wavefield_NRM_k1_w module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="k1-w-domain"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" accesskey="U">k1-w-domain</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">k1-w-domain</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="Wavefield_NRM_k1_w.html"
                        title="next chapter">Wavefield_NRM_k1_w module</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Layered_NRM_k1_w.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-Layered_NRM_k1_w">
<span id="layered-nrm-k1-w-module"></span><h1>Layered_NRM_k1_w module<a class="headerlink" href="#module-Layered_NRM_k1_w" title="Permalink to this headline">¶</a></h1>
<p>Routines for modelling wavefields in 1.5D non-reciprocal media.</p>
<span class="target" id="module-Wavefield_NRM_k1_w-v2.0"></span><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Christian Reinicke (<a class="reference external" href="mailto:c&#46;reinicke&#37;&#52;&#48;tudelft&#46;nl">c<span>&#46;</span>reinicke<span>&#64;</span>tudelft<span>&#46;</span>nl</a>), Kees Wapenaar (), and Evert Slob ()</td>
</tr>
<tr class="field-even field"><th class="field-name">Copyright:</th><td class="field-body">Christian Reinicke (<a class="reference external" href="mailto:c&#46;reinicke&#37;&#52;&#48;tudelft&#46;nl">c<span>&#46;</span>reinicke<span>&#64;</span>tudelft<span>&#46;</span>nl</a>), Kees Wapenaar (), and Evert Slob ()</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w">
<em class="property">class </em><code class="descclassname">Layered_NRM_k1_w.</code><code class="descname">Layered_NRM_k1_w</code><span class="sig-paren">(</span><em>nt</em>, <em>dt</em>, <em>nr</em>, <em>dx1</em>, <em>verbose=False</em>, <em>eps=None</em>, <em>x3vec=array([0.])</em>, <em>avec=array([0.])</em>, <em>b11vec=array([0.])</em>, <em>b13vec=array([0.])</em>, <em>b33vec=array([0.])</em>, <em>g1vec=array([0.])</em>, <em>g3vec=array([0.])</em>, <em>ReciprocalMedium=False</em>, <em>AdjointMedium=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w" title="Wavefield_NRM_k1_w.Wavefield_NRM_k1_w"><code class="xref py py-class docutils literal notranslate"><span class="pre">Wavefield_NRM_k1_w.Wavefield_NRM_k1_w</span></code></a></p>
<p>is a class to model wavefields in 1.5D (non-)reciprocal media in the 
horizontal-wavenumber frequency domain.</p>
<p>The class Layered_NRM_k1_w defines a 1.5D (non-)reciprocal medium and a 
scalar wavefield. We consider all horizontal-wavenumbers and all 
frequencies, that are sampled by the given number of samples and by the 
given sample intervals, in space (‘nr’, ‘dx1’) as well as in time 
(‘nt’, ‘dt’).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nt</strong> : int</p>
<blockquote>
<div><p>Number of time samples.</p>
</div></blockquote>
<p><strong>dt</strong> : int, float</p>
<blockquote>
<div><p>Time sample interval in seconds.</p>
</div></blockquote>
<p><strong>nr</strong> : int</p>
<blockquote>
<div><p>Number of space samples.</p>
</div></blockquote>
<p><strong>dx1</strong> : int, float</p>
<blockquote>
<div><p>Space sample interval in metres.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, optional</p>
<blockquote>
<div><p>Set ‘verbose=True’ to receive feedback in the command line.</p>
</div></blockquote>
<p><strong>eps</strong> : int, float, optional</p>
<blockquote>
<div><p>A real-valued scalar can be assigned to ‘eps’ to reduce the wrap-around 
effect of wavefields in the time domain. If the inverse Fourier 
transform is defined as,</p>
<blockquote>
<div><p><span class="math notranslate">\(f(t)  = \int F(\omega) \; \mathrm{e}^{\mathrm{j} \omega t} 
\mathrm{d}\omega\)</span>,</p>
</div></blockquote>
<p>which is ensured if the function <strong>K1W2X1T</strong> is used, ‘eps’ 
(<span class="math notranslate">\(=\epsilon\)</span>) should be positive to the suppress wrap-around 
effect from positive to negative time,</p>
<blockquote>
<div><p><span class="math notranslate">\(f(t) \mathrm{e}^{- \epsilon t} = 
\int F(\omega + \mathrm{j} \epsilon) \; 
\mathrm{e}^{\mathrm{j} (\omega + \mathrm{j} \epsilon) t} 
\mathrm{d}\omega\)</span>.</p>
</div></blockquote>
<p>Recommended value eps = <span class="math notranslate">\(\frac{3 nf}{dt}\)</span>.</p>
</div></blockquote>
<p><strong>x3vec</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Vertical spatial vector <span class="math notranslate">\(x_3\)</span>, for n layers ‘x3vec’ must have the 
shape (n,). We define the <span class="math notranslate">\(x_3\)</span>-axis as downward-pointing. 
Implicitly, the first value on the <span class="math notranslate">\(x_3\)</span>-axis is zero (not stored 
in ‘x3vec’).</p>
</div></blockquote>
<p><strong>avec</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\alpha\)</span> (real-valued), for n layers ‘avec’ 
must have the shape (n,).</p>
</div></blockquote>
<p><strong>b11vec</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{11}\)</span> (real-valued), for n layers 
‘b11vec’ must have the shape (n,).</p>
</div></blockquote>
<p><strong>b13vec</strong> : numpy.ndarray, optional</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{13}\)</span> (real-valued), for n layers 
‘b13vec’ must have the shape (n,).</p>
</div></blockquote>
<p><strong>b33vec</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{33}\)</span> (real-valued), for n layers 
‘b33vec’ must have the shape (n,).</p>
</div></blockquote>
<p><strong>g1vec</strong> : numpy.ndarray, optional</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\gamma_1\)</span> (real-valued for non-reciprocal 
media), for n layers ‘g1vec’ must have the shape (n,).</p>
</div></blockquote>
<p><strong>g3vec</strong> : numpy.ndarray, optional</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\gamma_3\)</span> (real-valued for non-reciprocal 
media), for n layers ‘g3vec’ must have the shape (n,).</p>
</div></blockquote>
<p><strong>ReciprocalMedium</strong> : bool, optional</p>
<blockquote>
<div><p>For non-reciprocal media set ‘ReciprocalMedium=False’, for reciprocal 
media set ‘ReciprocalMedium=True’.</p>
</div></blockquote>
<p><strong>AdjointMedium</strong> : bool, optional</p>
<blockquote>
<div><p>Set ‘AdjointMedium=True’ to compute scattering coefficients and 
propagators in an adjoint medium <span class="math notranslate">\(^{(a)}\)</span>. We have defined the 
scattering and propagation in the adjoint medium only for 
flux-normalisation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">class</p>
<blockquote>
<div><p>A class to model a wavefield in a 1.5D non-reciprocal medium in the 
horizontal-wavenumber frequency domain. The following instances are 
defined:</p>
<blockquote>
<div><ul class="simple">
<li><strong>x3vec</strong>: <span class="math notranslate">\(x_3\)</span>.</li>
<li><strong>avec</strong>: <span class="math notranslate">\(\alpha\)</span>.</li>
<li><strong>b11vec</strong>: <span class="math notranslate">\(\beta_{11}\)</span>.</li>
<li><strong>b13vec</strong>: <span class="math notranslate">\(\beta_{13}\)</span>.</li>
<li><strong>b33vec</strong>: <span class="math notranslate">\(\beta_{33}\)</span>.</li>
<li><strong>g1vec</strong>: <span class="math notranslate">\(\gamma_1\)</span>.</li>
<li><strong>g3vec</strong>: <span class="math notranslate">\(\gamma_3\)</span>.</li>
<li><strong>ReciprocalMedium</strong>: True for reciprocal media, False for non-reciprocal media.</li>
<li><strong>AdjointMedium</strong>: If True, propagation and scattering are defined in a medium and in its adjoint.</li>
<li><strong>k3</strong>: Vertical-wavenumber for positive ‘k1’.</li>
<li><strong>k3n</strong>: Vertical-wavenumber for negative ‘k1’.</li>
</ul>
</div></blockquote>
</div></blockquote>
<div class="admonition-todo last admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p>(1) In non-reciprocal media, when I use a complex-valued frequency 
<span class="math notranslate">\(\omega'=\omega+\mathrm{j}\epsilon\)</span> the vertical wavenumber 
definition becomes</p>
<blockquote>
<div><blockquote>
<div><p><span class="math notranslate">\(k_3=\sqrt{(\alpha \beta_{11} -\gamma_1^2)\omega' 
+ 2\gamma_1 k_1 \omega' -k_1^2} = 
\sqrt{(\alpha \beta_{11} - \gamma_1^2) (\omega -\epsilon^2) 
+ 2\gamma_1 k_1 \omega -k_1^2 
+ \mathrm{j} 2 \epsilon 
[\omega (\alpha \beta_{11} -\gamma_1^2) + \gamma_1 k_1]}\)</span> .</p>
</div></blockquote>
<p>Hence, if</p>
<blockquote>
<div><p><span class="math notranslate">\(\mathrm{sign}(\epsilon 
[\omega (\alpha \beta_{11} -\gamma_1^2) + \gamma_1 k_1]) &lt; 0\)</span>,</p>
</div></blockquote>
<p>the imaginary part of <span class="math notranslate">\(k_3\)</span> becomes negative, and the 
wavefield components <span class="math notranslate">\(\mathrm{e}^{\mathrm{j}k_3 x_3}\)</span> become 
unstable. I fix that by manually modifying the vertical wavenumber 
to</p>
<blockquote>
<div><p><span class="math notranslate">\(k_{3,mod} = \sqrt{(\alpha \beta_{11} -\gamma_1^2) 
(\omega - \epsilon^2) + 2\gamma_1 k_1 \omega -k_1^2 
+ \mathrm{j} 2 \Vert \epsilon 
[\omega (\alpha \beta_{11} -\gamma_1^2) + \gamma_1 k_1] \Vert}\)</span> .</p>
</div></blockquote>
<p>For those <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> components for which the 
absolute value in <span class="math notranslate">\(k_{3,mod}\)</span> has an effect, I effectively 
change the sign of <span class="math notranslate">\(\epsilon\)</span>. Can we justify this fix? If 
not, it might be better to simply exclude those 
<span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> components from the computation.</p>
<p>In addition, the absolute value in <span class="math notranslate">\(k_{3,mod}\)</span> implies that 
<span class="math notranslate">\(\epsilon\)</span> should be positive. Hence, when applying an 
inverse Fourier transform to the time domain, one has to choose 
the convention,</p>
<blockquote>
<div><p><span class="math notranslate">\(f(t)  = \int F(\omega) \; 
\mathrm{e}^{\mathrm{j} \omega t} \mathrm{d}\omega\)</span>.</p>
</div></blockquote>
<p>This can be done by complex-conjugating the modelled wavefield 
before applying the inverse Fourier transform. Note that the 
default settings of the 2D inverse Fourier transform function 
<strong>K1W2X1T</strong> handle all these sign choices correctly as long as 
<span class="math notranslate">\(\epsilon &gt;0\)</span>.</p>
</div></blockquote>
<p class="last">(2) In reciprocal media, for Im(<span class="math notranslate">\(\gamma_i\)</span>) <span class="math notranslate">\(\neq 0\)</span>, 
energy conservation does not hold for evanescent waves. (Reciprocal 
media are not yet included in version 2.0. However, when reciprocal
media are included this remark should be checked carefully.)</p>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul>
<li><dl class="first docutils">
<dt>We format the data as described below.</dt>
<dd><ul class="first last">
<li><p class="first">Wavefields are saved in an array of dimensions (nf,nr) in the frequency domain and (nt,nr) in the time domain.</p>
</li>
<li><dl class="first docutils">
<dt>Wavefields are in the <span class="math notranslate">\(k_1\)</span>-<span class="math notranslate">\(\omega\)</span> domain.</dt>
<dd><ul class="first last simple">
<li>The zero frequency component is placed at the first index position of the first dimension.</li>
<li>The zero horizontal-wavenumber component is placed at the first index position of the second dimension.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>If the wavefield is transformed to the space-time domain: </dt>
<dd><ul class="first last simple">
<li>The zero time component is placed at the first index position of the first dimension, followed by nt/2-1 positive time samples and nt/2 negative time samples.</li>
<li>The zero offset component is placed at the first index position of the second dimension, followed by nr/2-1 positive offset samples and nr/2 negative offset samples.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">For evanescent waves, Kees makes a sign choice for the vertical-wavenumber,</p>
<blockquote>
<div><p><span class="math notranslate">\(k_3=-j \sqrt{ k_1^2 - 2\gamma_1 k_1 \omega - (\alpha \beta_{11} -\gamma_1^2)  \omega^2}\)</span>.</p>
</div></blockquote>
</li>
<li><p class="first">By default, <strong>NumPy</strong> makes the oppostie sign choice,</p>
<blockquote>
<div><p><span class="math notranslate">\(k_3=+j \sqrt{ k_1^2 - 2\gamma_1 k_1 \omega - (\alpha \beta_{11} -\gamma_1^2)\omega^2}\)</span>.</p>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>For convenience, we stick to <strong>NumPy</strong>’s sign choice. Thus, we will also adapt the sign choice for the propagators,</dt>
<dd><ul class="first last simple">
<li>Kees chose: <span class="math notranslate">\(\tilde{w}^{\pm} = \mathrm{exp}(\pm \lambda^{\pm} \Delta x_3)\)</span>.</li>
<li>We choose: <span class="math notranslate">\(\tilde{w}^{\pm} = \mathrm{exp}(\mp \lambda^{\pm} \Delta x_3)\)</span>.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p class="rubric">References</p>
<p>Kees document as soon as it is published.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialise wavefield in a layered non-reciprocal medium</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">3.7</span><span class="p">]),</span> <span class="n">avec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span> 
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">b11vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">3.14</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span> 
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">b13vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.4</span><span class="p">,</span><span class="mf">1.2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">b33vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">3.14</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">g1vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">g3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.8</span><span class="p">,</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">2.3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">ReciprocalMedium</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get a meshgrid of the vertical-wavenumber</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">.</span><span class="n">K3</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(513, 512, 3)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the vertical-wavenumber for omega=delta omega,  and k1=0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">.</span><span class="n">K3</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(0.00044855235013677386+0j)</span>
</pre></div>
</div>
<p><strong>Wavefield Quantities</strong>
(Do not change the table!)</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="13%" />
<col width="11%" />
<col width="20%" />
<col width="19%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">&#160;</th>
<th class="head"><em>TE</em></th>
<th class="head"><em>TM</em></th>
<th class="head"><em>Ac. (meta)</em></th>
<th class="head"><em>Ac. (rotat)</em></th>
<th class="head"><em>SH (solid)</em></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><strong>P</strong></td>
<td><span class="math notranslate">\(E_2\)</span></td>
<td><span class="math notranslate">\(H_2\)</span></td>
<td><span class="math notranslate">\(\sigma\)</span></td>
<td><span class="math notranslate">\(\sigma\)</span></td>
<td><span class="math notranslate">\(v_2\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math notranslate">\(\mathbf{Q}_1\)</span></td>
<td><span class="math notranslate">\(H_3\)</span></td>
<td><span class="math notranslate">\(-E_3\)</span></td>
<td><span class="math notranslate">\(v_1\)</span></td>
<td><span class="math notranslate">\(v_1\)</span></td>
<td><span class="math notranslate">\(-\tau_{21}\)</span></td>
</tr>
<tr class="row-even"><td><span class="math notranslate">\(\mathbf{Q}_3\)</span></td>
<td><span class="math notranslate">\(-H_1\)</span></td>
<td><span class="math notranslate">\(E_1\)</span></td>
<td><span class="math notranslate">\(v_3\)</span></td>
<td><span class="math notranslate">\(v_3\)</span></td>
<td><span class="math notranslate">\(-\tau_{23}\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math notranslate">\(\boldsymbol{\alpha}\)</span></td>
<td><span class="math notranslate">\(\epsilon_{22}\)</span></td>
<td><span class="math notranslate">\(\mu_{22}\)</span></td>
<td><span class="math notranslate">\(\frac{1}{K}\)</span></td>
<td><span class="math notranslate">\(\kappa\)</span></td>
<td><span class="math notranslate">\(\mathcal{R}_{22}\)</span></td>
</tr>
<tr class="row-even"><td><span class="math notranslate">\(\boldsymbol{\beta}_{11}\)</span></td>
<td><span class="math notranslate">\(\mu_{33}\)</span></td>
<td><span class="math notranslate">\(\epsilon_{33}\)</span></td>
<td><span class="math notranslate">\(\mathcal{R}_{11}\)</span></td>
<td><span class="math notranslate">\(\rho\)</span></td>
<td><span class="math notranslate">\(4 s_{1221}\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math notranslate">\(\boldsymbol{\beta}_{13}\)</span></td>
<td><span class="math notranslate">\(-\mu_{31}\)</span></td>
<td><span class="math notranslate">\(-\epsilon_{31}\)</span></td>
<td><span class="math notranslate">\(\mathcal{R}_{13}\)</span></td>
<td><span class="math notranslate">\(\frac{2\rho\Omega_2}{j\omega}\)</span></td>
<td><span class="math notranslate">\(4 s_{1223}\)</span></td>
</tr>
<tr class="row-even"><td><span class="math notranslate">\(\boldsymbol{\beta}_{31}\)</span></td>
<td><span class="math notranslate">\(-\mu_{13}\)</span></td>
<td><span class="math notranslate">\(-\epsilon_{13}\)</span></td>
<td><span class="math notranslate">\(\mathcal{R}_{31}\)</span></td>
<td><span class="math notranslate">\(-\frac{2\rho\Omega_2}{j\omega}\)</span></td>
<td><span class="math notranslate">\(4 s_{3221}\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math notranslate">\(\boldsymbol{\beta}_{33}\)</span></td>
<td><span class="math notranslate">\(\mu_{11}\)</span></td>
<td><span class="math notranslate">\(\epsilon_{11}\)</span></td>
<td><span class="math notranslate">\(\mathcal{R}_{33}\)</span></td>
<td><span class="math notranslate">\(\rho\)</span></td>
<td><span class="math notranslate">\(4 s_{3223}\)</span></td>
</tr>
<tr class="row-even"><td><span class="math notranslate">\(\boldsymbol{\gamma}_{1}\)</span></td>
<td><span class="math notranslate">\(\xi_{23}\)</span></td>
<td><span class="math notranslate">\(-\zeta_{23}\)</span></td>
<td><span class="math notranslate">\(\frac{\theta_{mm1}}{3K}\)</span></td>
<td>&#160;</td>
<td><span class="math notranslate">\(-2 \xi_{221}\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math notranslate">\(\boldsymbol{\gamma}_{3}\)</span></td>
<td><span class="math notranslate">\(-\xi_{21}\)</span></td>
<td><span class="math notranslate">\(\zeta_{21}\)</span></td>
<td><span class="math notranslate">\(\frac{\theta_{mm3}}{3K}\)</span></td>
<td>&#160;</td>
<td><span class="math notranslate">\(-2 \xi_{223}\)</span></td>
</tr>
<tr class="row-even"><td><span class="math notranslate">\(\boldsymbol{\chi}_{1}\)</span></td>
<td><span class="math notranslate">\(\zeta_{32}\)</span></td>
<td><span class="math notranslate">\(-\xi_{32}\)</span></td>
<td><span class="math notranslate">\(-\frac{\eta_{1ll}}{3K}\)</span></td>
<td>&#160;</td>
<td><span class="math notranslate">\(-2 \zeta_{122}\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math notranslate">\(\boldsymbol{\chi}_{3}\)</span></td>
<td><span class="math notranslate">\(-\zeta_{12}\)</span></td>
<td><span class="math notranslate">\(\xi_{12}\)</span></td>
<td><span class="math notranslate">\(-\frac{\eta_{3ll}}{3K}\)</span></td>
<td>&#160;</td>
<td><span class="math notranslate">\(-2 \zeta_{322}\)</span></td>
</tr>
<tr class="row-even"><td><strong>B</strong></td>
<td><span class="math notranslate">\(-J_2^e\)</span></td>
<td><span class="math notranslate">\(-J_2^m\)</span></td>
<td><span class="math notranslate">\(q\)</span></td>
<td><span class="math notranslate">\(q\)</span></td>
<td><span class="math notranslate">\(f_2\)</span></td>
</tr>
<tr class="row-odd"><td><span class="math notranslate">\(\mathbf{C}_1\)</span></td>
<td><span class="math notranslate">\(-J_3^m\)</span></td>
<td><span class="math notranslate">\(J_3^e\)</span></td>
<td><span class="math notranslate">\(f_1\)</span></td>
<td><span class="math notranslate">\(f_1\)</span></td>
<td><span class="math notranslate">\(2h_{12}\)</span></td>
</tr>
<tr class="row-even"><td><span class="math notranslate">\(\mathbf{C}_3\)</span></td>
<td><span class="math notranslate">\(J_1^m\)</span></td>
<td><span class="math notranslate">\(-J_1^e\)</span></td>
<td><span class="math notranslate">\(f_3\)</span></td>
<td><span class="math notranslate">\(f_3\)</span></td>
<td><span class="math notranslate">\(2h_{32}\)</span></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.FK1_mask_k1_w">
<code class="descname">FK1_mask_k1_w</code><span class="sig-paren">(</span><em>RelativeTaperLength=0.03125</em>, <em>wmax=None</em>, <em>Opening=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.FK1_mask_k1_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.FK1_mask_k1_w" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a mask that mutes evanescent waves in the <span class="math notranslate">\(k_1\)</span>-
<span class="math notranslate">\(\omega\)</span> domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>RelativeTaperLength</strong> : int, float, optional</p>
<blockquote>
<div><p>The product of ‘RelativeTaperLength’ and the number of temporal 
samples ‘nt’ determines the taper length. The default value is 
‘RelativeTaperLength’<span class="math notranslate">\(=2^{-5}.\)</span></p>
</div></blockquote>
<p><strong>wmax</strong> : int, float, complex, optional</p>
<blockquote>
<div><p>Cut-off frequency <span class="math notranslate">\(\omega_{\mathrm{max}}\)</span> in <span class="math notranslate">\(s^{-1}\)</span>.</p>
</div></blockquote>
<p><strong>Opening</strong> : int, float, optional</p>
<blockquote>
<div><p>Factor, greater than zero, to widen or tighten the <span class="math notranslate">\(\omega\)</span>-
<span class="math notranslate">\(k_1\)</span> mask. If equal to one, the opening corresponds to the 
transition from propagating to evanescent waves.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>A dictionary that contains the ,</dt>
<dd><ul class="first simple">
<li><strong>FK</strong>: Sharp-edged <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> mask, mutes</li>
</ul>
<p>the evanescent wavefield in each layer indivually. Shape 
(nf,nr,n).</p>
<ul class="simple">
<li><strong>FK_global</strong>: Sharp-edged <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> mask,</li>
</ul>
<p>mutes the evanescent wavefield in the entire model. Shape 
(nf,nr).</p>
<ul class="simple">
<li><strong>FK_tap</strong>: Tapered <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> mask, mutes</li>
</ul>
<p>the evanescent wavefield in each layer indivually. Shape 
(nf,nr,n).</p>
<ul class="simple">
<li><strong>FK_global_tap</strong>: Tapered <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> mask,</li>
</ul>
<p>mutes the evanescent wavefield in the entire model. Shape 
(nf,nr).</p>
<ul class="simple">
<li><strong>FKn</strong>: Sharp-edged <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> mask, mutes</li>
</ul>
<p>the evanescent wavefield in each layer indivually (for sign-
inverted <span class="math notranslate">\(k_1\)</span>). Shape (nf,nr,n).</p>
<ul class="simple">
<li><strong>FKn_global</strong>: Sharp-edged <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> mask,</li>
</ul>
<p>mutes the evanescent wavefield in the entire model (for sign-
inverted <span class="math notranslate">\(k_1\)</span>). Shape (nf,nr).</p>
<ul class="simple">
<li><strong>FKn_tap</strong>: Tapered <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> mask, mutes</li>
</ul>
<p>the evanescent wavefield in each layer indivually (for sign-
inverted <span class="math notranslate">\(k_1\)</span>). Shape (nf,nr,n).</p>
<ul class="simple">
<li><strong>FKn_global_tap</strong>: Tapered <span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> mask,</li>
</ul>
<p>mutes the evanescent wavefield in the entire model (for sign-
inverted <span class="math notranslate">\(k_1\)</span>). Shape (nf,nr).</p>
<ul class="last simple">
<li><strong>taperlen</strong>: Taper length in number of samples.</li>
</ul>
</dd>
</dl>
<p>All masks are stored as complex valued arrays because they will be 
applied to complex-valued arrays.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">3.7</span><span class="p">]),</span>
<span class="go">         avec=np.array([1,2,3])*1e-3,b11vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="go">         b13vec=np.array([0.4,2.4,1.2])*1e-4,b33vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="go">         g1vec=np.array([0.8,2,1.3])*1e-4,g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="go">         ReciprocalMedium=False)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Create fk mask with a cut-off frequency at 200 1/s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mask</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">FK1_mask_k1_w</span><span class="p">(</span><span class="n">wmax</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tapered_fk_mask</span> <span class="o">=</span> <span class="n">Mask</span><span class="p">[</span><span class="s1">&#39;FK_tap&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.Eigenvalues_k1_w">
<code class="descname">Eigenvalues_k1_w</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.Eigenvalues_k1_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.Eigenvalues_k1_w" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the eigenvalues <span class="math notranslate">\(\lambda^{\pm}\)</span> of the two-way 
operator matrix <span class="math notranslate">\(\rm{\bf A}\)</span> in the wavenumber-frequency 
domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote>
<div><p>Dictionary that contains</p>
<blockquote>
<div><ul class="simple">
<li><strong>LP</strong>: The eigenvalue <span class="math notranslate">\(\lambda^{+}\)</span>.</li>
<li><strong>LM</strong>: The eigenvalue <span class="math notranslate">\(\lambda^{-}\)</span>.</li>
<li><strong>LPn</strong>: The eigenvalue <span class="math notranslate">\(\lambda^{+}\)</span> with sign-inverted horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>.</li>
<li><strong>LMn</strong>: The eigenvalue <span class="math notranslate">\(\lambda^{-}\)</span> with sign-inverted horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>.</li>
</ul>
</div></blockquote>
<p>All eigenvalue matrices are stored in a in a (nf,nr,n)-array. The 
dimensions correspond to the temporal frequencies <span class="math notranslate">\(\omega\)</span>, 
the horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span> and to the layers of the 
medium.</p>
</div></blockquote>
<div class="admonition-todo last admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p>(1) Check if the eigenvalues have to be modified for reciprocal 
media.</p>
<p class="last">(2) Check if <span class="math notranslate">\(\beta_{11} \beta_{33} - \beta_{13}^2 \geq 0\)</span> 
holds in general.</p>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>The eigenvalues are associated with non-reciprocal media.</li>
</ul>
<p class="rubric">References</p>
<p>Kees document as soon as it is published.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">3.7</span><span class="p">]),</span>
<span class="go">         avec=np.array([1,2,3])*1e-3,b11vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="go">         b13vec=np.array([0.4,2.4,1.2])*1e-4,b33vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="go">         g1vec=np.array([0.8,2,1.3])*1e-4,g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="go">         ReciprocalMedium=False)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute the eigenvalue lambda_plus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lam</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">Eigenvalues_k1_w</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lP</span> <span class="o">=</span> <span class="n">Lam</span><span class="p">[</span><span class="s2">&quot;LP&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lP</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Evaluate for k1=0 and \omega = \Delta \omega</span>
<span class="go">0.0006226976760655292j</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.L_eigenvectors_k1_w">
<code class="descname">L_eigenvectors_k1_w</code><span class="sig-paren">(</span><em>beta11=None</em>, <em>beta13=None</em>, <em>beta33=None</em>, <em>K3=None</em>, <em>K3n=None</em>, <em>normalisation='flux'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.L_eigenvectors_k1_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.L_eigenvectors_k1_w" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the eigenvector matrix ‘L’ and its inverse ‘Linv’, either 
in flux- or in pressure-normalisation for the vertical-wavenumber ‘K3’ 
inside a homogeneous layer. Here, the vertical-wavenumber is a meshgrid 
that contains all combinations of frequencies <span class="math notranslate">\(\omega\)</span> and 
horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>. If ‘AdjointMedium=True’, 
<strong>L_eigenvectors_k1_w</strong> also computes the eigenvector matrix in the 
adjoint medium ‘La’ and its inverse ‘Lainv’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>beta11</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{11}\)</span>  (real-valued).</p>
</div></blockquote>
<p><strong>beta13</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{13}\)</span>  (real-valued).</p>
</div></blockquote>
<p><strong>beta33</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{33}\)</span>  (real-valued).</p>
</div></blockquote>
<p><strong>K3</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Vertical-wavenumber <span class="math notranslate">\(k_3(+k_1)\)</span> for all frequencies 
<span class="math notranslate">\(\omega\)</span> and horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>.</p>
</div></blockquote>
<p><strong>K3n</strong> : numpy.ndarray, optional (required if ‘AdjointMedium=True’)</p>
<blockquote>
<div><p>Vertical-wavenumber <span class="math notranslate">\(k_3(-k_1)\)</span> for all frequencies 
<span class="math notranslate">\(\omega\)</span> and sign-inverted horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>.</p>
</div></blockquote>
<p><strong>normalisation</strong> : str, optional</p>
<blockquote>
<div><p>For pressure-normalisation set normalisation=’pressure’, for 
flux-normalisation set normalisation=’flux’.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><p>Dictionary that contains</p>
<blockquote>
<div><ul class="simple">
<li><strong>L</strong>: The eigenvector matrix.</li>
<li><strong>Linv</strong>: The inverse of the eigenvector matrix.</li>
<li><strong>La</strong>: The eigenvector matrix (adjoint medium).</li>
<li><strong>Lainv</strong>: The inverse of the eigenvector matrix (adjoint medium).</li>
</ul>
</div></blockquote>
<p>All eigenvector matrices are stored in a in a (nf,nr,2,2)-array. 
The first two dimensions correspond to all combinations of 
frequencies <span class="math notranslate">\(\omega\)</span> and horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>. 
The last two dimension are the actual eigenvector matrices for all 
<span class="math notranslate">\(\omega\)</span>-<span class="math notranslate">\(k_1\)</span> components.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>The eigenvector matrix ‘L’ and its inverse ‘Linv’ are different for reciprocal and non-reciprocal media (I assume that has not changed, but check it!).</li>
<li>For reciprocal media, the eigenvectors of the adjoint medium are identical to the eigenvectors of the true medium (verify!).</li>
<li>We have defined the eigenvectors of the adjoint medium only for flux-normalisation.</li>
<li>At zero frequency (<span class="math notranslate">\(\omega=0 \;\mathrm{s}^{-1}\)</span>), the eigenvector matrices ‘L’ and their inverse ‘Linv’ contain elements with poles. For computational convenience, we set the poles equal to zero. However, the resulting zero frequency component of all outputs is meaningless.</li>
</ul>
<p class="rubric">References</p>
<p>Kees document as soon as it is published.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialise wavefield in a layered non-reciprocal medium</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">3.7</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">avec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">b11vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">3.14</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">b13vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.4</span><span class="p">,</span><span class="mf">1.2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">b33vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">3.14</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">g1vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">g3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.8</span><span class="p">,</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">2.3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">ReciprocalMedium</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">AdjointMedium</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute eigenvectors in pressure-normalisation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Leig</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">L_eigenvectors_k1_w</span><span class="p">(</span><span class="n">beta11</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">beta13</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                           <span class="n">beta33</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b33vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">K3</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">K3</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                           <span class="n">K3n</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                           <span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;pressure&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="o">=</span><span class="n">Leig</span><span class="p">[</span><span class="s1">&#39;L&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># For pressure normalisation, the top-left element of L equals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># 1 for all frequencies and all horizontal-wavenumbers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="mi">101</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(1+0j)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># For pressure normalisation, the bottom-left element of L does not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># equal 1 for all frequencies and all horizontal-wavenumbers</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="mi">101</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">10.85892500293106j</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.RT_k1_w">
<code class="descname">RT_k1_w</code><span class="sig-paren">(</span><em>beta11_u=None</em>, <em>beta13_u=None</em>, <em>beta33_u=None</em>, <em>K3_u=None</em>, <em>K3n_u=None</em>, <em>beta11_l=None</em>, <em>beta13_l=None</em>, <em>beta33_l=None</em>, <em>K3_l=None</em>, <em>K3n_l=None</em>, <em>normalisation='flux'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.RT_k1_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.RT_k1_w" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the scattering coefficients at an horizontal interface.</p>
<p>The scattering coefficients can be computed either in flux- or in 
pressure-normalisation. The variables with subscript ‘u’ refer to the 
medium parameters in the upper half-space, the variables with subscript 
‘l’ refer to the medium parameters in the lower half-space. The 
vertical-wavenumbers ‘K3’<span class="math notranslate">\(=k_3(k_1,\omega)\)</span> and 
‘K3n’<span class="math notranslate">\(=k_3(-k_1,\omega)\)</span> are stored as <span class="math notranslate">\(k_1\)</span>-
<span class="math notranslate">\(\omega\)</span> meshgirds to compute the scattering coefficients for all 
sampled frequencies and horizontal-wavenumbers in a vectorsied manner. 
Set ‘AdjointMedium=True’ to compute the scattering coefficients also 
in the adjoint medium.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>beta11_u</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{11}\)</span> (real-valued) (upper half-space).</p>
</div></blockquote>
<p><strong>beta13_u</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{13}\)</span> (real-valued) (upper half-space).</p>
</div></blockquote>
<p><strong>beta33_u</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{33}\)</span> (real-valued) (upper half-space).</p>
</div></blockquote>
<p><strong>K3_u</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Vertical-wavenumber <span class="math notranslate">\(k_{3,u}(+k_1)\)</span> for all frequencies 
<span class="math notranslate">\(\omega\)</span> and horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span> (upper half-
space).</p>
</div></blockquote>
<p><strong>K3n_u</strong> : numpy.ndarray, optional (required if ‘AdjointMedium=True’)</p>
<blockquote>
<div><p>Vertical-wavenumber <span class="math notranslate">\(k_{3,u}(-k_1)\)</span> for all frequencies 
<span class="math notranslate">\(\omega\)</span> and sign-inverted horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span> 
(upper half-space).</p>
</div></blockquote>
<p><strong>beta11_l</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{11}\)</span> (real-valued) (lower half-space).</p>
</div></blockquote>
<p><strong>beta13_l</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{13}\)</span> (real-valued) (lower half-space).</p>
</div></blockquote>
<p><strong>beta33_l</strong> : int, float</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta_{33}\)</span> (real-valued) (lower half-space).</p>
</div></blockquote>
<p><strong>K3_l</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Vertical-wavenumber <span class="math notranslate">\(k_{3,l}(+k_1)\)</span> for all frequencies 
<span class="math notranslate">\(\omega\)</span> and horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span> (lower half-
space).</p>
</div></blockquote>
<p><strong>K3n_l</strong> : numpy.ndarray, optional (required if ‘AdjointMedium=True’)</p>
<blockquote>
<div><p>Vertical-wavenumber <span class="math notranslate">\(k_{3,l}(-k_1)\)</span> for all frequencies 
<span class="math notranslate">\(\omega\)</span> and sign-inverted horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span> 
(lower half-space).</p>
</div></blockquote>
<p><strong>normalisation</strong> : str, optional</p>
<blockquote>
<div><p>For pressure-normalisation set normalisation=’pressure’, for flux-
normalisation set normalisation=’flux’.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote>
<div><p>Dictionary that contains</p>
<blockquote>
<div><ul class="simple">
<li><strong>rP</strong>: Reflection coefficient from above.</li>
<li><strong>tP</strong>: Transmission coefficient from above.</li>
<li><strong>rM</strong>: Reflection coefficient from below.</li>
<li><strong>tM</strong>: Transmission coefficient from below.</li>
<li><strong>rPa</strong>: Reflection coefficient from above (adjoint medium).</li>
<li><strong>tPa</strong>: Transmission coefficient from above (adjoint medium).</li>
<li><strong>rMa</strong>: Reflection coefficient from below (adjoint medium).</li>
<li><strong>tMa</strong>: Transmission coefficient from below (adjoint medium).</li>
</ul>
</div></blockquote>
<p>All scattering coefficients are stored as arrays with the shape 
(nf,nr).</p>
</div></blockquote>
<div class="admonition-todo last admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">(1) For <span class="math notranslate">\((k_1 , \omega) = (0,0)\)</span> there is a zero division in the 
computation of the scattering coefficients. I have fixed that, however, I believe that the fix is (mathmatically) wrong. Check that!</p>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>For reciprocal media, the scattering coefficients of the adjoint medium are identical to the scattering coefficients of the true medium. (To be checked)</li>
<li>We have defined the scattering coefficients of the adjoint medium only for flux-normalisation.</li>
</ul>
<p class="rubric">References</p>
<p>Kees document as soon as it is published.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialise wavefield F in a reciprocal medium </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">3.7</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">avec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">b11vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">3.14</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">b13vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.4</span><span class="p">,</span><span class="mf">1.2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">b33vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">3.14</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">g1vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.8</span><span class="p">,</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">2.3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">ReciprocalMedium</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">AdjointMedium</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute scattering coefficients at the first interface in flux</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># normalisation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Scat</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">RT_k1_w</span><span class="p">(</span><span class="n">beta11_u</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">beta13_u</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">beta33_u</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b33vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                 <span class="n">K3_u</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">K3</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span><span class="n">K3n_u</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                 <span class="n">beta11_l</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">beta13_l</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">beta33_l</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">b33vec</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                 <span class="n">K3_l</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">K3</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span><span class="n">K3n_l</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">],</span><span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read the scattering coeffcients, and </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tP</span> <span class="o">=</span> <span class="n">Scat</span><span class="p">[</span><span class="s1">&#39;tP&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rM</span> <span class="o">=</span> <span class="n">Scat</span><span class="p">[</span><span class="s1">&#39;rM&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rP</span> <span class="o">=</span> <span class="n">Scat</span><span class="p">[</span><span class="s1">&#39;rP&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tM</span> <span class="o">=</span> <span class="n">Scat</span><span class="p">[</span><span class="s1">&#39;tM&#39;</span><span class="p">]</span> 
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tP</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(513, 512)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">tP</span><span class="o">-</span><span class="n">tM</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Transmission coefficient for k1,omega = (0,Delta omega)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tP</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(0.9865896281519458+0j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.W_propagators_k1_w">
<code class="descname">W_propagators_k1_w</code><span class="sig-paren">(</span><em>LP=None</em>, <em>LM=None</em>, <em>LPn=None</em>, <em>LMn=None</em>, <em>dx3=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.W_propagators_k1_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.W_propagators_k1_w" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the downgoing propagator ‘wP’ and the upgoing progagator 
‘wM’ for all sampled eigenvalues ‘LP’ and ‘LM’ and a vertical distance 
‘dx3’ (downward pointing <span class="math notranslate">\(x_3\)</span>-axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>LP</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Eigenvalus <span class="math notranslate">\(\lambda^+\)</span> for all frquencies <span class="math notranslate">\(\omega\)</span> and 
all horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>.</p>
</div></blockquote>
<p><strong>LM</strong> : numpy.ndarray</p>
<blockquote>
<div><p>Eigenvalus <span class="math notranslate">\(\lambda^-\)</span> for all frquencies <span class="math notranslate">\(\omega\)</span> and 
all horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>.</p>
</div></blockquote>
<p><strong>LPn</strong> : numpy.ndarray, optional (required if ‘AdjointMedium=True’)</p>
<blockquote>
<div><p>Eigenvalus <span class="math notranslate">\(\lambda^+\)</span> for all frquencies <span class="math notranslate">\(\omega\)</span> and 
all sign-inverted horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>.</p>
</div></blockquote>
<p><strong>LMn</strong> : numpy.ndarray, optional (required if ‘AdjointMedium=True’)</p>
<blockquote>
<div><p>Eigenvalus <span class="math notranslate">\(\lambda^-\)</span> for all frquencies <span class="math notranslate">\(\omega\)</span> and 
all sign-inverted horizontal-wavenumbers <span class="math notranslate">\(k_1\)</span>.</p>
</div></blockquote>
<p><strong>dx3</strong> : int, float</p>
<blockquote>
<div><p>Vertical propagation distance <span class="math notranslate">\(\Delta x_3\)</span> (downward 
pointing <span class="math notranslate">\(x_3\)</span>-axis).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote>
<div><p>Dictionary that contains</p>
<blockquote>
<div><ul class="simple">
<li><strong>wP</strong>: Downward propagator <span class="math notranslate">\(\tilde{w}^+\)</span>.</li>
<li><strong>wM</strong>: Upward propagator <span class="math notranslate">\(\tilde{w}^-\)</span>.</li>
<li><strong>wPa</strong>: Downward propagator <span class="math notranslate">\(\tilde{w}^{+(a)}\)</span> (adjoint medium).</li>
<li><strong>wMa</strong>: Upward propagator <span class="math notranslate">\(\tilde{w}^{-(a)}\)</span> (adjoint medium).</li>
</ul>
</div></blockquote>
<p>All propagators are stored in an arrays of shape (nf,nr). The 
variables ‘wPa’ and ‘wMa’ are computed only for the setting 
‘AdjointMedium=True’.</p>
</div></blockquote>
<div class="admonition-todo last admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">In a non-reciprocal medium, for a complex-valued frequency 
<span class="math notranslate">\(\omega'=\omega+\mathrm{j}\epsilon\)</span> one of the propagators 
has an exponentially growing term. Does that cause errors? If yes, 
can we fix that manually? (still the case?)</p>
</div>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Kees document as soon as it is published.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TO</span> <span class="n">BE</span> <span class="n">UPDATED</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialise a wavefield</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">,</span><span class="mf">3.7</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">avec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">3.14</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">g1vec</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">g3vec</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.8</span><span class="p">,</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">2.3</span><span class="p">])</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>     <span class="n">ReciprocalMedium</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">AdjointMedium</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute the propagators of the first layer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Prop</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">W_propagators_k1_w</span><span class="p">(</span><span class="n">K3</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">K3</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span><span class="n">K3n</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                            <span class="n">g3</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">g3vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">dx3</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">x3vec</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wP</span> <span class="o">=</span> <span class="n">Prop</span><span class="p">[</span><span class="s1">&#39;wP&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wM</span> <span class="o">=</span> <span class="n">Prop</span><span class="p">[</span><span class="s1">&#39;wM&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># In reciprocal media the down- and upgoing propagators are identical</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">wP</span><span class="o">-</span><span class="n">wM</span><span class="p">)</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.Contains_Nan_Inf">
<code class="descname">Contains_Nan_Inf</code><span class="sig-paren">(</span><em>FuncName</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.Contains_Nan_Inf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.Contains_Nan_Inf" title="Permalink to this definition">¶</a></dt>
<dd><p>checks if the given arrays contain NaN or Inf elements. If an array
contains NaN or Inf elements a command line statement is printed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>FuncName</strong> : str</p>
<blockquote>
<div><p>Name of the function in which <strong>Contains_Nan_Inf</strong> is called.</p>
</div></blockquote>
<p><strong>*args</strong> : tuple</p>
<blockquote>
<div><p>Undetermined number of input tuples. The first tuple element is an
array, the second tuple element is the name of the array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first"><strong>Message</strong> : str or None</p>
<blockquote class="last">
<div><p>If any of the input arrays contains a NaN or Inf, a message is 
printed in the command line.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is only meant for internal usage. Therefore, there are no
checks of the input variables.</p>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.RT_response_k1_w">
<code class="descname">RT_response_k1_w</code><span class="sig-paren">(</span><em>x3vec=None</em>, <em>avec=None</em>, <em>bvec=None</em>, <em>g1vec=None</em>, <em>g3vec=None</em>, <em>normalisation='flux'</em>, <em>InternalMultiples=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.RT_response_k1_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.RT_response_k1_w" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the reflection and transmission responses from above and 
from below. The medium parameters defined in <strong>Layered_NRM_k1_w</strong> are 
used, except if the medium parameters are given via the input 
variables.</p>
<p>The medium responses are associated to measurements at <span class="math notranslate">\(x_3=0\)</span> 
and at <span class="math notranslate">\(x_3=\)</span> ‘x3vec[-2]’ <span class="math notranslate">\(+\epsilon\)</span>, where 
<span class="math notranslate">\(\epsilon\)</span> is an infinitesimally small positive constant. Hence, 
the propagation from <span class="math notranslate">\(x_3=0\)</span> to the shallowest interface is 
included. However, the propagation through the deepest layer is 
excluded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x3vec</strong> : numpy.ndarray, optional</p>
<blockquote>
<div><p>Vertical spatial vector <span class="math notranslate">\(x_3\)</span>, for n layers ‘x3vec’ must have 
the shape (n,). We define the <span class="math notranslate">\(x_3\)</span>-axis as 
downward-pointing. Implicitly, the first value on the 
<span class="math notranslate">\(x_3\)</span>-axis is zero (not stored in ‘x3vec’).</p>
</div></blockquote>
<p><strong>avec</strong> : numpy.ndarray, optional</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\alpha\)</span> (real-valued), for n layers ‘avec’ 
must have the shape (n,).</p>
</div></blockquote>
<p><strong>bvec</strong> : numpy.ndarray, optional</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\beta\)</span> (real-valued), for n layers ‘bvec’ 
must have the shape (n,).</p>
</div></blockquote>
<p><strong>g1vec</strong> : numpy.ndarray, optional</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\gamma_1\)</span> (real-valued for non-reciprocal 
media or imaginary-valued for reciprocal media), for n layers 
‘g1vec’ must have the shape (n,).</p>
</div></blockquote>
<p><strong>g3vec</strong> : numpy.ndarray, optional</p>
<blockquote>
<div><p>Medium parameter <span class="math notranslate">\(\gamma_3\)</span> (real-valued for non-reciprocal 
media or imaginary-valued for reciprocal media), for n layers 
‘g3vec’ must have the shape (n,).</p>
</div></blockquote>
<p><strong>normalisation</strong> : str, optional</p>
<blockquote>
<div><p>For pressure-normalisation set normalisation=’pressure’, for 
flux-normalisation set normalisation=’flux’.</p>
</div></blockquote>
<p><strong>InternalMultiples</strong> : bool, optional</p>
<blockquote>
<div><p>To model internal multiples set ‘InternalMultiples=True’. To 
ignore internal multiples set ‘InternalMultiples=False’.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Dictionary that contains </dt>
<dd><ul class="first last simple">
<li><strong>RP</strong>: Reflection response from above.</li>
<li><strong>TP</strong>: Transmission response from above.</li>
<li><strong>RM</strong>: Reflection response from below.</li>
<li><strong>TM</strong>: Transmission response from below.</li>
<li><strong>RPa</strong>: Reflection response from above (adjoint medium).</li>
<li><strong>TPa</strong>: Transmission response from above (adjoint medium).</li>
<li><strong>RMa</strong>: Reflection response from below (adjoint medium).</li>
<li><strong>TMa</strong>: Transmission response from below (adjoint medium).</li>
</ul>
</dd>
</dl>
<p>All medium responses are stored in arrays of shape (nf,nr). The 
variables ‘RPa’, ‘TPa’, ‘RMa’ and ‘TMa’ are computed only if one 
sets ‘AdjointMedium=True’.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Kees document as soon as it is published.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialise a wavefield in a 1D reciprocal medium</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2049</span><span class="o">*</span><span class="mf">0.005</span><span class="p">),</span>
<span class="go">           x3vec=np.array([1.1,2.2,3.7])*1e3,</span>
<span class="go">           avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="go">           g1vec=np.array([0.8,2,1.3])*1e-4,</span>
<span class="go">           g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="go">           ReciprocalMedium=False,AdjointMedium=True) </span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Model the medium responses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RT</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span><span class="n">InternalMultiples</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RP</span> <span class="o">=</span> <span class="n">RT</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Make a Ricker wavelet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Wav</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">RickerWavelet_w</span><span class="p">(</span><span class="n">f0</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Compute gain function (correct for complex-valued frequency)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gain</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">Gain_t</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Apply wavelet, transform to the space-time domain and apply gain</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">gain</span><span class="o">*</span><span class="n">F</span><span class="o">.</span><span class="n">K1W2X1T</span><span class="p">(</span><span class="n">Wav</span><span class="o">*</span><span class="n">RP</span><span class="p">),</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Plot reflection response</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span>   <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">Tvec</span><span class="p">()[</span><span class="s1">&#39;tvec&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X1</span>  <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">Xvec</span><span class="p">()[</span><span class="s1">&#39;xvec&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ex</span>  <span class="o">=</span> <span class="p">(</span><span class="n">X1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">X1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asp</span> <span class="o">=</span> <span class="n">X1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">();</span> <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rP</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;seismic&#39;</span><span class="p">,</span><span class="n">vmin</span><span class="o">=-</span><span class="mf">1e-3</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
<span class="go">                             extent=ex,aspect=asp)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Offset (m)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="_images/Rplus_k1_w.png"><img alt="_images/Rplus_k1_w.png" src="_images/Rplus_k1_w.png" style="width: 200px; height: 200px;" /></a>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.Insert_layer">
<code class="descname">Insert_layer</code><span class="sig-paren">(</span><em>x3</em>, <em>UpdateSelf=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.Insert_layer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.Insert_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>inserts a transparent interface at the depth level ‘x3’. If ‘x3’ 
coincides with an interface of the model, the model’s interface is left 
unchanged. If ‘x3’ is a vector it is interpreted as multiple depth 
levels, at each one a transparent interface will be inserted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x3</strong> : int, float, numpy.ndarray</p>
<blockquote>
<div><p>A depth level, or a vector of depth levels, at which a transparent 
interface will be inserted. The variable ‘x3’ either must be a 
scalar, or have the shape (n,). Each element of ‘x3’ must be 
real-valued and greater than, or equal to zero.</p>
</div></blockquote>
<p><strong>UpdateSelf</strong> : bool, optional</p>
<blockquote>
<div><p>Set ‘UpdateSelf=True’ to not only output an updated model but also 
update the ‘self’ parameters.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Dictionary that contains </dt>
<dd><ul class="first last simple">
<li><strong>x3vec</strong>: Updated depth vector.</li>
<li><strong>avec</strong>:  Updated <span class="math notranslate">\(\alpha\)</span> vector.</li>
<li><strong>bvec</strong>:  Updated <span class="math notranslate">\(\beta\)</span> vector.</li>
<li><strong>g1vec</strong>: Updated <span class="math notranslate">\(\gamma_1\)</span> vector.</li>
<li><strong>g3vec</strong>: Updated <span class="math notranslate">\(\gamma_3\)</span> vector.</li>
<li><strong>K3</strong>:    Updated <span class="math notranslate">\(k_3(k_1)\)</span> vector.</li>
<li><strong>K3n</strong>:   Updated <span class="math notranslate">\(k_3(-k_1)\)</span> vector.</li>
</ul>
</dd>
</dl>
<p>All medium parameter vectors are stored in arrays of shape (n,).
The vertical wavenumbers are stored in arrays of shape (nf,nr,n).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialise a wavefield in a 1D reciprocal medium</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
<span class="go">         x3vec=np.array([10,150,200]),</span>
<span class="go">         avec=np.array([1,2,3]),bvec=np.array([0.4,3.14,2]),</span>
<span class="go">         g1vec=np.array([0.9,2.1,0.3]),g3vec=np.array([0.7,1.14,0.2]))</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Insert a transparent layer at x3=1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Updated depth vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;x3vec&#39;</span><span class="p">]</span>
<span class="go">array([  1,  10, 150, 200])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Updated alpha vector</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;avec&#39;</span><span class="p">]</span>
<span class="go">array([1, 1, 2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.GreensFunction_k1_w">
<code class="descname">GreensFunction_k1_w</code><span class="sig-paren">(</span><em>x3R</em>, <em>x3S</em>, <em>normalisation='flux'</em>, <em>InternalMultiples=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.GreensFunction_k1_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.GreensFunction_k1_w" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the one-way Green’s functions for a receiver and source 
depth defined by the input variables ‘x3R’ and ‘x3S’. The one-way 
wavefields are decomposed at the receiver- and at the source-side. We 
define the receiver and source depths just below ‘x3R’ and ‘x3S’, 
respectively (this is important if the receiver or source depth 
coincides with an interface).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x3R</strong> : int,float</p>
<blockquote>
<div><p>Receiver depth.</p>
</div></blockquote>
<p><strong>x3S</strong> : int, float</p>
<blockquote>
<div><p>Source depth.</p>
</div></blockquote>
<p><strong>normalisation</strong> : str, optional</p>
<blockquote>
<div><p>For pressure-normalisation set normalisation=’pressure’, for 
flux-normalisation set normalisation=’flux’.</p>
</div></blockquote>
<p><strong>InternalMultiples</strong> : bool, optional</p>
<blockquote>
<div><p>To model internal multiples set ‘InternalMultiples=True’. To 
exclude internal multiples set ‘InternalMultiples=False’.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Dictionary that contains </dt>
<dd><ul class="first last simple">
<li><strong>GPP</strong>: Green’s function <span class="math notranslate">\(G^{+,+}\)</span> (true medium).</li>
<li><strong>GPM</strong>: Green’s function <span class="math notranslate">\(G^{+,-}\)</span> (true medium).</li>
<li><strong>GMP</strong>: Green’s function <span class="math notranslate">\(G^{-,+}\)</span> (true medium).</li>
<li><strong>GMM</strong>: Green’s function <span class="math notranslate">\(G^{-,-}\)</span> (true medium).</li>
<li><strong>GPPa</strong>: Green’s function <span class="math notranslate">\(G^{+,+}\)</span> (adjoint medium).</li>
<li><strong>GPMa</strong>: Green’s function <span class="math notranslate">\(G^{+,-}\)</span> (adjoint medium).</li>
<li><strong>GMPa</strong>: Green’s function <span class="math notranslate">\(G^{-,+}\)</span> (adjoint medium).</li>
<li><strong>GMMa</strong>: Green’s function <span class="math notranslate">\(G^{-,-}\)</span> (adjoint medium).</li>
</ul>
</dd>
</dl>
<p>All medium responses are stored in arrays of shape (nf,nr). The 
variables ‘GPPa’, ‘GPMa’, ‘GMPa’ and ‘GMMa’ are computed, only if 
one sets ‘AdjointMedium=True’.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>The superscript ‘+’ and ‘-‘ refer to downgoing and upgoing waves,</li>
</ul>
<p>respectively.
- The first superscript refers to the wavefield at the receiver-side.
- The second superscript refers to the wavefield at the source-side.</p>
<p class="rubric">References</p>
<p>Kees document as soon as it is published.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">to</span> <span class="n">be</span> <span class="n">done</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_k1_w</span> <span class="k">import</span> <span class="n">Layered_NRM_k1_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Initialise a wavefield in a 1D reciprocal medium</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">nt</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span><span class="n">dx1</span><span class="o">=</span><span class="mf">12.5</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2049</span><span class="o">*</span><span class="mf">0.005</span><span class="p">),</span>
<span class="go">           x3vec=np.array([1.1,2.2,3.7])*1e3,</span>
<span class="go">           avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="go">           g1vec=np.array([0.8,2,1.3])*1e-4,</span>
<span class="go">           g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="go">           ReciprocalMedium=False,AdjointMedium=True) </span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">GreensFunction_p_w</span><span class="p">(</span><span class="n">x3R</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">x3S</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RT</span><span class="o">=</span><span class="n">F</span><span class="o">.</span><span class="n">RT_response_p_w</span><span class="p">(</span><span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                     <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">RT</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">G</span><span class="p">[</span><span class="s1">&#39;GMP&#39;</span><span class="p">]</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="Layered_NRM_k1_w.Layered_NRM_k1_w.FocusingFunction_p_w">
<code class="descname">FocusingFunction_p_w</code><span class="sig-paren">(</span><em>x3F</em>, <em>normalisation='flux'</em>, <em>InternalMultiples=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Layered_NRM_k1_w.html#Layered_NRM_k1_w.FocusingFunction_p_w"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Layered_NRM_k1_w.Layered_NRM_k1_w.FocusingFunction_p_w" title="Permalink to this definition">¶</a></dt>
<dd><p>computes the focusing functions between the top surface (<span class="math notranslate">\(x_3=0\)</span>) and the focusing depth defined by the input variable ‘x3F’. We define the focusing depth just below ‘x3F’. Hence, if the focusing depth coincides with an interface the focusing function focuses below that interface.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>x3F</strong> : int,float</p>
<blockquote>
<div><p>Focusing depth.</p>
</div></blockquote>
<p><strong>normalisation</strong> : str, optional</p>
<blockquote>
<div><p>For pressure-normalisation set normalisation=’pressure’, for flux-normalisation set normalisation=’flux’. Until now, this function only models the focusing function for flux-normalisation.</p>
</div></blockquote>
<p><strong>InternalMultiples</strong> : bool, optional</p>
<blockquote>
<div><p>To model internal multiples set ‘InternalMultiples=True’. To ignore internal multiples set ‘InternalMultiples=False’.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dict</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>Dictionary that contains </dt>
<dd><ul class="first last simple">
<li><strong>FP</strong>: Downgoing focusing function.</li>
<li><strong>RP</strong>: Reflection response from above.</li>
<li><strong>TP</strong>: Transmission response from above.</li>
<li><strong>FM</strong>: Upgoing focusing function.</li>
<li><strong>RM</strong>: Reflection response from below.</li>
<li><strong>TM</strong>: Transmission response from below.</li>
<li><strong>FPa</strong>: Downgoing focusing function (adjoint medium).</li>
<li><strong>RPa</strong>: Reflection response from above (adjoint medium).</li>
<li><strong>TPa</strong>: Transmission response from above (adjoint medium).</li>
<li><strong>FMa</strong>: Upgoing focusing function (adjoint medium).</li>
<li><strong>RMa</strong>: Reflection response from below (adjoint medium).</li>
<li><strong>TMa</strong>: Transmission response from below (adjoint medium).</li>
</ul>
</dd>
</dl>
<p>All medium responses are stored in arrays of shape (nf,1). The variables ‘FPa’, ‘RPa’, ‘TPa’, ‘FMa’, ‘RMa’ and ‘TMa’ are computed only if one sets ‘AdjointMedium=True’.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>The downgoing focusing funtion <span class="math notranslate">\(\tilde{F}_1^+\)</span> is computed by inverting the expressions for the transmission from above <span class="math notranslate">\(\tilde{T}^+\)</span>:</dt>
<dd><span class="math notranslate">\(\tilde{F}_{1,n}^+ = \tilde{F}_{1,n-1}^+ (\tilde{w}_n^+)^{-1} (1 - \tilde{w}_n^+ \tilde{R}_{n-1}^{\cap} \tilde{w}_n^- \tilde{r}_n^{\cup} )^{-1} (\tilde{t}_n^+)^{-1}\)</span></dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The upgoing focusing function is computed by applying the reflection response <span class="math notranslate">\(R^{\cup}\)</span> on the downgoing focusing funtion <span class="math notranslate">\(\tilde{F}_1^+\)</span>:</dt>
<dd><span class="math notranslate">\(\tilde{F}_{1,n}^- = \tilde{R}^{\cup} \tilde{F}_{1,n}^+\)</span>.</dd>
</dl>
</li>
</ul>
<p class="rubric">References</p>
<p>Kees document as soon as it is published.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">Layered_NRM_p_w</span> <span class="k">import</span> <span class="n">Layered_NRM_p_w</span> <span class="k">as</span> <span class="n">LM</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span><span class="o">=</span><span class="n">LM</span><span class="p">(</span> <span class="n">nt</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="mi">200</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">avec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]),</span><span class="n">bvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">3.14</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">g1vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">2.1</span><span class="p">,</span><span class="mf">0.3</span><span class="p">]),</span><span class="n">g3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">1.14</span><span class="p">,</span><span class="mf">0.2</span><span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>      <span class="n">p1</span><span class="o">=</span><span class="mf">2e-4</span><span class="p">,</span><span class="n">ReciprocalMedium</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">AdjointMedium</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="Wavefield_NRM_k1_w.html" title="Wavefield_NRM_k1_w module"
             >next</a> |</li>
        <li class="right" >
          <a href="modules.html" title="k1-w-domain"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="modules.html" >k1-w-domain</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Christian Reinicke, Kees Wapenaar, and Evert Slob.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.2.
    </div>
  </body>
</html>