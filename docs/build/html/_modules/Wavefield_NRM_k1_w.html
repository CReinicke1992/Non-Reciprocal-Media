
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Wavefield_NRM_k1_w &#8212; Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Wavefield_NRM_k1_w</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Routines for modelling wavefields in 1.5D non-reciprocal media.</span>

<span class="sd">.. module:: Wavefield_NRM_k1_w 2\.0</span>

<span class="sd">:Authors:</span>
<span class="sd">    Christian Reinicke (c.reinicke@tudelft.nl), Kees Wapenaar (), and Evert Slob ()</span>
<span class="sd">    </span>
<span class="sd">:Copyright:</span>
<span class="sd">    Christian Reinicke (c.reinicke@tudelft.nl), Kees Wapenaar (), and Evert Slob ()</span>
<span class="sd">&quot;&quot;&quot;</span>
        
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1">#import matplotlib.pylab as plt</span>

<div class="viewcode-block" id="Wavefield_NRM_k1_w"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w">[docs]</a><span class="k">class</span> <span class="nc">Wavefield_NRM_k1_w</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;is a class to define a scalar wavefield in the horizontal-wavenumber </span>
<span class="sd">    frequency domain (:math:`k_1-\omega`).</span>
<span class="sd">        </span>
<span class="sd">    The class Wavefield_NRM_k1_w defines the parameters of a scalar wavefield </span>
<span class="sd">    in a 1.5D (non-)reciprocal medium. We consider all horizontal-wavenumbers </span>
<span class="sd">    and all frequencies, that are sampled by the given number of samples and by </span>
<span class="sd">    the given sample intervals, in space (&#39;nr&#39;, &#39;dx1&#39;) as well as in time </span>
<span class="sd">    (&#39;nt&#39;, &#39;dt&#39;).</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    nt : int</span>
<span class="sd">        Number of time samples.</span>
<span class="sd">    </span>
<span class="sd">    dt : int, float</span>
<span class="sd">        Time sample interval in seconds.</span>
<span class="sd">        </span>
<span class="sd">    nr : int</span>
<span class="sd">        Number of space samples.</span>
<span class="sd">    </span>
<span class="sd">    dx1 : int, float</span>
<span class="sd">        Space sample interval in metres.</span>
<span class="sd">        </span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Set &#39;verbose=True&#39; to receive feedback in the command line.</span>
<span class="sd">        </span>
<span class="sd">    eps : int, float, optional</span>
<span class="sd">        A real-valued scalar can be assigned to &#39;eps&#39; to reduce the wrap-around </span>
<span class="sd">        effect of wavefields in the time domain. If the inverse Fourier </span>
<span class="sd">        transform is defined as,</span>
<span class="sd">            :math:`f(t)  = \int F(\omega) \; \mathrm{e}^{\mathrm{j} \omega t} </span>
<span class="sd">            \mathrm{d}\omega`,</span>
<span class="sd">        which is ensured if the function **K1W2X1T** is used, &#39;eps&#39; </span>
<span class="sd">        (:math:`=\epsilon`) should be positive to the suppress wrap-around </span>
<span class="sd">        effect from positive to negative time,</span>
<span class="sd">            :math:`f(t) \mathrm{e}^{- \epsilon t} = </span>
<span class="sd">            \int F(\omega + \mathrm{j} \epsilon) \; </span>
<span class="sd">            \mathrm{e}^{\mathrm{j} (\omega + \mathrm{j} \epsilon) t} </span>
<span class="sd">            \mathrm{d}\omega`.</span>
<span class="sd">        Recommended value eps = :math:`\\frac{3 nf}{dt}`.</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    class</span>
<span class="sd">        A class to define a wavefield in a 1.5D non-reciprocal medium in the </span>
<span class="sd">        horizontal-wavenumber frequency domain. The following instances are </span>
<span class="sd">        defined:</span>
<span class="sd">            - **nt**: Number of time samples.</span>
<span class="sd">            - **dt**: Time sample interval in seconds.</span>
<span class="sd">            - **nr**: Number of space samples.</span>
<span class="sd">            - **dx1**: Number of space samples.</span>
<span class="sd">            - **verbose**: If one sets &#39;verbose=True&#39; feedback will be output </span>
<span class="sd">            in the command line.</span>
<span class="sd">            - **eps**: Scalar constant to reduce temporal wrap-around effect.</span>
<span class="sd">            - **nf**: Number of positive time samples :math:`=0.5 nt + 1`.</span>
<span class="sd">            - **nk**: Number of positive space samples :math:`=0.5 nr + 1`.</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    We format the data as described below.</span>
<span class="sd">        - Wavefields are saved in an array of dimensions (nf,nr) in the </span>
<span class="sd">        frequency domain and (nt,nr) in the time domain.</span>
<span class="sd">        - Wavefields are in the :math:`k_1`-:math:`\omega` domain.</span>
<span class="sd">        - The zero frequency component is placed at the first index position of </span>
<span class="sd">        the first dimension.</span>
<span class="sd">        - The zero horizontal-wavenumber component is placed at the first index </span>
<span class="sd">        position of the second dimension.</span>
<span class="sd">        - If the wavefield is transformed to the space-time domain: </span>
<span class="sd">            - The zero time component is placed at the first index position of </span>
<span class="sd">            the first dimension, followed by nt/2-1 positive time samples and </span>
<span class="sd">            nt/2 negative time samples. </span>
<span class="sd">            - The zero offset component is placed at the first index position </span>
<span class="sd">            of the second dimension, followed by nr/2-1 positive offset samples </span>
<span class="sd">            and nr/2 negative offset samples.</span>
<span class="sd">            </span>
<span class="sd">     </span>
<span class="sd">    Examples</span>
<span class="sd">    -------- </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # Initialise a wavefield class</span>
<span class="sd">    &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">    &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">nr</span><span class="p">,</span><span class="n">dx1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Wavefield_NRM_k1_w: nr has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Wavefield_NRM_k1_w: nt has to be an integer.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Wavefield_NRM_k1_w: dt has to be an integer or a float.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dx1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dx1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Wavefield_NRM_k1_w: dx1 has to be an integer or a float.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nt</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">nr</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">dt</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">dx1</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Wavefield_NRM_k1_w: nt, nr, dt and dx1 must be greater than zero.&#39;</span><span class="p">)</span>
        <span class="c1"># Check if verbose is a bool</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">verbose</span><span class="p">,</span><span class="nb">bool</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Wavefield_NRM_k1_w: </span><span class="se">\&#39;</span><span class="s1">verbose</span><span class="se">\&#39;</span><span class="s1"> must be of the type bool.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Wavefield_NRM_k1_w: </span><span class="se">\&#39;</span><span class="s1">eps</span><span class="se">\&#39;</span><span class="s1"> must be of the type int or float.&#39;</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">nt</span> <span class="o">=</span> <span class="n">nt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nr</span> <span class="o">=</span> <span class="n">nr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx1</span> <span class="o">=</span> <span class="n">dx1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nf</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Index of Nyquist frequency + 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nk</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Index of Nyquist space sample + 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">author</span> <span class="o">=</span> <span class="s2">&quot;Christian Reinicke&quot;</span>
        
    <span class="c1"># Horizontal-wavenumber sampling    </span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.Dk1"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.Dk1">[docs]</a>    <span class="k">def</span> <span class="nf">Dk1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns horizontal-wavenumber sampling interval :math:`\Delta k_1` in :math:`\mathrm{m}^{-1}`.</span>
<span class="sd">        </span>
<span class="sd">        The horizontal-wavenumber sampling interval is defined by the space sampling interval :math:`\Delta x_1` (&#39;dx1&#39;) and the number of space samples &#39;nr&#39;. </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        float</span>
<span class="sd">            Horizontal-wavenumber sample interval in :math:`\mathrm{m}^{-1}` :math:`\Delta k_1` :math:`= \\frac{2 \pi}{\Delta x_1 \; nr}`.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">        &gt;&gt;&gt; F.Dk1()</span>
<span class="sd">        0.002454369260617026</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">)</span></div>
    
    <span class="c1"># Horizontal-wavenumber vector    </span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.K1vec"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.K1vec">[docs]</a>    <span class="k">def</span> <span class="nf">K1vec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a vector of all horizontal-wavenumber samples :math:`k_1` in :math:`\mathrm{m}^{-1}`.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains the horizontal-wavenumber vector:</span>
<span class="sd">                - **k1vec**: nr/2 negative horizontal-wavenumbers are placed in the first part, followed by zero horizontal-wavenumber (index position nr/2), and nr/2-1 positive horizontal-wavenumbers.</span>
<span class="sd">                - **k1vecfft**: zero horizontal-wavenumber is placed at the first index position, followed by nr/2-1 positive horizontal-wavenumbers, and nr/2 negative horizontal-wavenumbers.</span>
<span class="sd">           The vector has the shape (nr,1). The Nyquist component is negative.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">        &gt;&gt;&gt; F.K1vec()[&#39;k1vecfft&#39;][F.nk-1,0]</span>
<span class="sd">        -0.6283185307179586</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dk1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dk1</span><span class="p">()</span>
        <span class="n">k1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">k1vec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dk1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">k1vecfft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">k1vec</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;k1vec&#39;</span><span class="p">:</span><span class="n">k1vec</span><span class="p">,</span><span class="s1">&#39;k1vecfft&#39;</span><span class="p">:</span><span class="n">k1vecfft</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
    <span class="c1"># Frequency sampling    </span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.Dw"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.Dw">[docs]</a>    <span class="k">def</span> <span class="nf">Dw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns frequency sampling interval :math:`\Delta` :math:`\omega` in radians.</span>
<span class="sd">        </span>
<span class="sd">        The frequency sampling interval is defined by the time sampling interval :math:`\Delta t` (&#39;dt&#39;) and the number of time samples &#39;nt&#39;. </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        float</span>
<span class="sd">            Frequency sample interval in radians :math:`\Delta \omega` :math:`= \\frac{2 \pi}{\Delta t \; nt}`</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">        &gt;&gt;&gt; F.Dw()</span>
<span class="sd">        1.227184630308513</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">)</span></div>
      
    <span class="c1"># Frequency vector    </span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.Wvec"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.Wvec">[docs]</a>    <span class="k">def</span> <span class="nf">Wvec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a vector of all frequency samples :math:`\omega` in radians.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Frequency vector, zero frequency is placed at the first index position. The vector has the shape (nf,1). If &#39;self.eps&#39; is defined, an imaginary constant :math:`\epsilon` is added to the frequency vector. </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">        &gt;&gt;&gt; F.Wvec()</span>
<span class="sd">        array([[0.], ..., [628.31853072]])</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">)</span>
        <span class="n">wvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">wvec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dw</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">)</span>
        
        <span class="c1"># Add imaginary constant to the frequency</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">wvec</span> <span class="o">=</span> <span class="n">wvec</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
 
        <span class="k">return</span> <span class="n">wvec</span></div>
    
    <span class="c1"># Make a 2D meshgrid in w-k1-domain</span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.W_K1_grid"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.W_K1_grid">[docs]</a>    <span class="k">def</span> <span class="nf">W_K1_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns frequency horizontal-wavenumber meshgrids. </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains a meshgrid</span>
<span class="sd">                - **Wgrid**: with the frequency vector *wvec* (the zero frequency sample is placed at the first index position) along the 1st dimension, and nr copies of it along the 2nd dimension.</span>
<span class="sd">                - **Xgrid**: with the offset vector *xvec* (the zero offset sample is placed in the center) along the 2nd dimension, and nt copies of it along the 1st dimension.</span>
<span class="sd">                - **Xgridfft**: with the offset vector *xvecfft* (the zero offset sample is placed at the first index position) along the 2nd dimension, and nt copies of it along the 1st dimension.</span>
<span class="sd">            All output arrays have the shape (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">        &gt;&gt;&gt; F.W_K1_grid()[&#39;Wgrid&#39;][:,0]</span>
<span class="sd">        array([ 0.        ,  1.22718463,  2.45436926, ..., 628.3185307179587])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wvec</span><span class="p">()</span>
        <span class="n">k1vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K1vec</span><span class="p">()[</span><span class="s1">&#39;k1vec&#39;</span><span class="p">]</span>
        <span class="n">k1vecfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K1vec</span><span class="p">()[</span><span class="s1">&#39;k1vecfft&#39;</span><span class="p">]</span>
        <span class="n">K1grid</span><span class="p">,</span><span class="n">Wgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">k1vec</span><span class="p">,</span><span class="n">wvec</span><span class="p">)</span>
        <span class="n">K1gridfft</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">k1vecfft</span><span class="p">,</span><span class="n">wvec</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">:</span><span class="n">Wgrid</span><span class="p">,</span><span class="s1">&#39;K1grid&#39;</span><span class="p">:</span><span class="n">K1grid</span><span class="p">,</span><span class="s1">&#39;K1gridfft&#39;</span><span class="p">:</span><span class="n">K1gridfft</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
    <span class="c1"># Space vector</span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.Xvec"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.Xvec">[docs]</a>    <span class="k">def</span> <span class="nf">Xvec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a vector of all spatial samples :math:`x_1` in metres.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains the offset vector,</span>
<span class="sd">                - **xvec**: zero offset placed at the center.</span>
<span class="sd">                - **xvecfft**: zero offset placed at the first index position.</span>
<span class="sd">            Both vectors have the shape (nr,1).</span>
<span class="sd">                </span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">        &gt;&gt;&gt; F.Xvec()[&#39;xvec&#39;]</span>
<span class="sd">        array([[-1280.], ...,[ 1275.]])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">xvec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">xvecfft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">xvec</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xvec&#39;</span><span class="p">:</span><span class="n">xvec</span><span class="p">,</span><span class="s1">&#39;xvecfft&#39;</span><span class="p">:</span><span class="n">xvecfft</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
    <span class="c1"># Time vector</span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.Tvec"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.Tvec">[docs]</a>    <span class="k">def</span> <span class="nf">Tvec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a vector of all time samples :math:`t` in seconds.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains the time vector, </span>
<span class="sd">                - **tvec**: zero time placed at the center. </span>
<span class="sd">                - **tvecfft**: zero time placed at the first index position.</span>
<span class="sd">            Both vectors have the shape (nt,1).</span>
<span class="sd">                </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">        &gt;&gt;&gt; F.Tvec()[&#39;tvec&#39;]</span>
<span class="sd">        array([[-2.56 ], ..., [ 2.555]])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">tvec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tvecfft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">tvec</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;tvec&#39;</span><span class="p">:</span><span class="n">tvec</span><span class="p">,</span><span class="s1">&#39;tvecfft&#39;</span><span class="p">:</span><span class="n">tvecfft</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
    <span class="c1"># Make a 2D meshgrid in t-x-domain</span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.T_X_grid"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.T_X_grid">[docs]</a>    <span class="k">def</span> <span class="nf">T_X_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns time-space meshgrids. </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains the meshgrid</span>
<span class="sd">                - **Tgrid**: with the time vector *tvec* (the zero time sample is placed in the center) along the 1st dimension, and nr copies of it along the 2nd dimension.</span>
<span class="sd">                - **Xgrid**: with the offset vector *xvec* (the zero offset sample is placed in the center) along the 2nd dimension, and nt copies of it along the 1st dimension.</span>
<span class="sd">                - **Tgridfft**: with the time vector *tvecfft* (the zero time sample is placed at the first index position) along the 1st dimension, and nr copies of it along the 2nd dimension.</span>
<span class="sd">                - **Xgridfft**: with the offset vector *xvecfft* (the zero offset sample is placed at the first index position) along the 2nd dimension, and nt copies of it along the 1st dimension.</span>
<span class="sd">            All output arrays have the shape (nt,nr).</span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=5)</span>
<span class="sd">        &gt;&gt;&gt; F.T_X_grid()[&#39;Tgridfft&#39;][:,0]</span>
<span class="sd">        array([ 0.   ,  0.005,  0.01 , ..., -0.015, -0.01 , -0.005])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tvec</span><span class="p">()[</span><span class="s1">&#39;tvec&#39;</span><span class="p">]</span>
        <span class="n">tvecfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tvec</span><span class="p">()[</span><span class="s1">&#39;tvecfft&#39;</span><span class="p">]</span>
        <span class="n">xvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xvec</span><span class="p">()[</span><span class="s1">&#39;xvec&#39;</span><span class="p">]</span>
        <span class="n">xvecfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xvec</span><span class="p">()[</span><span class="s1">&#39;xvecfft&#39;</span><span class="p">]</span>
        <span class="n">Xgrid</span><span class="p">,</span><span class="n">Tgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span><span class="n">tvec</span><span class="p">)</span>
        <span class="n">Xgridfft</span><span class="p">,</span><span class="n">Tgridfft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xvecfft</span><span class="p">,</span><span class="n">tvecfft</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Tgrid&#39;</span><span class="p">:</span><span class="n">Tgrid</span><span class="p">,</span><span class="s1">&#39;Xgrid&#39;</span><span class="p">:</span><span class="n">Xgrid</span><span class="p">,</span><span class="s1">&#39;Tgridfft&#39;</span><span class="p">:</span><span class="n">Tgridfft</span><span class="p">,</span><span class="s1">&#39;Xgridfft&#39;</span><span class="p">:</span><span class="n">Xgridfft</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
    <span class="c1"># Make a 2D meshgrid in w-x-domain</span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.W_X_grid"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.W_X_grid">[docs]</a>    <span class="k">def</span> <span class="nf">W_X_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns two frequency-space meshgrids. </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains a meshgrid</span>
<span class="sd">                - **Wgrid**: with the frequency vector *wvec* (the zero frequency sample is placed at the first index position) along the 1st dimension, and nr copies of it along the 2nd dimension.</span>
<span class="sd">                - **Xgrid**: with the offset vector *xvec* (the zero offset sample is placed in the center) along the 2nd dimension, and nt copies of it along the 1st dimension.</span>
<span class="sd">                - **Xgridfft**: with the offset vector *xvecfft* (the zero offset sample is placed at the first index position) along the 2nd dimension, and nt copies of it along the 1st dimension.</span>
<span class="sd">            All output arrays have the shape (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Wavefield_NRM_k1_w import Wavefield_NRM_k1_w as WF</span>
<span class="sd">        &gt;&gt;&gt; F=WF(nt=1024,dt=0.005,nr=512,dx1=10)</span>
<span class="sd">        &gt;&gt;&gt; F.W_X_grid()[&#39;Wgrid&#39;][:,0]</span>
<span class="sd">        array([ 0.        ,  1.22718463,  2.45436926, ..., 628.3185307179587])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wvec</span><span class="p">()</span>
        <span class="n">xvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xvec</span><span class="p">()[</span><span class="s1">&#39;xvec&#39;</span><span class="p">]</span>
        <span class="n">xvecfft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xvec</span><span class="p">()[</span><span class="s1">&#39;xvecfft&#39;</span><span class="p">]</span>
        <span class="n">Xgrid</span><span class="p">,</span><span class="n">Wgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xvec</span><span class="p">,</span><span class="n">wvec</span><span class="p">)</span>
        <span class="n">Xgridfft</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xvecfft</span><span class="p">,</span><span class="n">wvec</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">:</span><span class="n">Wgrid</span><span class="p">,</span><span class="s1">&#39;Xgrid&#39;</span><span class="p">:</span><span class="n">Xgrid</span><span class="p">,</span><span class="s1">&#39;Xgridfft&#39;</span><span class="p">:</span><span class="n">Xgridfft</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
    <span class="c1"># Transform wavefield from k1-w-domain to x1-t-domain</span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.K1W2X1T"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.K1W2X1T">[docs]</a>    <span class="k">def</span> <span class="nf">K1W2X1T</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">array_k1w</span><span class="p">,</span><span class="n">NumPy_fft_Sign_Convention</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">K1W_fft_Same_Sign</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;applies an inverse Fourier transform from the :math:`k_1`-:math:`\omega` domain to  the :math:`x_1`-:math:`t` domain. </span>
<span class="sd">        </span>
<span class="sd">        We assume that the space-time domain signal is real-valued (:math:`x_1`-:math:`t` domain). Therefore, we use the NumPy function :py:class:`numpy.fft.irfftn`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        array_k1w : numpy.ndarray</span>
<span class="sd">            Array in the :math:`k_1`-:math:`\omega` domain, shape (nf,nr).</span>
<span class="sd">        </span>
<span class="sd">        NumPy_fft_Sign_Convention : bool, optional</span>
<span class="sd">            Set &#39;NumPy_fft_Sign_Convention=True&#39; if the temporal inverse Fourier transform is defined with same sign convention as Numpy&#39;s :py:class:`numpy.fft.ifft`: :math:`\int \cdot \; \mathrm{e}^{+\mathrm{j} \omega t} \mathrm{d}\omega`. </span>
<span class="sd">            </span>
<span class="sd">        K1W_fft_Same_Sign : bool, optional</span>
<span class="sd">            - Set &#39;K1W_fft_Same_Sign=True&#39; to apply the temporal and the spatial inverse Fourier tansform with the same signs in the exponential: :math:`\int\int \cdot \; \mathrm{e}^{\pm(\mathrm{j} \omega t + \mathrm{j} k_1 x_1)} \mathrm{d}k_1 \; \mathrm{d}\omega`.</span>
<span class="sd">            - Set &#39;K1W_fft_Same_Sign=False&#39; to apply the temporal and the spatial inverse Fourier tansform with opposite signs in the exponential: :math:`\int\int \cdot \; \mathrm{e}^{\pm(\mathrm{j} \omega t - \mathrm{j} k_1 x_1)} \mathrm{d}k_1 \; \mathrm{d}\omega`.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Real-valued array in the :math:`x_1`-:math:`t` domain, shape (nt,nr).</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">            - In the sub-class **Layered_NRM_k1_w**, we define the wavefield propagators with a positive sign, :math:`\\tilde{w}^{\pm} = \mathrm{exp}(+j k_3&#39;(\omega) \Delta x_3)`. Thus, we implicitly assume that the temporal inverse Fourier transfrom is defined with a negative sign in the exponential function, which is why we set by default &#39;NumPy_fft_Sign_Convention=False&#39;.</span>
<span class="sd">        </span>
<span class="sd">            - By default, we set &#39;K1W_fft_Same_Sign=False&#39;, i.e. the default definition of the inverse Fourier transform is,</span>
<span class="sd">            \t\t:math:`f(x_1,t)= \\frac{1}{(2\pi)^2} \int \int F(k_1,\omega) \; \mathrm{e}^{-\mathrm{j}\omega t + \mathrm{j} k_1 x_1} \; \mathrm{d}\omega \; \mathrm{d}k_1`.</span>
<span class="sd">                                                                                                                    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array_k1w</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;K1W2X1T: The input variable </span><span class="se">\&#39;</span><span class="s1">array_k1w</span><span class="se">\&#39;</span><span class="s1"> must be of the type numpy.ndarray.&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">array_k1w</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;K1W2X1T: The input variable </span><span class="se">\&#39;</span><span class="s1">array_k1w</span><span class="se">\&#39;</span><span class="s1"> must have the shape (nf,nr).&#39;</span><span class="p">)</span>
        
        <span class="c1"># If the sign convention for the inverse temporal Fourier transform  is </span>
        <span class="c1"># opposite to NumPy&#39;s ifft convention, we complex-conjugate the </span>
        <span class="c1"># wavefield before applying an ifft.</span>
        <span class="k">if</span> <span class="n">NumPy_fft_Sign_Convention</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">array_k1w</span> <span class="o">=</span> <span class="n">array_k1w</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            
        <span class="c1"># If the temporal and spatial Fourier transforms are defined with </span>
        <span class="c1"># opposite signs, we reverse the horizontal-wavenumber dimension.</span>
        <span class="k">if</span> <span class="n">K1W_fft_Same_Sign</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">array_k1w</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">array_k1w</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="c1"># Numpy&#39;s irfftn applies a standard ifftn along along specified axes,</span>
        <span class="c1"># and an irfft along the last specified axis.</span>
        <span class="c1"># Here, we want to apply the irfft along time/frequency (1st axis).</span>
        <span class="c1"># Thus, we apply a transpose before and after applying irfftn.</span>
        <span class="n">array_x1t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfftn</span><span class="p">(</span><span class="n">array_k1w</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        
        <span class="k">return</span> <span class="n">array_x1t</span></div>
    
    <span class="c1"># Transform wavefield from x1-t-domain to k1-w-domain</span>
<div class="viewcode-block" id="Wavefield_NRM_k1_w.X1T2K1W"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.X1T2K1W">[docs]</a>    <span class="k">def</span> <span class="nf">X1T2K1W</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">array_x1t</span><span class="p">,</span><span class="n">NumPy_fft_Sign_Convention</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">K1W_fft_Same_Sign</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;applies a forward Fourier transform from the :math:`x_1`-:math:`t` domain to the :math:`k1_1`-:math:`\omega` domain. </span>
<span class="sd">        </span>
<span class="sd">        We assume that the space-time domain signal is real-valued (:math:`x_1`-:math:`t` domain). Therefore, we use the NumPy function :py:class:`numpy.fft.rfftn`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        array_pt : numpy.ndarray</span>
<span class="sd">            Real-valued array in the :math:`x_1`-:math:`t` domain, shape (nt,nr).</span>
<span class="sd">            </span>
<span class="sd">        NumPy_fft_Sign_Convention : bool, optional</span>
<span class="sd">            Set &#39;NumPy_fft_Sign_Convention=True&#39; if the temporal forward Fourier transform is defined with same sign convention as Numpy&#39;s :py:class:`numpy.fft.fft`: :math:`\int \cdot \; \mathrm{e}^{-\mathrm{j} \omega t} \mathrm{d}t`. </span>
<span class="sd">            </span>
<span class="sd">        K1W_fft_Same_Sign : bool, optional</span>
<span class="sd">            - Set &#39;K1W_fft_Same_Sign=True&#39; to apply the temporal and the spatial forward Fourier tansform with the same signs in the exponential: :math:`\int\int \cdot \; \mathrm{e}^{\pm(\mathrm{j} \omega t + \mathrm{j} k_1 x_1)} \mathrm{d}x_1 \; \mathrm{d}t`.</span>
<span class="sd">            - Set &#39;K1W_fft_Same_Sign=False&#39; to apply the temporal and the spatial forward Fourier tansform with opposite signs in the exponential: :math:`\int\int \cdot \; \mathrm{e}^{\pm(\mathrm{j} \omega t - \mathrm{j} k_1 x_1)} \mathrm{d}x_1 \; \mathrm{d}t`.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array in the :math:`k_1`-:math:`\omega` domain, shape (nf,nr).</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">            - In the sub-class **Layered_NRM_k1_w** we define the wavefield propagators with a positive sign, :math:`\\tilde{w}^{\pm} = \mathrm{exp}(+j k_3&#39;(\omega) \Delta x_3)`. Thus, we implicitly assume that the temporal forward Fourier transfrom is defined with a positive sign in the exponential, which is why we set by default &#39;NumPy_fft_Sign_Convention=False&#39;.</span>
<span class="sd">        </span>
<span class="sd">            - By default, we set ‘K1W_fft_Same_Sign=False’, i.e. the default definition of the forward Fourier transform is,</span>
<span class="sd">            \t\t:math:`F(k_1,\omega)=\int \int f(x_1,\omega) \mathrm{e}^{+\mathrm{j}\omega t - \mathrm{j} k_1 x_1} \; \mathrm{d}t \; \mathrm{d}x_1`.</span>
<span class="sd">    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array_x1t</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;X1T2K1W: The input variable </span><span class="se">\&#39;</span><span class="s1">array_x1t</span><span class="se">\&#39;</span><span class="s1"> must be of the type numpy.ndarray.&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">array_x1t</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;X1T2K1W: The input variable </span><span class="se">\&#39;</span><span class="s1">array_x1t</span><span class="se">\&#39;</span><span class="s1"> must have the shape (nt,nr).&#39;</span><span class="p">)</span>
            
        <span class="c1"># Numpy&#39;s rfftn applies a standard fftn along along specified axes,</span>
        <span class="c1"># and an rfft along the last specified axis.</span>
        <span class="c1"># Here, we want to apply the rfft along time/frequency (1st axis).</span>
        <span class="c1"># Thus, we apply a transpose before and after applying rfftn.</span>
        <span class="n">array_k1w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftn</span><span class="p">(</span><span class="n">array_x1t</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        
        <span class="c1"># If the sign convention for the forward temporal Fourier transform  is </span>
        <span class="c1"># opposite to NumPy&#39;s fft convention, we introduced an error above.</span>
        <span class="c1"># To correct the error, we complex-conjugate the result.</span>
        <span class="k">if</span> <span class="n">NumPy_fft_Sign_Convention</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">array_k1w</span> <span class="o">=</span> <span class="n">array_k1w</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            
        <span class="c1"># If the temporal and spatial Fourier transforms are defined with </span>
        <span class="c1"># opposite signs, we reverse the horizontal-wavenumber dimension.</span>
        <span class="k">if</span> <span class="n">K1W_fft_Same_Sign</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">array_k1w</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">array_k1w</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">array_k1w</span></div>
    
<div class="viewcode-block" id="Wavefield_NRM_k1_w.RickerWavelet_w"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.RickerWavelet_w">[docs]</a>    <span class="k">def</span> <span class="nf">RickerWavelet_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">f0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">w0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">NormalisationToOne</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes a Ricker wavelet in the frequency domain. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        f0 : int, float, optional</span>
<span class="sd">            Value of the most energetic frequency :math:`f_0` in Hz.</span>
<span class="sd">            </span>
<span class="sd">        w0 : int, float, optional</span>
<span class="sd">            Value of the most energetic frequency :math:`\omega_0` in radians.</span>
<span class="sd">            </span>
<span class="sd">        NormalisationToOne : bool, optional</span>
<span class="sd">            Set &#39;NormalisationToOne=False&#39; to keep the analytic scaling of the </span>
<span class="sd">            Ricker wavelet.  For &#39;NormalisationToOne=True&#39; the Ricker wavelet </span>
<span class="sd">            is scaled by the inverse of the amplitude of the peak frequency </span>
<span class="sd">            :math:`\\frac{2}{\mathrm{e}\sqrt{\pi}\omega_0}`.</span>
<span class="sd">            </span>
<span class="sd">        eps : int, float, optional</span>
<span class="sd">            The input variable eps can be defined to compute the wavelet for an </span>
<span class="sd">            &#39;eps&#39; value different than the &#39;self.eps&#39; parameter.</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of the shape (nf,nr). The Ricker wavelet (in the frequency </span>
<span class="sd">            domain) is saved along the first dimension and copied nr times </span>
<span class="sd">            along the second dimension.</span>
<span class="sd">            </span>
<span class="sd">            :math:`R(\omega) = \\frac{2\omega^2}{\sqrt{\pi}\omega_0^3}</span>
<span class="sd">            \mathrm{e}^{-\\frac{\omega^2}{\omega_0^2}}`</span>
<span class="sd">            </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        .. [1] Y. Wang, &quot;Frequencies of the Ricker wavelet,&quot; Geophysics 80.2 </span>
<span class="sd">        (2015): A31-A37.</span>
<span class="sd"> </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">NormalisationToOne</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RickerWavelet_w: The input variables </span><span class="se">\&#39;</span><span class="s1">NormalisationToOne</span><span class="se">\&#39;</span><span class="s1"> must be of the type bool.&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">f0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">w0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RickerWavelet_w: One the input variables, </span><span class="se">\&#39;</span><span class="s1">f0</span><span class="se">\&#39;</span><span class="s1"> or  </span><span class="se">\&#39;</span><span class="s1">w0</span><span class="se">\&#39;</span><span class="s1">, must be given. </span><span class="se">\&#39;</span><span class="s1">f0</span><span class="se">\&#39;</span><span class="s1"> or  </span><span class="se">\&#39;</span><span class="s1">w0</span><span class="se">\&#39;</span><span class="s1"> are the most energetic frequency either in hertz or in radians.&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">f0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">w0</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">w0</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RickerWavelet_w: The input variables </span><span class="se">\&#39;</span><span class="s1">w0</span><span class="se">\&#39;</span><span class="s1"> must be of the type int or float.&#39;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">w0</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RickerWavelet_w: The input variables </span><span class="se">\&#39;</span><span class="s1">w0</span><span class="se">\&#39;</span><span class="s1"> must be greater than zero.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">f0</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">f0</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RickerWavelet_w: The input variables </span><span class="se">\&#39;</span><span class="s1">f0</span><span class="se">\&#39;</span><span class="s1"> must be of the type int or float.&#39;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">f0</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RickerWavelet_w: The input variables </span><span class="se">\&#39;</span><span class="s1">f0</span><span class="se">\&#39;</span><span class="s1"> must be greater than zero.&#39;</span><span class="p">)</span>
 
            <span class="c1"># Transform to circular frequency               </span>
            <span class="n">w0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f0</span>
        
        <span class="c1"># Frequency vector</span>
        <span class="k">if</span> <span class="n">eps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>        
            <span class="n">wvec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wvec</span><span class="p">()</span>   
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RickerWavelet_w: </span><span class="se">\&#39;</span><span class="s1">eps</span><span class="se">\&#39;</span><span class="s1"> must be of the type int or &#39;</span>
                         <span class="o">+</span><span class="s1">&#39;float.&#39;</span><span class="p">)</span>
            <span class="n">wvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wvec</span><span class="p">()</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">eps</span>
        
        <span class="c1"># Compute wavelet according to Wang 2015</span>
        <span class="n">Wav</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">wvec</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">w0</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">wvec</span><span class="o">/</span><span class="n">w0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># Optionally scale the wavelet</span>
        <span class="k">if</span> <span class="n">NormalisationToOne</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">peak</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">w0</span><span class="p">)</span>
            <span class="n">Wav</span>  <span class="o">=</span> <span class="n">Wav</span><span class="o">/</span><span class="n">peak</span>
            
        <span class="c1"># Copy the wavelet along the spatial dimension</span>
        <span class="n">Wav</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">Wav</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">Wav</span></div>
    
<div class="viewcode-block" id="Wavefield_NRM_k1_w.Gain_t"><a class="viewcode-back" href="../Wavefield_NRM_k1_w.html#Wavefield_NRM_k1_w.Wavefield_NRM_k1_w.Gain_t">[docs]</a>    <span class="k">def</span> <span class="nf">Gain_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">RelativeTaperLength</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes a gain function in the time domain to compensate for the </span>
<span class="sd">        imaginary constant :math:`\epsilon` added to the frequencies</span>
<span class="sd">        :math:`\omega&#39; = \omega + \mathrm{j}\epsilon`.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        RelativeTaperLength : int, float, optional</span>
<span class="sd">            The product of \&#39;RelativeTaperLength\&#39; and the number of temporal </span>
<span class="sd">            samples \&#39;nt\&#39; determines the taper length. The default value is </span>
<span class="sd">            \&#39;RelativeTaperLength\&#39;:math:`=2^{-5}.`</span>
<span class="sd">            </span>
<span class="sd">        eps : int, float, optional</span>
<span class="sd">            To compute the gain for an &#39;eps&#39; value different than the &#39;self.eps&#39; </span>
<span class="sd">            parameter the input variable eps can be defined.</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of the shape (nt,nr). The exponential gain function </span>
<span class="sd">            :math:`\mathrm{e}^{\epsilon t}` is sorted along the first dimension </span>
<span class="sd">            (time zero element followed by positive time samples, then negative </span>
<span class="sd">            time samples).</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Gain_t </span><span class="se">\&#39;</span><span class="s1">RelativeTaperLength</span><span class="se">\&#39;</span><span class="s1"> must be of the type int or float.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check that RelativeTaperLength is not smaller than zero</span>
        <span class="k">if</span> <span class="n">RelativeTaperLength</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Gain_t: </span><span class="se">\&#39;</span><span class="s1">RelativeTaperLength</span><span class="se">\&#39;</span><span class="s1"> must be greater than, or equal to zero.&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">eps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subeps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Gain_t: </span><span class="se">\&#39;</span><span class="s1">eps</span><span class="se">\&#39;</span><span class="s1"> must be of the type int or float.&#39;</span><span class="p">)</span>
            <span class="n">subeps</span> <span class="o">=</span> <span class="n">eps</span>    
    
        <span class="c1"># Compute gain</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="n">subeps</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">Tvec</span><span class="p">()[</span><span class="s1">&#39;tvecfft&#39;</span><span class="p">]</span> <span class="p">)</span>
        
        <span class="c1"># Apply taper</span>
        <span class="n">taperlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">taperlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">taperlen</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
            
            <span class="n">gain_max</span> <span class="o">=</span> <span class="n">gain</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">taperlen</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">gain_min</span> <span class="o">=</span> <span class="n">gain</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">gain</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">taperlen</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">gain_max</span> <span class="o">-</span> <span class="n">gain_min</span><span class="p">)</span><span class="o">*</span><span class="n">tap</span> 
                                                    <span class="o">+</span> <span class="n">gain_min</span>                <span class="p">)</span>
            
        <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">gain</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">gain</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Christian Reinicke, Kees Wapenaar, and Evert Slob.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.2.
    </div>
  </body>
</html>