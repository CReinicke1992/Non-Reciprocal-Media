
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Layered_NRM_k1_w &#8212; Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Layered_NRM_k1_w</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Routines for modelling wavefields in 1.5D non-reciprocal media.</span>

<span class="sd">.. module:: Wavefield_NRM_k1_w-v2.0</span>

<span class="sd">:Authors:</span>
<span class="sd">    Christian Reinicke (c.reinicke@tudelft.nl), Kees Wapenaar (), and Evert Slob ()</span>
<span class="sd">    </span>
<span class="sd">:Copyright:</span>
<span class="sd">    Christian Reinicke (c.reinicke@tudelft.nl), Kees Wapenaar (), and Evert Slob ()</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">Wavefield_NRM_k1_w</span> <span class="k">import</span> <span class="n">Wavefield_NRM_k1_w</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>

<div class="viewcode-block" id="Layered_NRM_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w">[docs]</a><span class="k">class</span> <span class="nc">Layered_NRM_k1_w</span><span class="p">(</span><span class="n">Wavefield_NRM_k1_w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;is a class to model wavefields in 1.5D (non-)reciprocal media in the </span>
<span class="sd">    horizontal-wavenumber frequency domain.</span>
<span class="sd">        </span>
<span class="sd">    The class Layered_NRM_k1_w defines a 1.5D (non-)reciprocal medium and a </span>
<span class="sd">    scalar wavefield. We consider all horizontal-wavenumbers and all </span>
<span class="sd">    frequencies, that are sampled by the given number of samples and by the </span>
<span class="sd">    given sample intervals, in space (&#39;nr&#39;, &#39;dx1&#39;) as well as in time </span>
<span class="sd">    (&#39;nt&#39;, &#39;dt&#39;).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of time samples.</span>
<span class="sd">    </span>
<span class="sd">    dt : int, float</span>
<span class="sd">        Time sample interval in seconds.</span>
<span class="sd">        </span>
<span class="sd">    nr : int</span>
<span class="sd">        Number of space samples.</span>
<span class="sd">    </span>
<span class="sd">    dx1 : int, float</span>
<span class="sd">        Space sample interval in metres.</span>
<span class="sd">        </span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Set &#39;verbose=True&#39; to receive feedback in the command line.</span>
<span class="sd">        </span>
<span class="sd">    eps : int, float, optional</span>
<span class="sd">        A real-valued scalar can be assigned to &#39;eps&#39; to reduce the wrap-around </span>
<span class="sd">        effect of wavefields in the time domain. If the inverse Fourier </span>
<span class="sd">        transform is defined as,</span>
<span class="sd">            :math:`f(t)  = \int F(\omega) \; \mathrm{e}^{\mathrm{j} \omega t} </span>
<span class="sd">            \mathrm{d}\omega`,</span>
<span class="sd">        which is ensured if the function **K1W2X1T** is used, &#39;eps&#39; </span>
<span class="sd">        (:math:`=\epsilon`) should be positive to the suppress wrap-around </span>
<span class="sd">        effect from positive to negative time,</span>
<span class="sd">            :math:`f(t) \mathrm{e}^{- \epsilon t} = </span>
<span class="sd">            \int F(\omega + \mathrm{j} \epsilon) \; </span>
<span class="sd">            \mathrm{e}^{\mathrm{j} (\omega + \mathrm{j} \epsilon) t} </span>
<span class="sd">            \mathrm{d}\omega`.</span>
<span class="sd">        Recommended value eps = :math:`\\frac{3 nf}{dt}`.</span>
<span class="sd">        </span>
<span class="sd">    x3vec : numpy.ndarray</span>
<span class="sd">        Vertical spatial vector :math:`x_3`, for n layers &#39;x3vec&#39; must have the </span>
<span class="sd">        shape (n,). We define the :math:`x_3`-axis as downward-pointing. </span>
<span class="sd">        Implicitly, the first value on the :math:`x_3`-axis is zero (not stored </span>
<span class="sd">        in &#39;x3vec&#39;).</span>
<span class="sd">    </span>
<span class="sd">    avec : numpy.ndarray</span>
<span class="sd">        Medium parameter :math:`\\alpha` (real-valued), for n layers &#39;avec&#39; </span>
<span class="sd">        must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">    b11vec : numpy.ndarray</span>
<span class="sd">        Medium parameter :math:`\\beta_{11}` (real-valued), for n layers </span>
<span class="sd">        &#39;b11vec&#39; must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">    b13vec : numpy.ndarray, optional</span>
<span class="sd">        Medium parameter :math:`\\beta_{13}` (real-valued), for n layers </span>
<span class="sd">        &#39;b13vec&#39; must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">    b33vec : numpy.ndarray</span>
<span class="sd">        Medium parameter :math:`\\beta_{33}` (real-valued), for n layers </span>
<span class="sd">        &#39;b33vec&#39; must have the shape (n,).</span>
<span class="sd">    </span>
<span class="sd">    g1vec : numpy.ndarray, optional</span>
<span class="sd">        Medium parameter :math:`\gamma_1` (real-valued for non-reciprocal </span>
<span class="sd">        media), for n layers &#39;g1vec&#39; must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">    g3vec : numpy.ndarray, optional</span>
<span class="sd">        Medium parameter :math:`\gamma_3` (real-valued for non-reciprocal </span>
<span class="sd">        media), for n layers &#39;g3vec&#39; must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">    ReciprocalMedium : bool, optional</span>
<span class="sd">        For non-reciprocal media set &#39;ReciprocalMedium=False&#39;, for reciprocal </span>
<span class="sd">        media set &#39;ReciprocalMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">    AdjointMedium : bool, optional</span>
<span class="sd">        Set &#39;AdjointMedium=True&#39; to compute scattering coefficients and </span>
<span class="sd">        propagators in an adjoint medium :math:`^{(a)}`. We have defined the </span>
<span class="sd">        scattering and propagation in the adjoint medium only for </span>
<span class="sd">        flux-normalisation.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    class</span>
<span class="sd">        A class to model a wavefield in a 1.5D non-reciprocal medium in the </span>
<span class="sd">        horizontal-wavenumber frequency domain. The following instances are </span>
<span class="sd">        defined:</span>
<span class="sd">            - **x3vec**: :math:`x_3`.</span>
<span class="sd">            - **avec**: :math:`\\alpha`.</span>
<span class="sd">            - **b11vec**: :math:`\\beta_{11}`.</span>
<span class="sd">            - **b13vec**: :math:`\\beta_{13}`.</span>
<span class="sd">            - **b33vec**: :math:`\\beta_{33}`.</span>
<span class="sd">            - **g1vec**: :math:`\gamma_1`.</span>
<span class="sd">            - **g3vec**: :math:`\gamma_3`.</span>
<span class="sd">            - **ReciprocalMedium**: True for reciprocal media, False for non-reciprocal media.</span>
<span class="sd">            - **AdjointMedium**: If True, propagation and scattering are defined in a medium and in its adjoint.</span>
<span class="sd">            - **k3**: Vertical-wavenumber for positive &#39;k1&#39;.</span>
<span class="sd">            - **k3n**: Vertical-wavenumber for negative &#39;k1&#39;.</span>
<span class="sd">            </span>
<span class="sd">    </span>
<span class="sd">    .. todo:: </span>
<span class="sd">        </span>
<span class="sd">        (1) In non-reciprocal media, when I use a complex-valued frequency </span>
<span class="sd">        :math:`\omega&#39;=\omega+\mathrm{j}\epsilon` the vertical wavenumber </span>
<span class="sd">        definition becomes </span>
<span class="sd">    </span>
<span class="sd">                :math:`k_3=\sqrt{(\\alpha \\beta_{11} -\gamma_1^2)\omega&#39; </span>
<span class="sd">                + 2\gamma_1 k_1 \omega&#39; -k_1^2} = </span>
<span class="sd">                \sqrt{(\\alpha \\beta_{11} - \gamma_1^2) (\omega -\epsilon^2) </span>
<span class="sd">                + 2\gamma_1 k_1 \omega -k_1^2 </span>
<span class="sd">                + \mathrm{j} 2 \epsilon </span>
<span class="sd">                [\omega (\\alpha \\beta_{11} -\gamma_1^2) + \gamma_1 k_1]}` .</span>
<span class="sd">        </span>
<span class="sd">            Hence, if </span>
<span class="sd">              </span>
<span class="sd">                :math:`\mathrm{sign}(\epsilon </span>
<span class="sd">                [\omega (\\alpha \\beta_{11} -\gamma_1^2) + \gamma_1 k_1]) &lt; 0`, </span>
<span class="sd">              </span>
<span class="sd">            the imaginary part of :math:`k_3` becomes negative, and the </span>
<span class="sd">            wavefield components :math:`\mathrm{e}^{\mathrm{j}k_3 x_3}` become </span>
<span class="sd">            unstable. I fix that by manually modifying the vertical wavenumber </span>
<span class="sd">            to </span>
<span class="sd">    </span>
<span class="sd">                :math:`k_{3,mod} = \sqrt{(\\alpha \\beta_{11} -\gamma_1^2) </span>
<span class="sd">                (\omega - \epsilon^2) + 2\gamma_1 k_1 \omega -k_1^2 </span>
<span class="sd">                + \mathrm{j} 2 \Vert \epsilon </span>
<span class="sd">                [\omega (\\alpha \\beta_{11} -\gamma_1^2) + \gamma_1 k_1] \Vert}` .</span>
<span class="sd">    </span>
<span class="sd">            For those :math:`\omega`-:math:`k_1` components for which the </span>
<span class="sd">            absolute value in :math:`k_{3,mod}` has an effect, I effectively </span>
<span class="sd">            change the sign of :math:`\epsilon`. Can we justify this fix? If </span>
<span class="sd">            not, it might be better to simply exclude those </span>
<span class="sd">            :math:`\omega`-:math:`k_1` components from the computation.</span>
<span class="sd">            </span>
<span class="sd">            In addition, the absolute value in :math:`k_{3,mod}` implies that </span>
<span class="sd">            :math:`\epsilon` should be positive. Hence, when applying an </span>
<span class="sd">            inverse Fourier transform to the time domain, one has to choose </span>
<span class="sd">            the convention, </span>
<span class="sd">            </span>
<span class="sd">                :math:`f(t)  = \int F(\omega) \; </span>
<span class="sd">                \mathrm{e}^{\mathrm{j} \omega t} \mathrm{d}\omega`.</span>
<span class="sd">            </span>
<span class="sd">            This can be done by complex-conjugating the modelled wavefield </span>
<span class="sd">            before applying the inverse Fourier transform. Note that the </span>
<span class="sd">            default settings of the 2D inverse Fourier transform function </span>
<span class="sd">            **K1W2X1T** handle all these sign choices correctly as long as </span>
<span class="sd">            :math:`\epsilon &gt;0`.</span>
<span class="sd">            </span>
<span class="sd">        (2) In reciprocal media, for Im(:math:`\gamma_i`) :math:`\\neq 0`, </span>
<span class="sd">        energy conservation does not hold for evanescent waves. (Reciprocal </span>
<span class="sd">        media are not yet included in version 2.0. However, when reciprocal</span>
<span class="sd">        media are included this remark should be checked carefully.)</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    </span>
<span class="sd">    - We format the data as described below.</span>
<span class="sd">        - Wavefields are saved in an array of dimensions (nf,nr) in the frequency domain and (nt,nr) in the time domain.</span>
<span class="sd">        - Wavefields are in the :math:`k_1`-:math:`\omega` domain.</span>
<span class="sd">            - The zero frequency component is placed at the first index position of the first dimension.</span>
<span class="sd">            - The zero horizontal-wavenumber component is placed at the first index position of the second dimension.</span>
<span class="sd">        - If the wavefield is transformed to the space-time domain: </span>
<span class="sd">            - The zero time component is placed at the first index position of the first dimension, followed by nt/2-1 positive time samples and nt/2 negative time samples. </span>
<span class="sd">            - The zero offset component is placed at the first index position of the second dimension, followed by nr/2-1 positive offset samples and nr/2 negative offset samples.</span>
<span class="sd">        - For evanescent waves, Kees makes a sign choice for the vertical-wavenumber,</span>
<span class="sd">        </span>
<span class="sd">        \t:math:`k_3=-j \sqrt{ k_1^2 - 2\gamma_1 k_1 \omega - (\\alpha \\beta_{11} -\gamma_1^2)  \omega^2}`.</span>
<span class="sd">        </span>
<span class="sd">        - By default, **NumPy** makes the oppostie sign choice, </span>
<span class="sd">        </span>
<span class="sd">        \t:math:`k_3=+j \sqrt{ k_1^2 - 2\gamma_1 k_1 \omega - (\\alpha \\beta_{11} -\gamma_1^2)\omega^2}`.</span>
<span class="sd">        </span>
<span class="sd">        - For convenience, we stick to **NumPy**&#39;s sign choice. Thus, we will also adapt the sign choice for the propagators,</span>
<span class="sd">              - Kees chose: :math:`\\tilde{w}^{\pm} = \mathrm{exp}(\pm \lambda^{\pm} \Delta x_3)`.</span>
<span class="sd">              - We choose: :math:`\\tilde{w}^{\pm} = \mathrm{exp}(\mp \lambda^{\pm} \Delta x_3)`.</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    Kees document as soon as it is published.</span>
<span class="sd">    </span>
<span class="sd">     </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # Initialise wavefield in a layered non-reciprocal medium</span>
<span class="sd">    &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,</span>
<span class="sd">    &gt;&gt;&gt;      x3vec=np.array([1.1,2.2,3.7]), avec=np.array([1,2,3])*1e-3, </span>
<span class="sd">    &gt;&gt;&gt;      b11vec=np.array([1.4,3.14,2])*1e-4, </span>
<span class="sd">    &gt;&gt;&gt;      b13vec=np.array([0.4,2.4,1.2])*1e-4,</span>
<span class="sd">    &gt;&gt;&gt;      b33vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">    &gt;&gt;&gt;      g1vec=np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">    &gt;&gt;&gt;      g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">    &gt;&gt;&gt;      ReciprocalMedium=False)</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # Get a meshgrid of the vertical-wavenumber</span>
<span class="sd">    &gt;&gt;&gt; F.K3.shape</span>
<span class="sd">    (513, 512, 3)</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # Get the vertical-wavenumber for omega=delta omega,  and k1=0</span>
<span class="sd">    &gt;&gt;&gt; F.K3[1,0,0]</span>
<span class="sd">    (0.00044855235013677386+0j)</span>
<span class="sd">    </span>
<span class="sd">    **Wavefield Quantities**</span>
<span class="sd">    (Do not change the table!)</span>
<span class="sd">    </span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    |                                        | *TE*                       | *TM*                   | *Ac. (meta)*                             | *Ac. (rotat)*                           | *SH (solid)*                       |</span>
<span class="sd">    +========================================+============================+========================+==========================================+=========================================+====================================+</span>
<span class="sd">    | **P**                                  | :math:`E_2`                | :math:`H_2`            | :math:`\sigma`                           | :math:`\sigma`                          | :math:`v_2`                        |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\mathbf{Q}_1`                   | :math:`H_3`                | :math:`-E_3`           | :math:`v_1`                              | :math:`v_1`                             | :math:`-\\tau_{21}`                 |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\mathbf{Q}_3`                   | :math:`-H_1`               | :math:`E_1`            | :math:`v_3`                              | :math:`v_3`                             | :math:`-\\tau_{23}`                 |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\\alpha}`            | :math:`\epsilon_{22}`      | :math:`\mu_{22}`       | :math:`\\frac{1}{K}`                      | :math:`\kappa`                          | :math:`\mathcal{R}_{22}`           |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\\beta}_{11}`        | :math:`\mu_{33}`           | :math:`\epsilon_{33}`  | :math:`\mathcal{R}_{11}`                 | :math:`\\rho`                            | :math:`4 s_{1221}`                 |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\\beta}_{13}`        | :math:`-\mu_{31}`          | :math:`-\epsilon_{31}` | :math:`\mathcal{R}_{13}`                 | :math:`\\frac{2\\rho\Omega_2}{j\omega}`   | :math:`4 s_{1223}`                 |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\\beta}_{31}`        | :math:`-\mu_{13}`          | :math:`-\epsilon_{13}` | :math:`\mathcal{R}_{31}`                 | :math:`-\\frac{2\\rho\Omega_2}{j\omega}`  | :math:`4 s_{3221}`                 |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\\beta}_{33}`        | :math:`\mu_{11}`           | :math:`\epsilon_{11}`  | :math:`\mathcal{R}_{33}`                 | :math:`\\rho`                            | :math:`4 s_{3223}`                 |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\gamma}_{1}`        |  :math:`\\xi_{23}`          | :math:`-\zeta_{23}`    | :math:`\\frac{\\theta_{mm1}}{3K}`          |                                         |  :math:`-2 \\xi_{221}`              |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\gamma}_{3}`        |  :math:`-\\xi_{21}`         | :math:`\zeta_{21}`     | :math:`\\frac{\\theta_{mm3}}{3K}`          |                                         |  :math:`-2 \\xi_{223}`              |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\\chi}_{1}`          |  :math:`\zeta_{32}`        | :math:`-\\xi_{32}`      | :math:`-\\frac{\eta_{1ll}}{3K}`           |                                         | :math:`-2 \zeta_{122}`             |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\\boldsymbol{\\chi}_{3}`          |  :math:`-\zeta_{12}`       | :math:`\\xi_{12}`       | :math:`-\\frac{\eta_{3ll}}{3K}`           |                                         | :math:`-2 \zeta_{322}`             |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | **B**                                  | :math:`-J_2^e`             | :math:`-J_2^m`         | :math:`q`                                | :math:`q`                               | :math:`f_2`                        |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\mathbf{C}_1`                   | :math:`-J_3^m`             | :math:`J_3^e`          | :math:`f_1`                              | :math:`f_1`                             | :math:`2h_{12}`                    |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    | :math:`\mathbf{C}_3`                   | :math:`J_1^m`              | :math:`-J_1^e`         | :math:`f_3`                              | :math:`f_3`                             | :math:`2h_{32}`                    |</span>
<span class="sd">    +----------------------------------------+----------------------------+------------------------+------------------------------------------+-----------------------------------------+------------------------------------+</span>
<span class="sd">    </span>

<span class="sd">   &quot;&quot;&quot;</span>    
  
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">nr</span><span class="p">,</span><span class="n">dx1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">avec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">b11vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">b13vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">b33vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">g1vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">g3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">ReciprocalMedium</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">AdjointMedium</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="c1"># Inherit __init__ from Wavefield_NRM_k1_w</span>
        <span class="n">Wavefield_NRM_k1_w</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">nr</span><span class="p">,</span><span class="n">dx1</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="n">eps</span><span class="p">)</span>
        
        <span class="c1"># Check if medium parameters are passed as arrays</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b11vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b13vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b33vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g1vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g3vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: x3vec, avec, b11vec, b13vec, b33vec, &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;g1vec and g3vec have to be of the type numpy.ndarray.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Set beta_{13}, gamma_1 and gamma_3 by default equal to zero</span>
        <span class="k">if</span> <span class="n">b13vec</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">b13vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">avec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g1vec</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">avec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g3vec</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">avec</span><span class="p">)</span>
            
        <span class="c1"># Force the medium parameters to have identical shape</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">avec</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">b11vec</span><span class="o">.</span><span class="n">shape</span> 
            <span class="ow">or</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">b13vec</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">b33vec</span><span class="o">.</span><span class="n">shape</span> 
            <span class="ow">or</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">g1vec</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">g3vec</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: x3vec, avec, b11vec, b13vec, b33vec, &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;g1vec and g3vec have to be of identical shape.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Force the medium parameters to be 1-dimensional, i.e. e.g. avec.shape=(n,)</span>
        <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: x3vec.ndim, avec.ndim, b11vec.ndim, &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;b13vec.ndim, b33vec.ndim, g1vec.ndim and g3vec.ndim &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;must be one.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if x3vec is positive and constantly increasing</span>
        <span class="k">if</span> <span class="n">x3vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">x3vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: x3vec must only contain constantly &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;increasing values greater than, or equal to zero.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if Medium choices are bools</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">ReciprocalMedium</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> 
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">AdjointMedium</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span>   <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: </span><span class="se">\&#39;</span><span class="s1">ReciprocalMedium</span><span class="se">\&#39;</span><span class="s1"> and &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">AdjointMedium</span><span class="se">\&#39;</span><span class="s1"> must be of the type bool.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if medium parameters correspond to a lossless (non-)reciprocal medium</span>
        <span class="k">if</span> <span class="n">ReciprocalMedium</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">avec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span>      <span class="ow">or</span> <span class="n">b11vec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> 
                <span class="ow">or</span> <span class="n">b13vec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">b33vec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> 
                <span class="ow">or</span> <span class="n">g1vec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span>  <span class="ow">or</span> <span class="n">g3vec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> <span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: In lossless non-reciprocal media &#39;</span>
                         <span class="s1">&#39;avec, b11vec, b13vec, b33vec, g1vec and g3vec have &#39;</span>
                         <span class="o">+</span><span class="s1">&#39;to be real-valued.&#39;</span><span class="p">)</span>
        <span class="c1"># The updated equations do not address reciprocal media. Therefore,</span>
        <span class="c1"># I am not making any assumptions about their real- and imaginary</span>
        <span class="c1"># parts before Kees confirms the missing expressions.</span>
        <span class="k">elif</span> <span class="n">ReciprocalMedium</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: This version (2.0) does not yet &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;include expressions for reciprocal media. To consider &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;reciprocal media set </span><span class="se">\&#39;</span><span class="s1">ReciprocalMedium=False</span><span class="se">\&#39;</span><span class="s1"> and &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">g1vec = 0</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">g3vec = 0</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
<span class="c1">#            if (avec.imag.any()!=0      or b11vec.imag.any()!=0 </span>
<span class="c1">#                or b13vec.imag.any()!=0 or b33vec.imag.any()!=0 </span>
<span class="c1">#                or g1vec.real.any()!=0  or g3vec.real.any()!=0 ):</span>
<span class="c1">#                sys.exit(&#39;Layered_NRM_k1_w: In lossless reciprocal media avec,&#39;</span>
<span class="c1">#                         +&#39; b11vec, b13vec and b33vec have to be real-valued, &#39;</span>
<span class="c1">#                         +&#39;g1vec and g3vec have to be only imaginary-valued.&#39;)</span>
            
        <span class="c1"># Set medium parameters </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span>  <span class="o">=</span> <span class="n">x3vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avec</span>   <span class="o">=</span> <span class="n">avec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span> <span class="o">=</span> <span class="n">b11vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b13vec</span> <span class="o">=</span> <span class="n">b13vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b31vec</span> <span class="o">=</span> <span class="n">b13vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b33vec</span> <span class="o">=</span> <span class="n">b33vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span>  <span class="o">=</span> <span class="n">g1vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span>  <span class="o">=</span> <span class="n">g3vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="o">=</span> <span class="n">ReciprocalMedium</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span>    <span class="o">=</span> <span class="n">AdjointMedium</span>
        
        <span class="c1"># Calculate vertical ray-parameter p3=p3(+p1) p3n=p3(-p1) </span>
        <span class="c1"># Note: By default python uses opposite sign convention for evanescent waves as Kees: (-1)**0.5=1j</span>
        <span class="n">K3</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">K3n</span> <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">W</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
        <span class="n">K1</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;K1gridfft&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">K3n</span> <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span>  <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span>
                    <span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span>
                    
            <span class="c1"># This is a manual fix to avoid exponential growth of the wavefield</span>
            <span class="c1"># I believe this fix sign-inverts epsilon for the unstable</span>
            <span class="c1"># w-k1 components. I am not sure if that is a problem. </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    
                    <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span>  <span class="o">=</span> <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>  <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
                    <span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
                    
        <span class="bp">self</span><span class="o">.</span><span class="n">K3</span>  <span class="o">=</span> <span class="n">K3</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K3n</span> <span class="o">=</span> <span class="n">K3n</span><span class="o">**</span><span class="mf">0.5</span>
        
    
<div class="viewcode-block" id="Layered_NRM_k1_w.FK1_mask_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.FK1_mask_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">FK1_mask_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">RelativeTaperLength</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="n">wmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">Opening</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a mask that mutes evanescent waves in the :math:`k_1`-</span>
<span class="sd">        :math:`\omega` domain.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            </span>
<span class="sd">        RelativeTaperLength : int, float, optional</span>
<span class="sd">            The product of \&#39;RelativeTaperLength\&#39; and the number of temporal </span>
<span class="sd">            samples \&#39;nt\&#39; determines the taper length. The default value is </span>
<span class="sd">            \&#39;RelativeTaperLength\&#39;:math:`=2^{-5}.`</span>
<span class="sd">            </span>
<span class="sd">        wmax : int, float, complex, optional</span>
<span class="sd">            Cut-off frequency :math:`\omega_{\mathrm{max}}` in :math:`s^{-1}`.</span>
<span class="sd">            </span>
<span class="sd">        Opening : int, float, optional</span>
<span class="sd">            Factor, greater than zero, to widen or tighten the :math:`\omega`-</span>
<span class="sd">            :math:`k_1` mask. If equal to one, the opening corresponds to the </span>
<span class="sd">            transition from propagating to evanescent waves. </span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary that contains the ,</span>
<span class="sd">                - **FK**: Sharp-edged :math:`\omega`-:math:`k_1` mask, mutes </span>
<span class="sd">                the evanescent wavefield in each layer indivually. Shape </span>
<span class="sd">                (nf,nr,n).</span>
<span class="sd">                </span>
<span class="sd">                - **FK_global**: Sharp-edged :math:`\omega`-:math:`k_1` mask, </span>
<span class="sd">                mutes the evanescent wavefield in the entire model. Shape </span>
<span class="sd">                (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">                - **FK_tap**: Tapered :math:`\omega`-:math:`k_1` mask, mutes </span>
<span class="sd">                the evanescent wavefield in each layer indivually. Shape </span>
<span class="sd">                (nf,nr,n).</span>
<span class="sd">                </span>
<span class="sd">                - **FK_global_tap**: Tapered :math:`\omega`-:math:`k_1` mask, </span>
<span class="sd">                mutes the evanescent wavefield in the entire model. Shape </span>
<span class="sd">                (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">                - **FKn**: Sharp-edged :math:`\omega`-:math:`k_1` mask, mutes </span>
<span class="sd">                the evanescent wavefield in each layer indivually (for sign-</span>
<span class="sd">                inverted :math:`k_1`). Shape (nf,nr,n).</span>
<span class="sd">                </span>
<span class="sd">                - **FKn_global**: Sharp-edged :math:`\omega`-:math:`k_1` mask, </span>
<span class="sd">                mutes the evanescent wavefield in the entire model (for sign-</span>
<span class="sd">                inverted :math:`k_1`). Shape (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">                - **FKn_tap**: Tapered :math:`\omega`-:math:`k_1` mask, mutes </span>
<span class="sd">                the evanescent wavefield in each layer indivually (for sign-</span>
<span class="sd">                inverted :math:`k_1`). Shape (nf,nr,n).</span>
<span class="sd">                </span>
<span class="sd">                - **FKn_global_tap**: Tapered :math:`\omega`-:math:`k_1` mask,</span>
<span class="sd">                mutes the evanescent wavefield in the entire model (for sign-</span>
<span class="sd">                inverted :math:`k_1`). Shape (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">                - **taperlen**: Taper length in number of samples.</span>
<span class="sd">                </span>
<span class="sd">            All masks are stored as complex valued arrays because they will be </span>
<span class="sd">            applied to complex-valued arrays.</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">                 avec=np.array([1,2,3])*1e-3,b11vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">                 b13vec=np.array([0.4,2.4,1.2])*1e-4,b33vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">                 g1vec=np.array([0.8,2,1.3])*1e-4,g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">                 ReciprocalMedium=False)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Create fk mask with a cut-off frequency at 200 1/s</span>
<span class="sd">        &gt;&gt;&gt; Mask=F.FK1_mask_k1_w(wmax=200)</span>
<span class="sd">        &gt;&gt;&gt; Tapered_fk_mask = Mask[&#39;FK_tap&#39;]</span>
<span class="sd">        </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if RelativeTaperLength is a float or an int</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">RelativeTaperLength</span><span class="se">\&#39;</span><span class="s1"> must be of the &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;type int or float.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check that RelativeTaperLength is not smaller than zero</span>
        <span class="k">if</span> <span class="n">RelativeTaperLength</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">RelativeTaperLength</span><span class="se">\&#39;</span><span class="s1"> must be greater &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;than, or equal to zero.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check if wmax is a float or an int or a complex</span>
        <span class="k">if</span> <span class="n">wmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wmax</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
                  <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wmax</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> 
                  <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wmax</span><span class="p">,</span><span class="nb">complex</span><span class="p">)):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">wmax</span><span class="se">\&#39;</span><span class="s1"> must be of the type int, &#39;</span>
                         <span class="o">+</span><span class="s1">&#39;float or complex.&#39;</span><span class="p">)</span>
       
            <span class="c1"># Check that wmax is not smaller than zero</span>
            <span class="k">if</span> <span class="n">wmax</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">wmax</span><span class="se">\&#39;</span><span class="s1"> must be greater than, or &#39;</span>
                         <span class="o">+</span><span class="s1">&#39;equal to zero.&#39;</span><span class="p">)</span>
                
        <span class="c1"># Check if Opening is a scalar</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Opening</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Opening</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">Opening</span><span class="se">\&#39;</span><span class="s1"> must be of the &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;type int or float.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check that Opening is not smaller than zero</span>
        <span class="k">if</span> <span class="n">Opening</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">Opening</span><span class="se">\&#39;</span><span class="s1"> must be greater &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;than, or equal to zero.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Help variable (k3 squared)</span>
        <span class="n">Q</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">Qn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            
        <span class="c1"># Sharp-edged FK mask</span>
        <span class="n">FK</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">FKn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Frequency and wavenumber meshgrid</span>
        <span class="n">W</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;K1gridfft&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bvec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">Q</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">Opening</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">Qn</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">Q</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span> <span class="n">Opening</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> 
                                 <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
                <span class="n">Qn</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">Opening</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> 
                                 <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
                    
        <span class="n">FK</span><span class="p">[</span><span class="n">Q</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">FKn</span><span class="p">[</span><span class="n">Qn</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">FK_global</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">FK</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">FKn_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">FKn</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">FK_tap</span>         <span class="o">=</span> <span class="n">FK</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">FKn_tap</span>        <span class="o">=</span> <span class="n">FKn</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">FK_global_tap</span>  <span class="o">=</span> <span class="n">FK_global</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">FKn_global_tap</span> <span class="o">=</span> <span class="n">FKn_global</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Taper length</span>
        <span class="n">taperlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">taperlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Define sine taper</span>
            <span class="c1"># If complex-valued frequencies are used they must be included in</span>
            <span class="c1"># the taper. Otherwise the amplitudes are falsified.</span>
            <span class="n">w</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wvec</span><span class="p">()[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">def</span> <span class="nf">SineTaper</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
                <span class="n">w0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                <span class="n">tap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">taperlen</span><span class="p">]</span><span class="o">-</span><span class="n">w0</span><span class="p">)</span>
                              <span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">taperlen</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="p">)</span>
                              <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">tap</span><span class="o">**</span><span class="mi">2</span>
                        
            <span class="c1"># Define taper for each wavenumber</span>
            <span class="k">for</span> <span class="n">WavNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">):</span>
                
                <span class="c1"># FK_global</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FK_global</span><span class="p">[:,</span><span class="n">WavNum</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i1</span>  <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
                
                    <span class="k">if</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">taperlen</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">:</span>
                        <span class="n">FK_global_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="n">taperlen</span><span class="p">,</span><span class="n">WavNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                      
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">FK_global_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:,</span><span class="n">WavNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="n">i1</span><span class="p">]</span>
                   
                <span class="c1"># FKn_global</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FKn_global</span><span class="p">[:,</span><span class="n">WavNum</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i1</span>  <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
                
                    <span class="k">if</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">taperlen</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">:</span>
                        <span class="n">FKn_global_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="n">taperlen</span><span class="p">,</span><span class="n">WavNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                       
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">FKn_global_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:,</span><span class="n">WavNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="n">i1</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="c1"># FK</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FK</span><span class="p">[:,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">i1</span>  <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
                    
                        <span class="k">if</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">taperlen</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">:</span>
                            <span class="n">FK_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="n">taperlen</span><span class="p">,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                        
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">FK_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="n">i1</span><span class="p">]</span>
                            
                    <span class="c1"># FKn</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FKn</span><span class="p">[:,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">i1</span>  <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
                    
                        <span class="k">if</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">taperlen</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">:</span>
                            <span class="n">FKn_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="n">taperlen</span><span class="p">,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                        
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">FKn_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="n">i1</span><span class="p">]</span>
        
        <span class="c1"># Mask to cut-off frequencies greater than wmax</span>
        <span class="k">if</span> <span class="n">wmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">wmax</span><span class="o">.</span><span class="n">real</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()))</span>
            
            <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">M</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">M</span><span class="p">[</span><span class="n">ind</span><span class="p">:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">FK</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">FK</span>         <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">FK</span>
                <span class="n">FK_global</span>  <span class="o">=</span> <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">FK_global</span>
                <span class="n">FKn</span>        <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">FKn</span>
                <span class="n">FKn_global</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">FKn_global</span>
                
                <span class="k">if</span> <span class="n">taperlen</span> <span class="o">&lt;</span> <span class="n">ind</span><span class="p">:</span>
                    <span class="n">M</span><span class="p">[</span><span class="n">ind</span><span class="o">-</span><span class="n">taperlen</span><span class="p">:</span><span class="n">ind</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">ind</span><span class="o">-</span><span class="n">taperlen</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>
                    <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">M</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">FK</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">M</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">M</span><span class="p">[:,:,:</span><span class="mi">1</span><span class="p">],</span><span class="n">FK</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">FK_tap</span>         <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">FK_tap</span>
                <span class="n">FK_global_tap</span>  <span class="o">=</span> <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">FK_global_tap</span>
                <span class="n">FKn_tap</span>        <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">FKn_tap</span>
                <span class="n">FKn_global_tap</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">FKn_global_tap</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">FK</span>        <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FK</span>
                <span class="n">FK_global</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FK_global</span>
                <span class="n">FK_tap</span>        <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FK_tap</span>
                <span class="n">FK_global_tap</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FK_global_tap</span>
                
                <span class="n">FKn</span>        <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FKn</span>
                <span class="n">FKn_global</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FKn_global</span>
                <span class="n">FKn_tap</span>        <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FKn_tap</span>
                <span class="n">FKn_global_tap</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FKn_global_tap</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;FK&#39;</span><span class="p">:</span><span class="n">FK</span><span class="p">,</span><span class="s1">&#39;FK_global&#39;</span><span class="p">:</span><span class="n">FK_global</span><span class="p">,</span><span class="s1">&#39;FK_tap&#39;</span><span class="p">:</span><span class="n">FK_tap</span><span class="p">,</span>
               <span class="s1">&#39;FK_global_tap&#39;</span><span class="p">:</span><span class="n">FK_global_tap</span><span class="p">,</span>
               <span class="s1">&#39;FKn&#39;</span><span class="p">:</span><span class="n">FKn</span><span class="p">,</span><span class="s1">&#39;FKn_global&#39;</span><span class="p">:</span><span class="n">FKn_global</span><span class="p">,</span><span class="s1">&#39;FKn_tap&#39;</span><span class="p">:</span><span class="n">FKn_tap</span><span class="p">,</span>
               <span class="s1">&#39;FKn_global_tap&#39;</span><span class="p">:</span><span class="n">FKn_global_tap</span><span class="p">,</span><span class="s1">&#39;taperlen&#39;</span><span class="p">:</span><span class="n">taperlen</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
        
<div class="viewcode-block" id="Layered_NRM_k1_w.Eigenvalues_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.Eigenvalues_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">Eigenvalues_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the eigenvalues :math:`\lambda^{\pm}` of the two-way </span>
<span class="sd">        operator matrix :math:`\\rm{\\bf A}` in the wavenumber-frequency </span>
<span class="sd">        domain.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">            </span>
<span class="sd">                - **LP**: The eigenvalue :math:`\lambda^{+}`.</span>
<span class="sd">                - **LM**: The eigenvalue :math:`\lambda^{-}`.</span>
<span class="sd">                - **LPn**: The eigenvalue :math:`\lambda^{+}` with sign-inverted horizontal-wavenumbers :math:`k_1`. </span>
<span class="sd">                - **LMn**: The eigenvalue :math:`\lambda^{-}` with sign-inverted horizontal-wavenumbers :math:`k_1`.   </span>
<span class="sd">                </span>
<span class="sd">            All eigenvalue matrices are stored in a in a (nf,nr,n)-array. The </span>
<span class="sd">            dimensions correspond to the temporal frequencies :math:`\omega`, </span>
<span class="sd">            the horizontal-wavenumbers :math:`k_1` and to the layers of the </span>
<span class="sd">            medium.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        .. todo::</span>
<span class="sd">            </span>
<span class="sd">            (1) Check if the eigenvalues have to be modified for reciprocal </span>
<span class="sd">            media.</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">            (2) Check if :math:`\\beta_{11} \\beta_{33} - \\beta_{13}^2 \geq 0` </span>
<span class="sd">            holds in general.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            - The eigenvalues are associated with non-reciprocal media.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">                 avec=np.array([1,2,3])*1e-3,b11vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">                 b13vec=np.array([0.4,2.4,1.2])*1e-4,b33vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">                 g1vec=np.array([0.8,2,1.3])*1e-4,g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">                 ReciprocalMedium=False)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Compute the eigenvalue lambda_plus</span>
<span class="sd">        &gt;&gt;&gt; Lam = F.Eigenvalues_k1_w()</span>
<span class="sd">        &gt;&gt;&gt; lP = Lam[&quot;LP&quot;]</span>
<span class="sd">        &gt;&gt;&gt; lP[1,0,0]  # Evaluate for k1=0 and \omega = \Delta \omega</span>
<span class="sd">        0.0006226976760655292j</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Frequency and horizontal-wavenumber meshgrids</span>
        <span class="n">Om</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;K1gridfft&#39;</span><span class="p">]</span>
        
        <span class="c1"># Eigenvalues for adjoint medium</span>
        <span class="n">LPn</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">LMn</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            
            <span class="n">LP</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">LM</span> <span class="o">=</span> <span class="n">LP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                
                <span class="n">tmp1</span> <span class="o">=</span> <span class="p">(</span> <span class="n">K1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> 
                         <span class="o">+</span> <span class="n">Om</span><span class="o">*</span><span class="p">(</span>  <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> 
                               <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> 
                        
                <span class="n">tmp2</span> <span class="o">=</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>  <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b33vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> 
                                 <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span> 
                        <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span> <span class="p">)</span>
                
                <span class="n">LP</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">+</span> <span class="n">tmp2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span>
                <span class="n">LM</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">-</span> <span class="n">tmp2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span>
                    
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">LPn</span> <span class="o">=</span> <span class="n">LP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">LMn</span> <span class="o">=</span> <span class="n">LP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                
                    <span class="n">tmp1</span> <span class="o">=</span> <span class="p">(</span> <span class="o">-</span><span class="n">K1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> 
                              <span class="o">+</span> <span class="n">Om</span><span class="o">*</span><span class="p">(</span>  <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> 
                                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> 
                            
                    <span class="n">tmp2</span> <span class="o">=</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>  <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">b33vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> 
                                     <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">b13vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span> 
                            <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span> <span class="p">)</span>
                    
                    <span class="n">LPn</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">+</span> <span class="n">tmp2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span>
                    <span class="n">LMn</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">-</span> <span class="n">tmp2</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">b11vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span>
                
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Eigenvalues_k1_w (ReciprocalMedium is False)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;---------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For non-reciprocal media, we compute the eigenvalues &#39;</span>
                      <span class="o">+</span><span class="s1">&#39;under the assumption that (b11*b33 - b13**2) is &#39;</span>
                      <span class="o">+</span><span class="s1">&#39;greater than, or equal to zero.&#39;</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            
            <span class="c1">#####################</span>
            <span class="c1"># NOT YET IMPLEMENTED</span>
            <span class="c1">#####################</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Eigenvalues_k1_w (ReciprocalMedium is True)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For reciprocal media, the eigenvalues are not yet &#39;</span>
                      <span class="o">+</span><span class="s1">&#39;implemented.&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;LP&quot;</span><span class="p">:</span><span class="n">LP</span><span class="p">,</span><span class="s2">&quot;LM&quot;</span><span class="p">:</span><span class="n">LM</span><span class="p">,</span><span class="s2">&quot;LPn&quot;</span><span class="p">:</span><span class="n">LPn</span><span class="p">,</span><span class="s2">&quot;LMn&quot;</span><span class="p">:</span><span class="n">LMn</span><span class="p">}</span></div>
    
    
<div class="viewcode-block" id="Layered_NRM_k1_w.L_eigenvectors_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.L_eigenvectors_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">L_eigenvectors_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">beta11</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">beta13</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">beta33</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">K3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the eigenvector matrix &#39;L&#39; and its inverse &#39;Linv&#39;, either </span>
<span class="sd">        in flux- or in pressure-normalisation for the vertical-wavenumber &#39;K3&#39; </span>
<span class="sd">        inside a homogeneous layer. Here, the vertical-wavenumber is a meshgrid </span>
<span class="sd">        that contains all combinations of frequencies :math:`\omega` and </span>
<span class="sd">        horizontal-wavenumbers :math:`k_1`. If \&#39;AdjointMedium=True\&#39;, </span>
<span class="sd">        **L_eigenvectors_k1_w** also computes the eigenvector matrix in the </span>
<span class="sd">        adjoint medium &#39;La&#39; and its inverse &#39;Lainv&#39;. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        beta11 : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{11}`  (real-valued).</span>
<span class="sd">        </span>
<span class="sd">        beta13 : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{13}`  (real-valued).</span>
<span class="sd">            </span>
<span class="sd">        beta33 : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{33}`  (real-valued).</span>
<span class="sd">        </span>
<span class="sd">        K3 : numpy.ndarray</span>
<span class="sd">            Vertical-wavenumber :math:`k_3(+k_1)` for all frequencies </span>
<span class="sd">            :math:`\omega` and horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">        </span>
<span class="sd">        K3n : numpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Vertical-wavenumber :math:`k_3(-k_1)` for all frequencies </span>
<span class="sd">            :math:`\omega` and sign-inverted horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for </span>
<span class="sd">            flux-normalisation set normalisation=&#39;flux&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">            </span>
<span class="sd">                - **L**: The eigenvector matrix.</span>
<span class="sd">                - **Linv**: The inverse of the eigenvector matrix.</span>
<span class="sd">                - **La**: The eigenvector matrix (adjoint medium).</span>
<span class="sd">                - **Lainv**: The inverse of the eigenvector matrix (adjoint medium).</span>
<span class="sd">                </span>
<span class="sd">            All eigenvector matrices are stored in a in a (nf,nr,2,2)-array. </span>
<span class="sd">            The first two dimensions correspond to all combinations of </span>
<span class="sd">            frequencies :math:`\omega` and horizontal-wavenumbers :math:`k_1`. </span>
<span class="sd">            The last two dimension are the actual eigenvector matrices for all </span>
<span class="sd">            :math:`\omega`-:math:`k_1` components.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            </span>
<span class="sd">        - The eigenvector matrix &#39;L&#39; and its inverse &#39;Linv&#39; are different for reciprocal and non-reciprocal media (I assume that has not changed, but check it!).</span>
<span class="sd">        - For reciprocal media, the eigenvectors of the adjoint medium are identical to the eigenvectors of the true medium (verify!).</span>
<span class="sd">        - We have defined the eigenvectors of the adjoint medium only for flux-normalisation.</span>
<span class="sd">        - At zero frequency (:math:`\omega=0 \;\mathrm{s}^{-1}`), the eigenvector matrices \&#39;L\&#39; and their inverse \&#39;Linv\&#39; contain elements with poles. For computational convenience, we set the poles equal to zero. However, the resulting zero frequency component of all outputs is meaningless.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise wavefield in a layered non-reciprocal medium</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">        &gt;&gt;&gt;      avec=np.array([1,2,3])*1e-3,b11vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      b13vec=np.array([0.4,2.4,1.2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      b33vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g1vec=np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      ReciprocalMedium=False,AdjointMedium=True)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Compute eigenvectors in pressure-normalisation</span>
<span class="sd">        &gt;&gt;&gt; Leig=F.L_eigenvectors_k1_w(beta11=F.b11vec[0],beta13=F.b13vec[0],</span>
<span class="sd">        &gt;&gt;&gt;                            beta33=F.b33vec[0],K3=F.K3[:,:,0],</span>
<span class="sd">        &gt;&gt;&gt;                            K3n=F.K3n[:,:,0],</span>
<span class="sd">        &gt;&gt;&gt;                            normalisation=&#39;pressure&#39;)</span>
<span class="sd">        &gt;&gt;&gt; L=Leig[&#39;L&#39;]</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # For pressure normalisation, the top-left element of L equals</span>
<span class="sd">        &gt;&gt;&gt; # 1 for all frequencies and all horizontal-wavenumbers</span>
<span class="sd">        &gt;&gt;&gt; L[101,200,0,0]</span>
<span class="sd">        (1+0j)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # For pressure normalisation, the bottom-left element of L does not</span>
<span class="sd">        &gt;&gt;&gt; # equal 1 for all frequencies and all horizontal-wavenumbers</span>
<span class="sd">        &gt;&gt;&gt; L[101,200,1,0]</span>
<span class="sd">        10.85892500293106j</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if required input variables are given</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">beta11</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">beta13</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">beta33</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> 
             <span class="ow">or</span> <span class="p">(</span><span class="n">K3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;L_eigenvectors_k1_w: The input variables </span><span class="se">\&#39;</span><span class="s1">beta11</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">beta13</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">beta33</span><span class="se">\&#39;</span><span class="s1"> and  </span><span class="se">\&#39;</span><span class="s1">K3</span><span class="se">\&#39;</span><span class="s1"> must be set.&#39;</span><span class="p">)</span>
         
        <span class="c1"># Check if normalisation is set correctly</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;L_eigenvectors_k1_w: The input variable &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">normalisation</span><span class="se">\&#39;</span><span class="s1"> must be set, either to </span><span class="se">\&#39;</span><span class="s1">flux</span><span class="se">\&#39;</span><span class="s1">, or &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;to </span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check if the vertical-wavenumber for a negative horizontal-wavenumber </span>
        <span class="c1"># is given</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">K3n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> 
          <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;L_eigenvectors_k1_w: The input variable </span><span class="se">\&#39;</span><span class="s1">K3n</span><span class="se">\&#39;</span><span class="s1"> &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;(vertical-wavenumber K3 for a negative horizontal-&#39;</span>
                     <span class="o">+</span><span class="s1">&#39;wavenumber k1) must be given to compute the eigenvector&#39;</span>
                     <span class="o">+</span><span class="s1">&#39; matrix of the adjoint medium </span><span class="se">\&#39;</span><span class="s1">La</span><span class="se">\&#39;</span><span class="s1"> and its inverse &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">Lainv</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Initialise L and Linv</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">Linv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">La</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Lainv</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Construct a vertical ray-parameter</span>
        <span class="c1"># Exclude poles at zero-frequency</span>
        <span class="n">Om</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
        <span class="n">P3</span>           <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">P3</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>     <span class="o">=</span> <span class="n">K3</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">/</span><span class="n">Om</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
        <span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>      <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Construct an inverse vertical ray-parameter</span>
        <span class="c1"># Exclude pole at zero frequency and zero horizontal-wavenumber</span>
        <span class="c1"># K3[0,0] = 0</span>
        <span class="c1"># P3[0,:] = 0</span>
        <span class="n">P3inv</span> <span class="o">=</span> <span class="n">P3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">P3inv</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">Om</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">/</span><span class="n">K3</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
        
        <span class="n">hinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">beta11</span><span class="o">*</span><span class="n">beta33</span><span class="o">-</span><span class="n">beta13</span><span class="o">*</span><span class="n">beta13</span> <span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="mi">72</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The eigenvectors L and their inverse Linv have a pole at &#39;</span>
                  <span class="o">+</span><span class="s1">&#39;zero frequency. Here, we set the zero frequency component &#39;</span>
                  <span class="o">+</span><span class="s1">&#39;of L and Linv to zero (which is wrong but convenient for &#39;</span>
                  <span class="o">+</span><span class="s1">&#39;the computation).</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">):</span>
            
            <span class="c1">#####################</span>
            <span class="c1"># NOT YET IMPLEMENTED</span>
            <span class="c1">#####################</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w (ReciprocalMedium is True)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For reciprocal media, the eigenvectors are not yet &#39;</span>
                      <span class="o">+</span><span class="s1">&#39;implemented.&#39;</span><span class="p">)</span>
            
<span class="c1">#            # L matrix</span>
<span class="c1">#            fac = (beta*P3inv/2)**0.5</span>
<span class="c1">#            L[:,:,0,0] = 1*fac</span>
<span class="c1">#            L[:,:,0,1] = 1*fac</span>
<span class="c1">#            L[:,:,1,0] = (P3+g3)/beta*fac</span>
<span class="c1">#            L[:,:,1,1] = -(P3-g3)/beta*fac</span>
<span class="c1">#            </span>
<span class="c1">#            # Inverse L matrix</span>
<span class="c1">#            Linv[:,:,0,0] = -L[:,:,1,1]</span>
<span class="c1">#            Linv[:,:,0,1] =  L[:,:,0,0]</span>
<span class="c1">#            Linv[:,:,1,0] =  L[:,:,1,0]</span>
<span class="c1">#            Linv[:,:,1,1] = -L[:,:,0,0]</span>
<span class="c1">#            </span>
<span class="c1">#            if self.AdjointMedium is True:</span>
<span class="c1">#                if self.verbose is True:</span>
<span class="c1">#                    print(&#39;\nL_eigenvectors_k1_w (AdjointMedium is True) and (ReciprocalMedium is True)&#39;)</span>
<span class="c1">#                    print(&#39;-------------------------------------------------------------------------------&#39;)</span>
<span class="c1">#                    print(&#39;For reciprocal media, the eigenvector matrix of a medium and its adjoint medium &#39;)</span>
<span class="c1">#                    print(&#39;are identical.\n&#39;)</span>
<span class="c1">#               </span>
<span class="c1">#                La = L.copy()</span>
<span class="c1">#                Lainv = Linv.copy()</span>
<span class="c1">#            </span>
<span class="c1">#        elif (self.ReciprocalMedium is True) and (normalisation is &#39;pressure&#39;):            </span>
<span class="c1">#            # L matrix</span>
<span class="c1">#            L[:,:,0,0] = 1</span>
<span class="c1">#            L[:,:,0,1] = 1</span>
<span class="c1">#            L[:,:,1,0] = (P3+g3)/beta</span>
<span class="c1">#            L[:,:,1,1] = -(P3-g3)/beta</span>
<span class="c1">#            </span>
<span class="c1">#            # Inverse L matrix</span>
<span class="c1">#            fac = beta*P3inv/2</span>
<span class="c1">#            Linv[:,:,0,0] = -L[:,:,1,1]*fac</span>
<span class="c1">#            Linv[:,:,0,1] = 1*fac</span>
<span class="c1">#            Linv[:,:,1,0] = L[:,:,1,0]*fac</span>
<span class="c1">#            Linv[:,:,1,1] = -1*fac</span>
<span class="c1">#            </span>
<span class="c1">#            if self.verbose is True and self.AdjointMedium is True:</span>
<span class="c1">#                print(&#39;\nL_eigenvectors_k1_w (AdjointMedium is True) and (normalisation=\&#39;pressure\&#39;)&#39;)</span>
<span class="c1">#                print(&#39;-------------------------------------------------------------------------------&#39;)</span>
<span class="c1">#                print(&#39;We have defined the eigenvector matrix of the adjoint medium \&#39;La\&#39; and its &#39;)</span>
<span class="c1">#                print(&#39;inverse \&#39;Lainv\&#39; only for flux-normalisation.\n&#39;)</span>
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">):</span>
            <span class="c1"># L matrix</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">hinv</span><span class="o">*</span><span class="n">P3inv</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P3</span><span class="o">/</span><span class="n">hinv</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
            
            <span class="c1"># Inverse L matrix</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w (AdjointMedium is True) and (ReciprocalMedium is False)&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For non-reciprocal media, the eigenvector matrix of a medium and its adjoint &#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;medium are different.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    
                <span class="c1"># Construct a vertical ray-parameter  for sign-inverted </span>
                <span class="c1"># horizontal-wavenumbers</span>
                <span class="c1"># Exclude poles at zero-frequency</span>
                <span class="n">Om</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
                <span class="n">P3n</span>           <span class="o">=</span> <span class="n">K3n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">P3n</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>     <span class="o">=</span> <span class="n">K3n</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">/</span><span class="n">Om</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
                <span class="n">P3n</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>      <span class="o">=</span> <span class="mi">0</span>
                
                <span class="c1"># Construct an inverse vertical ray-parameter  for sign-inverted </span>
                <span class="c1"># horizontal-wavenumbers</span>
                <span class="c1"># Exclude pole at zero frequency and zero horizontal-wavenumber</span>
                <span class="c1"># K3[0,0] = 0</span>
                <span class="c1"># P3[0,:] = 0</span>
                <span class="n">P3ninv</span> <span class="o">=</span> <span class="n">P3n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">P3ninv</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">Om</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">/</span><span class="n">K3n</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
                
                <span class="c1"># L matrix (adjoint medium) = N Transpose( Inverse( L(-k1) )) N</span>
                <span class="n">La</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">La</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">hinv</span><span class="o">*</span><span class="n">P3ninv</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="n">La</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">La</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">La</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P3n</span><span class="o">/</span><span class="n">hinv</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="n">La</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">La</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">La</span> <span class="o">=</span> <span class="n">La</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
                
                <span class="c1">#  Inverse L matrix (adjoint medium) = N Transpose( L(-k1)) N</span>
                <span class="n">Lainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">La</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">La</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">La</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">La</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="c1"># L matrix</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">P3</span><span class="o">/</span><span class="n">hinv</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Inverse L matrix</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hinv</span><span class="o">*</span><span class="n">P3inv</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">hinv</span><span class="o">*</span><span class="n">P3inv</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Linv</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w (AdjointMedium is True) and (normalisation=</span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We have defined the eigenvector matrix of the adjoint medium </span><span class="se">\&#39;</span><span class="s1">La</span><span class="se">\&#39;</span><span class="s1"> and its &#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inverse </span><span class="se">\&#39;</span><span class="s1">Lainv</span><span class="se">\&#39;</span><span class="s1"> only for flux-normalisation.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="n">L</span><span class="p">,</span><span class="s1">&#39;Linv&#39;</span><span class="p">:</span><span class="n">Linv</span><span class="p">,</span><span class="s1">&#39;La&#39;</span><span class="p">:</span><span class="n">La</span><span class="p">,</span><span class="s1">&#39;Lainv&#39;</span><span class="p">:</span><span class="n">Lainv</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
          
<div class="viewcode-block" id="Layered_NRM_k1_w.RT_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.RT_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">RT_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">beta11_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">beta13_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">beta33_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3n_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">beta11_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">beta13_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">beta33_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3n_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the scattering coefficients at an horizontal interface.</span>
<span class="sd">        </span>
<span class="sd">        The scattering coefficients can be computed either in flux- or in </span>
<span class="sd">        pressure-normalisation. The variables with subscript &#39;u&#39; refer to the </span>
<span class="sd">        medium parameters in the upper half-space, the variables with subscript </span>
<span class="sd">        &#39;l&#39; refer to the medium parameters in the lower half-space. The </span>
<span class="sd">        vertical-wavenumbers \&#39;K3\&#39;:math:`=k_3(k_1,\omega)` and </span>
<span class="sd">        \&#39;K3n\&#39;:math:`=k_3(-k_1,\omega)` are stored as :math:`k_1`-</span>
<span class="sd">        :math:`\omega` meshgirds to compute the scattering coefficients for all </span>
<span class="sd">        sampled frequencies and horizontal-wavenumbers in a vectorsied manner. </span>
<span class="sd">        Set \&#39;AdjointMedium=True\&#39; to compute the scattering coefficients also </span>
<span class="sd">        in the adjoint medium.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        beta11_u : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{11}` (real-valued) (upper half-space).</span>
<span class="sd">        </span>
<span class="sd">        beta13_u : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{13}` (real-valued) (upper half-space).</span>
<span class="sd">            </span>
<span class="sd">        beta33_u : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{33}` (real-valued) (upper half-space).</span>
<span class="sd">        </span>
<span class="sd">        K3_u : numpy.ndarray</span>
<span class="sd">            Vertical-wavenumber :math:`k_{3,u}(+k_1)` for all frequencies </span>
<span class="sd">            :math:`\omega` and horizontal-wavenumbers :math:`k_1` (upper half-</span>
<span class="sd">            space).</span>
<span class="sd">        </span>
<span class="sd">        K3n_u : numpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Vertical-wavenumber :math:`k_{3,u}(-k_1)` for all frequencies </span>
<span class="sd">            :math:`\omega` and sign-inverted horizontal-wavenumbers :math:`k_1` </span>
<span class="sd">            (upper half-space).</span>
<span class="sd">            </span>
<span class="sd">        beta11_l : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{11}` (real-valued) (lower half-space).</span>
<span class="sd">        </span>
<span class="sd">        beta13_l : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{13}` (real-valued) (lower half-space).</span>
<span class="sd">            </span>
<span class="sd">        beta33_l : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta_{33}` (real-valued) (lower half-space).</span>
<span class="sd">        </span>
<span class="sd">        K3_l : numpy.ndarray</span>
<span class="sd">            Vertical-wavenumber :math:`k_{3,l}(+k_1)` for all frequencies </span>
<span class="sd">            :math:`\omega` and horizontal-wavenumbers :math:`k_1` (lower half-</span>
<span class="sd">            space).</span>
<span class="sd">        </span>
<span class="sd">        K3n_l : numpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Vertical-wavenumber :math:`k_{3,l}(-k_1)` for all frequencies </span>
<span class="sd">            :math:`\omega` and sign-inverted horizontal-wavenumbers :math:`k_1` </span>
<span class="sd">            (lower half-space).</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for flux-</span>
<span class="sd">            normalisation set normalisation=&#39;flux&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">            </span>
<span class="sd">                - **rP**: Reflection coefficient from above.</span>
<span class="sd">                - **tP**: Transmission coefficient from above.</span>
<span class="sd">                - **rM**: Reflection coefficient from below.</span>
<span class="sd">                - **tM**: Transmission coefficient from below.</span>
<span class="sd">                - **rPa**: Reflection coefficient from above (adjoint medium).</span>
<span class="sd">                - **tPa**: Transmission coefficient from above (adjoint medium).</span>
<span class="sd">                - **rMa**: Reflection coefficient from below (adjoint medium).</span>
<span class="sd">                - **tMa**: Transmission coefficient from below (adjoint medium).</span>
<span class="sd">                </span>
<span class="sd">            All scattering coefficients are stored as arrays with the shape </span>
<span class="sd">            (nf,nr).</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        .. todo::</span>
<span class="sd">            </span>
<span class="sd">            (1) For :math:`(k_1 , \omega) = (0,0)` there is a zero division in the </span>
<span class="sd">            computation of the scattering coefficients. I have fixed that, however, I believe that the fix is (mathmatically) wrong. Check that!</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">    </span>
<span class="sd">        - For reciprocal media, the scattering coefficients of the adjoint medium are identical to the scattering coefficients of the true medium. (To be checked)</span>
<span class="sd">        - We have defined the scattering coefficients of the adjoint medium only for flux-normalisation.</span>
<span class="sd">        </span>
<span class="sd">            </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        Kees document as soon as it is published.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">    </span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise wavefield F in a reciprocal medium </span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">        &gt;&gt;&gt;      avec=np.array([1,2,3])*1e-3,b11vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      b13vec=np.array([0.4,2.4,1.2])*1e-4,b33vec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g1vec=np.array([0.8,2,1.3])*1e-4,g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      ReciprocalMedium=False,AdjointMedium=True)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Compute scattering coefficients at the first interface in flux</span>
<span class="sd">        &gt;&gt;&gt; # normalisation</span>
<span class="sd">        &gt;&gt;&gt; Scat = F.RT_k1_w(beta11_u=F.b11vec[0],beta13_u=F.b13vec[0],beta33_u=F.b33vec[0],</span>
<span class="sd">        &gt;&gt;&gt;                  K3_u=F.K3[:,:,0],K3n_u=F.K3n[:,:,0],</span>
<span class="sd">        &gt;&gt;&gt;                  beta11_l=F.b11vec[1],beta13_l=F.b13vec[1],beta33_l=F.b33vec[1],</span>
<span class="sd">        &gt;&gt;&gt;                  K3_l=F.K3[:,:,1],K3n_l=F.K3n[:,:,1],normalisation=&#39;flux&#39;)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Read the scattering coeffcients, and </span>
<span class="sd">        &gt;&gt;&gt; tP = Scat[&#39;tP&#39;]</span>
<span class="sd">        &gt;&gt;&gt; rM = Scat[&#39;rM&#39;]</span>
<span class="sd">        &gt;&gt;&gt; rP = Scat[&#39;rP&#39;]</span>
<span class="sd">        &gt;&gt;&gt; tM = Scat[&#39;tM&#39;] </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; tP.shape</span>
<span class="sd">        (513, 512)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; np.linalg.norm(tP-tM)</span>
<span class="sd">        0.0</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Transmission coefficient for k1,omega = (0,Delta omega)</span>
<span class="sd">        &gt;&gt;&gt; tP[1,0]</span>
<span class="sd">        (0.9865896281519458+0j)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if required input variables are given</span>
        <span class="k">if</span> <span class="p">(</span>   <span class="p">(</span><span class="n">beta11_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">beta13_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">beta33_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> 
            <span class="ow">or</span> <span class="p">(</span><span class="n">beta11_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">beta13_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">beta33_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> 
            <span class="ow">or</span> <span class="p">(</span><span class="n">K3_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">K3_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_k1_w: The input variables </span><span class="se">\&#39;</span><span class="s1">beta11_u</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">beta13_u</span><span class="se">\&#39;</span><span class="s1">,&#39;</span>
                     <span class="o">+</span><span class="s1">&#39; </span><span class="se">\&#39;</span><span class="s1">beta33_u</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">K3_u</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">beta11_l</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">beta13_l</span><span class="se">\&#39;</span><span class="s1">, &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">beta33_l</span><span class="se">\&#39;</span><span class="s1">,  </span><span class="se">\&#39;</span><span class="s1">K3_l</span><span class="se">\&#39;</span><span class="s1"> must be set.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check if normalisation is set correctly</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_k1_w: The input variable </span><span class="se">\&#39;</span><span class="s1">normalisation</span><span class="se">\&#39;</span><span class="s1"> must be&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; set, either to </span><span class="se">\&#39;</span><span class="s1">flux</span><span class="se">\&#39;</span><span class="s1">, or to </span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check if the vertical-wavenumber for a sign-inverted horizontal-</span>
        <span class="c1"># wavenumber is given</span>
        <span class="k">if</span>  <span class="p">(</span>    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> 
             <span class="ow">and</span> <span class="p">((</span><span class="n">K3n_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">K3n_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span> 
             <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> 
             <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_k1_w: The input variables </span><span class="se">\&#39;</span><span class="s1">K3n_u</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">K3n_l</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; (vertical-wavenumber :math:`k_3` for a sign-inverted&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; horizontal-wavenumber :math:`k_1`) must be set to&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; compute the scattering coefficients in the adjoint&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; medium </span><span class="se">\&#39;</span><span class="s1">rPa</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">tPa</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">rMa</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">tMa</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Initialise scattering coefficients in adjoint medium    </span>
        <span class="n">rPa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tPa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rMa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tMa</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># For zero frequency and zero horizontal-wavenumber we will encounter</span>
        <span class="c1"># divisions by zero. </span>
        <span class="c1"># To avoid this problem we modify the (w,k1)=(0,0) element of K3,</span>
        <span class="c1"># such that there is no division by zero, and such that the resulting</span>
        <span class="c1"># scattering coefficients are correct</span>
        <span class="c1"># The (w,k1)=(0,0) element of K3 is actually a ray-parameter P3</span>
        <span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">K3_u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span>
        <span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">K3_l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span>
        <span class="n">K3n_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">K3n_u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span>
        <span class="n">K3n_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">K3n_l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span>
        
        <span class="n">hu</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">beta11_u</span><span class="o">*</span><span class="n">beta33_u</span><span class="o">-</span><span class="n">beta13_u</span><span class="o">*</span><span class="n">beta13_u</span> <span class="p">)</span>
        <span class="n">hl</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">beta11_l</span><span class="o">*</span><span class="n">beta33_l</span><span class="o">-</span><span class="n">beta13_l</span><span class="o">*</span><span class="n">beta13_l</span> <span class="p">)</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">):</span>
            
            <span class="c1">#####################</span>
            <span class="c1"># NOT YET IMPLEMENTED</span>
            <span class="c1">#####################</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">RT_k1_w (ReciprocalMedium is True)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For reciprocal media, the scattering coefficients are &#39;</span>
                      <span class="o">+</span><span class="s1">&#39;not yet implemented.&#39;</span><span class="p">)</span>
            
<span class="c1">#            # True medium</span>
<span class="c1">#            denom = 1/( (K3_u-Om*g3_u)*beta_l + (K3_l+Om*g3_l)*beta_u )</span>
<span class="c1">#            rP =  ( (K3_u+Om*g3_u)*beta_l - (K3_l+Om*g3_l)*beta_u ) * denom </span>
<span class="c1">#            rM = -( (K3_u-Om*g3_u)*beta_l - (K3_l-Om*g3_l)*beta_u ) * denom</span>
<span class="c1">#            tP = 2*(K3_u*beta_l*K3_l*beta_u)**0.5 * denom</span>
<span class="c1">#            tM = tP</span>
<span class="c1">#            </span>
<span class="c1">#            # Correct the zero frequency, zero horizontal-wavenumber component</span>
<span class="c1">#            denom = 1/( (K3_u[0,0]-g3_u)*beta_l + (K3_l[0,0]+g3_l)*beta_u )</span>
<span class="c1">#            rP[0,0] =  ( (K3_u[0,0]+g3_u)*beta_l - (K3_l[0,0]+g3_l)*beta_u ) * denom </span>
<span class="c1">#            rM[0,0] = -( (K3_u[0,0]-g3_u)*beta_l - (K3_l[0,0]-g3_l)*beta_u ) * denom</span>
<span class="c1">#            tP[0,0] = 2*(K3_u[0,0]*beta_l*K3_l[0,0]*beta_u)**0.5 * denom</span>
<span class="c1">#            tM[0,0] = tP[0,0]</span>
<span class="c1">#            </span>
<span class="c1">#            if self.AdjointMedium is True:</span>
<span class="c1">#                # Adjoint medium</span>
<span class="c1">#                rPa = rP </span>
<span class="c1">#                tPa = tP </span>
<span class="c1">#                rMa = rM </span>
<span class="c1">#                tMa = tM </span>
<span class="c1">#    </span>
<span class="c1">#                if self.verbose is True:</span>
<span class="c1">#                    print(&#39;\nRT_k1_w: (AdjointMedium is True) and (ReciprocalMedium is True)&#39;)</span>
<span class="c1">#                    print(72*&#39;-&#39;)</span>
<span class="c1">#                    print(&#39;For reciprocal media, the scattering coefficients in a medium and its adjoint medium are identical.\n&#39;)</span>
<span class="c1">#        </span>
<span class="c1">#        elif (self.ReciprocalMedium is True) and (normalisation is &#39;pressure&#39;):</span>
<span class="c1">#            </span>
<span class="c1">#            # True medium</span>
<span class="c1">#            denom = 1/( (K3_u-Om*g3_u)*beta_l + (K3_l+Om*g3_l)*beta_u )</span>
<span class="c1">#            rP =  ( (K3_u+Om*g3_u)*beta_l - (K3_l+Om*g3_l)*beta_u ) * denom</span>
<span class="c1">#            rM = -( (K3_u-Om*g3_u)*beta_l - (K3_l-Om*g3_l)*beta_u ) * denom</span>
<span class="c1">#            tP = 2*K3_u*beta_l * denom</span>
<span class="c1">#            tM = 2*K3_l*beta_u * denom</span>
<span class="c1">#            </span>
<span class="c1">#            # Correct the zero frequency, zero horizontal-wavenumber component</span>
<span class="c1">#            denom = 1/( (K3_u[0,0]-g3_u)*beta_l + (K3_l[0,0]+g3_l)*beta_u )</span>
<span class="c1">#            rP[0,0] =  ( (K3_u[0,0]+g3_u)*beta_l - (K3_l[0,0]+g3_l)*beta_u ) * denom </span>
<span class="c1">#            rM[0,0] = -( (K3_u[0,0]-g3_u)*beta_l - (K3_l[0,0]-g3_l)*beta_u ) * denom</span>
<span class="c1">#            tP[0,0] = 2*K3_u[0,0]*beta_l * denom</span>
<span class="c1">#            tM[0,0] = 2*K3_l[0,0]*beta_u * denom</span>
<span class="c1">#            </span>
<span class="c1">#            if self.verbose is True and self.AdjointMedium is True:</span>
<span class="c1">#                print(&#39;\nRT_k1_w: (AdjointMedium is True) and (normalisation=\&#39;pressure\&#39;)&#39;)</span>
<span class="c1">#                print(72*&#39;-&#39;)</span>
<span class="c1">#                print(&#39;We have defined the scattering coefficients of the adjoint medium only for flux-normalisation.\n&#39;)</span>
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">):</span>
            
            <span class="c1"># True medium (no need to coorect (w,k1)=(0,0) element)</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">hu</span> <span class="o">+</span> <span class="n">K3_l</span><span class="o">*</span><span class="n">hl</span><span class="p">)</span>
            <span class="n">rP</span> <span class="o">=</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">hu</span> <span class="o">-</span> <span class="n">K3_l</span><span class="o">*</span><span class="n">hl</span><span class="p">)</span> <span class="o">*</span><span class="n">denom</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">hu</span><span class="o">*</span><span class="n">K3_l</span><span class="o">*</span><span class="n">hl</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="o">-</span><span class="n">rP</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="n">tP</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Adjoint medium (no need to coorect (w,k1)=(0,0) element)</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">K3n_u</span><span class="o">*</span><span class="n">hu</span> <span class="o">+</span> <span class="n">K3n_l</span><span class="o">*</span><span class="n">hl</span><span class="p">)</span>
                <span class="n">rPa</span> <span class="o">=</span> <span class="p">(</span><span class="n">K3n_u</span><span class="o">*</span><span class="n">hu</span> <span class="o">-</span> <span class="n">K3n_l</span><span class="o">*</span><span class="n">hl</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
                <span class="n">tPa</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">K3n_u</span><span class="o">*</span><span class="n">hu</span><span class="o">*</span><span class="n">K3n_l</span><span class="o">*</span><span class="n">hl</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">denom</span>
                <span class="n">rMa</span> <span class="o">=</span> <span class="o">-</span><span class="n">rPa</span>
                <span class="n">tMa</span> <span class="o">=</span> <span class="n">tPa</span> 
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            
            <span class="c1"># True medium  (no need to coorect (w,k1)=(0,0) element)</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">hu</span> <span class="o">+</span> <span class="n">K3_l</span><span class="o">*</span><span class="n">hl</span><span class="p">)</span>
            <span class="n">rP</span> <span class="o">=</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">hu</span> <span class="o">-</span> <span class="n">K3_l</span><span class="o">*</span><span class="n">hl</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3_u</span><span class="o">*</span><span class="n">hu</span><span class="o">*</span><span class="n">denom</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="o">-</span><span class="n">rP</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">RT_k1_w: (AdjointMedium is True) and (normalisation=</span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="mi">72</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We have defined the scattering coefficients of the &#39;</span>
                      <span class="o">+</span><span class="s1">&#39;adjoint medium only for flux-normalisation.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rP&#39;</span><span class="p">:</span><span class="n">rP</span><span class="p">,</span><span class="s1">&#39;tP&#39;</span><span class="p">:</span><span class="n">tP</span><span class="p">,</span><span class="s1">&#39;rM&#39;</span><span class="p">:</span><span class="n">rM</span><span class="p">,</span><span class="s1">&#39;tM&#39;</span><span class="p">:</span><span class="n">tM</span><span class="p">,</span><span class="s1">&#39;rPa&#39;</span><span class="p">:</span><span class="n">rPa</span><span class="p">,</span><span class="s1">&#39;tPa&#39;</span><span class="p">:</span><span class="n">tPa</span><span class="p">,</span><span class="s1">&#39;rMa&#39;</span><span class="p">:</span><span class="n">rMa</span><span class="p">,</span><span class="s1">&#39;tMa&#39;</span><span class="p">:</span><span class="n">tMa</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.W_propagators_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.W_propagators_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">W_propagators_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">LP</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">LM</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">LPn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">LMn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dx3</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the downgoing propagator &#39;wP&#39; and the upgoing progagator </span>
<span class="sd">        &#39;wM&#39; for all sampled eigenvalues &#39;LP&#39; and &#39;LM&#39; and a vertical distance </span>
<span class="sd">        &#39;dx3&#39; (downward pointing :math:`x_3`-axis).</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        LP : numpy.ndarray</span>
<span class="sd">            Eigenvalus :math:`\lambda^+` for all frquencies :math:`\omega` and </span>
<span class="sd">            all horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">            </span>
<span class="sd">        LM : numpy.ndarray</span>
<span class="sd">            Eigenvalus :math:`\lambda^-` for all frquencies :math:`\omega` and </span>
<span class="sd">            all horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">        </span>
<span class="sd">        LPn : numpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Eigenvalus :math:`\lambda^+` for all frquencies :math:`\omega` and </span>
<span class="sd">            all sign-inverted horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">            </span>
<span class="sd">        LMn : numpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Eigenvalus :math:`\lambda^-` for all frquencies :math:`\omega` and </span>
<span class="sd">            all sign-inverted horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">            </span>
<span class="sd">        dx3 : int, float</span>
<span class="sd">            Vertical propagation distance :math:`\Delta x_3` (downward </span>
<span class="sd">            pointing :math:`x_3`-axis).</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">            </span>
<span class="sd">                - **wP**: Downward propagator :math:`\\tilde{w}^+`.</span>
<span class="sd">                - **wM**: Upward propagator :math:`\\tilde{w}^-`.</span>
<span class="sd">                - **wPa**: Downward propagator :math:`\\tilde{w}^{+(a)}` (adjoint medium). </span>
<span class="sd">                - **wMa**: Upward propagator :math:`\\tilde{w}^{-(a)}` (adjoint medium). </span>
<span class="sd">                </span>
<span class="sd">            All propagators are stored in an arrays of shape (nf,nr). The </span>
<span class="sd">            variables &#39;wPa&#39; and &#39;wMa&#39; are computed only for the setting </span>
<span class="sd">            &#39;AdjointMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        .. todo::</span>
<span class="sd">            </span>
<span class="sd">            In a non-reciprocal medium, for a complex-valued frequency </span>
<span class="sd">            :math:`\omega&#39;=\omega+\mathrm{j}\epsilon` one of the propagators </span>
<span class="sd">            has an exponentially growing term. Does that cause errors? If yes, </span>
<span class="sd">            can we fix that manually? (still the case?)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; TO BE UPDATED</span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise a wavefield</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">        &gt;&gt;&gt;      avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g1vec=1j*np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g3vec=1j*np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      ReciprocalMedium=True,AdjointMedium=True)</span>

<span class="sd">        &gt;&gt;&gt; # Compute the propagators of the first layer</span>
<span class="sd">        &gt;&gt;&gt; Prop = F.W_propagators_k1_w(K3=F.K3[:,:,0],K3n=F.K3n[:,:,0],</span>
<span class="sd">        &gt;&gt;&gt;                             g3=F.g3vec[0],dx3=F.x3vec[0])</span>

<span class="sd">        &gt;&gt;&gt; wP = Prop[&#39;wP&#39;]</span>
<span class="sd">        &gt;&gt;&gt; wM = Prop[&#39;wM&#39;]</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # In reciprocal media the down- and upgoing propagators are identical</span>
<span class="sd">        &gt;&gt;&gt; np.linalg.norm(wP-wM)</span>
<span class="sd">        0.0</span>
<span class="sd">        </span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if required input variables are given</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LP</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span> 
             <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LM</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dx3</span><span class="p">))</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;W_propagators_k1_w: The input variables </span><span class="se">\&#39;</span><span class="s1">LP</span><span class="se">\&#39;</span><span class="s1"> and  &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">LM</span><span class="se">\&#39;</span><span class="s1"> must have the shape (nf,nr)=(</span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1">). The input &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">dx3</span><span class="se">\&#39;</span><span class="s1"> be a scalar.&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span>
            
        <span class="c1"># If AdjointMedium=True it is required to set LPn=LP(-k1) and LMn=LM(-k1)</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> 
            <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LPn</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">LMn</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;W_propagators_k1_w: If </span><span class="se">\&#39;</span><span class="s1">AdjointMedium=True</span><span class="se">\&#39;</span><span class="s1"> the input&#39;</span>
                     <span class="o">+</span><span class="s1">&#39;variables </span><span class="se">\&#39;</span><span class="s1">LPn</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">LMn</span><span class="se">\&#39;</span><span class="s1"> must be given, and it &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;must have the shape (nf,nr)=(</span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1">).&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span>
        
        <span class="c1"># Propagators in the adjoint medium</span>
        <span class="n">wPa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">wMa</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#####################</span>
            <span class="c1"># NOT YET IMPLEMENTED</span>
            <span class="c1">#####################</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">W_propagators_k1_w (ReciprocalMedium is True)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-----------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For reciprocal media, the propagators are not yet &#39;</span>
                      <span class="o">+</span><span class="s1">&#39;implemented.&#39;</span><span class="p">)</span>
<span class="c1">#            wP = np.exp(1j*K3*dx3)</span>
<span class="c1">#            wM = wP.copy()</span>
<span class="c1">#            </span>
<span class="c1">#            if self.AdjointMedium is True:</span>
<span class="c1">#                wPa = np.exp(1j*K3n*dx3)</span>
<span class="c1">#                wMa = wPa.copy()                </span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            
            <span class="n">wP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">LP</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
            <span class="n">wM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">LM</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
        
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">wPa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">LMn</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
                <span class="n">wMa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">LPn</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
           
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;wP&#39;</span><span class="p">:</span><span class="n">wP</span><span class="p">,</span><span class="s1">&#39;wM&#39;</span><span class="p">:</span><span class="n">wM</span><span class="p">,</span><span class="s1">&#39;wPa&#39;</span><span class="p">:</span><span class="n">wPa</span><span class="p">,</span><span class="s1">&#39;wMa&#39;</span><span class="p">:</span><span class="n">wMa</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.Contains_Nan_Inf"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.Contains_Nan_Inf">[docs]</a>    <span class="k">def</span> <span class="nf">Contains_Nan_Inf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">FuncName</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;checks if the given arrays contain NaN or Inf elements. If an array</span>
<span class="sd">        contains NaN or Inf elements a command line statement is printed.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        FuncName : str</span>
<span class="sd">            Name of the function in which **Contains_Nan_Inf** is called.</span>
<span class="sd">            </span>
<span class="sd">        *args : tuple</span>
<span class="sd">            Undetermined number of input tuples. The first tuple element is an</span>
<span class="sd">            array, the second tuple element is the name of the array.</span>
<span class="sd">            </span>
<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        </span>
<span class="sd">        Message : str or None</span>
<span class="sd">            If any of the input arrays contains a NaN or Inf, a message is </span>
<span class="sd">            printed in the command line.</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        This function is only meant for internal usage. Therefore, there are no</span>
<span class="sd">        checks of the input variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
            <span class="n">Var</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Name</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="p">:</span>
                
                <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">FuncName</span><span class="o">+</span><span class="s1">&#39;:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="mi">72</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;At least one element of the modelled wavefields&#39;</span> 
                          <span class="o">+</span> <span class="s1">&#39;contains a NaN (Not a Number) or an Inf &#39;</span>
                          <span class="o">+</span> <span class="s1">&#39;(infinite).</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">keep</span> <span class="o">+=</span> <span class="mi">1</span>
                
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - &#39;</span><span class="o">+</span><span class="n">Name</span><span class="o">+</span><span class="s1">&#39; contains </span><span class="si">%d</span><span class="s1"> NaN.&#39;</span>
                          <span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Var</span><span class="p">))))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - &#39;</span><span class="o">+</span><span class="n">Name</span><span class="o">+</span><span class="s1">&#39; contains </span><span class="si">%d</span><span class="s1"> Inf.&#39;</span>
                          <span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Var</span><span class="p">))))</span>
        <span class="k">return</span></div>
            
    
<div class="viewcode-block" id="Layered_NRM_k1_w.RT_response_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.RT_response_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">RT_response_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g1vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span><span class="n">InternalMultiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the reflection and transmission responses from above and </span>
<span class="sd">        from below. The medium parameters defined in **Layered_NRM_k1_w** are </span>
<span class="sd">        used, except if the medium parameters are given via the input </span>
<span class="sd">        variables. </span>
<span class="sd">        </span>
<span class="sd">        The medium responses are associated to measurements at :math:`x_3=0` </span>
<span class="sd">        and at :math:`x_3=` &#39;x3vec[-2]&#39; :math:`+\epsilon`, where </span>
<span class="sd">        :math:`\epsilon` is an infinitesimally small positive constant. Hence, </span>
<span class="sd">        the propagation from :math:`x_3=0` to the shallowest interface is </span>
<span class="sd">        included. However, the propagation through the deepest layer is </span>
<span class="sd">        excluded.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        x3vec : numpy.ndarray, optional</span>
<span class="sd">            Vertical spatial vector :math:`x_3`, for n layers &#39;x3vec&#39; must have </span>
<span class="sd">            the shape (n,). We define the :math:`x_3`-axis as </span>
<span class="sd">            downward-pointing. Implicitly, the first value on the </span>
<span class="sd">            :math:`x_3`-axis is zero (not stored in &#39;x3vec&#39;).</span>
<span class="sd">    </span>
<span class="sd">        avec : numpy.ndarray, optional</span>
<span class="sd">            Medium parameter :math:`\\alpha` (real-valued), for n layers &#39;avec&#39; </span>
<span class="sd">            must have the shape (n,).</span>
<span class="sd">            </span>
<span class="sd">        bvec : numpy.ndarray, optional</span>
<span class="sd">            Medium parameter :math:`\\beta` (real-valued), for n layers &#39;bvec&#39; </span>
<span class="sd">            must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">        g1vec : numpy.ndarray, optional</span>
<span class="sd">            Medium parameter :math:`\gamma_1` (real-valued for non-reciprocal </span>
<span class="sd">            media or imaginary-valued for reciprocal media), for n layers </span>
<span class="sd">            &#39;g1vec&#39; must have the shape (n,).</span>
<span class="sd">            </span>
<span class="sd">        g3vec : numpy.ndarray, optional</span>
<span class="sd">            Medium parameter :math:`\gamma_3` (real-valued for non-reciprocal </span>
<span class="sd">            media or imaginary-valued for reciprocal media), for n layers </span>
<span class="sd">            &#39;g3vec&#39; must have the shape (n,).</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for </span>
<span class="sd">            flux-normalisation set normalisation=&#39;flux&#39;.</span>
<span class="sd">            </span>
<span class="sd">        InternalMultiples : bool, optional</span>
<span class="sd">            To model internal multiples set &#39;InternalMultiples=True&#39;. To </span>
<span class="sd">            ignore internal multiples set &#39;InternalMultiples=False&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **RP**: Reflection response from above.</span>
<span class="sd">                - **TP**: Transmission response from above.</span>
<span class="sd">                - **RM**: Reflection response from below.</span>
<span class="sd">                - **TM**: Transmission response from below.</span>
<span class="sd">                - **RPa**: Reflection response from above (adjoint medium).</span>
<span class="sd">                - **TPa**: Transmission response from above (adjoint medium).</span>
<span class="sd">                - **RMa**: Reflection response from below (adjoint medium).</span>
<span class="sd">                - **TMa**: Transmission response from below (adjoint medium).</span>
<span class="sd">            All medium responses are stored in arrays of shape (nf,nr). The </span>
<span class="sd">            variables &#39;RPa&#39;, &#39;TPa&#39;, &#39;RMa&#39; and &#39;TMa&#39; are computed only if one </span>
<span class="sd">            sets &#39;AdjointMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise a wavefield in a 1D reciprocal medium</span>
<span class="sd">        &gt;&gt;&gt; F = LM(nt=4096,dt=0.005,nr=2048,dx1=12.5,eps=2/(2049*0.005),</span>
<span class="sd">                   x3vec=np.array([1.1,2.2,3.7])*1e3,</span>
<span class="sd">                   avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">                   g1vec=np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">                   g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">                   ReciprocalMedium=False,AdjointMedium=True) </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Model the medium responses</span>
<span class="sd">        &gt;&gt;&gt; RT = F.RT_response_k1_w(normalisation=&#39;flux&#39;,InternalMultiples=True)</span>
<span class="sd">        &gt;&gt;&gt; RP = RT[&#39;RP&#39;]</span>
<span class="sd">        &gt;&gt;&gt; # Make a Ricker wavelet</span>
<span class="sd">        &gt;&gt;&gt; Wav=F.RickerWavelet_w(f0=30)</span>
<span class="sd">        &gt;&gt;&gt; # Compute gain function (correct for complex-valued frequency)</span>
<span class="sd">        &gt;&gt;&gt; gain = F.Gain_t()</span>
<span class="sd">        &gt;&gt;&gt; # Apply wavelet, transform to the space-time domain and apply gain</span>
<span class="sd">        &gt;&gt;&gt; rP = np.fft.fftshift(gain*F.K1W2X1T(Wav*RP),axes=(0,1))</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Plot reflection response</span>
<span class="sd">        &gt;&gt;&gt; T   = F.Tvec()[&#39;tvec&#39;]</span>
<span class="sd">        &gt;&gt;&gt; X1  = F.Xvec()[&#39;xvec&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ex  = (X1[0,0], X1[-1,0], T[-1,0], T[0,0])</span>
<span class="sd">        &gt;&gt;&gt; asp = X1[-1,0]/T[-1,0]</span>
<span class="sd">        &gt;&gt;&gt; plt.figure(); plt.imshow(rP,cmap=&#39;seismic&#39;,vmin=-1e-3,vmax=1e-3,</span>
<span class="sd">                                     extent=ex,aspect=asp)</span>
<span class="sd">        &gt;&gt;&gt; plt.xlabel(&#39;Offset (m)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;Time (s)&#39;)</span>
<span class="sd">        </span>
<span class="sd">        .. image:: ../pictures/cropped/Rplus_k1_w.png</span>
<span class="sd">            :height: 200px</span>
<span class="sd">            :width: 200 px</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if normalisation is set correctly</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_response_k1_w: The input variable </span><span class="se">\&#39;</span><span class="s1">normalisation</span><span class="se">\&#39;</span><span class="s1"> &#39;</span><span class="o">+</span>
                     <span class="s1">&#39;must be set, either to </span><span class="se">\&#39;</span><span class="s1">flux</span><span class="se">\&#39;</span><span class="s1">, or to </span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Medium responses of the adjoint medium can only be computed in </span>
        <span class="c1"># flux-normalisation</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_response_k1_w: We have defined the scattering &#39;</span><span class="o">+</span>
                     <span class="s1">&#39;coefficients of the adjoint medium only for &#39;</span>     <span class="o">+</span>
                     <span class="s1">&#39;flux-normalisation.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if a layer stack is given</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x3vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g1vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g3vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            
            <span class="c1"># Create a wavefield in a sub-medium</span>
            <span class="c1"># I do this because when the sub-wavefield is initialised all </span>
            <span class="c1"># parameters are automatically tested for correctness</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span> <span class="o">=</span> <span class="n">Layered_NRM_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dx1</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
                                            <span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span>
                                            <span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span><span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                            <span class="n">ReciprocalMedium</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span><span class="p">,</span>
                                            <span class="n">AdjointMedium</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span><span class="p">)</span>
            
            <span class="n">x3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">x3vec</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">bvec</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">g3vec</span>
            <span class="n">K3</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">K3</span>
            <span class="n">K3n</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">K3n</span>
                
        <span class="c1"># Else compute response of entire medium</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span>
            <span class="n">K3</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K3</span>
            <span class="n">K3n</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K3n</span>
            
        
        <span class="c1"># Number of layers</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x3vec</span><span class="p">)</span>
        
        <span class="c1"># Vector with layer thicknesses</span>
        <span class="n">dx3vec</span> <span class="o">=</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dx3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">x3vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Reflection responses: Initial value</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">RM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Here every frequency component has an amplitude equal to one. Hence,</span>
        <span class="c1"># the total wavefield has a strength of sqrt(nt*nr)</span>
        <span class="c1"># When an ifft is applied the wavefield is scaled by 1/sqrt(nt*nr).</span>
        <span class="c1"># Hence in the time domain the wavefield has an amplitude equal to one.</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">TM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Internal multiple operator: Initial value</span>
        <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">RPa</span> <span class="o">=</span> <span class="n">RP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">RMa</span> <span class="o">=</span> <span class="n">RM</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">TPa</span> <span class="o">=</span> <span class="n">TP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">TMa</span> <span class="o">=</span> <span class="n">TM</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">RPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">TPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">RMa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">TMa</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Loop over N-1 interfaces</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="c1"># Scattering coefficients</span>
            <span class="n">ScatCoeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_k1_w</span><span class="p">(</span><span class="n">beta_u</span><span class="o">=</span><span class="n">bvec</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">g3_u</span><span class="o">=</span><span class="n">g3vec</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                     <span class="n">K3_u</span><span class="o">=</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span><span class="n">K3n_u</span><span class="o">=</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span>
                                     <span class="n">beta_l</span><span class="o">=</span><span class="n">bvec</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">g3_l</span><span class="o">=</span><span class="n">g3vec</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">K3_l</span><span class="o">=</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">K3n_l</span><span class="o">=</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">)</span>
            
            <span class="n">rP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rP&#39;</span><span class="p">]</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tP&#39;</span><span class="p">]</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rM&#39;</span><span class="p">]</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tM&#39;</span><span class="p">]</span>
            
            <span class="c1"># Propagators</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_propagators_k1_w</span><span class="p">(</span><span class="n">K3</span><span class="o">=</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span><span class="n">K3n</span><span class="o">=</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span>
                                        <span class="n">g3</span><span class="o">=</span><span class="n">g3vec</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">dx3</span><span class="o">=</span><span class="n">dx3vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>    <span class="p">)</span>
            <span class="n">WP</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wP&#39;</span><span class="p">]</span>
            <span class="n">WM</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wM&#39;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="p">)</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="p">)</span>
            
            <span class="c1"># Update reflection / transmission responses</span>
            <span class="n">RP</span> <span class="o">=</span> <span class="n">RP</span> <span class="o">+</span> <span class="n">TM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TP</span>
            <span class="n">RM</span> <span class="o">=</span> <span class="n">rM</span> <span class="o">+</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>
            <span class="n">TP</span> <span class="o">=</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TP</span>
            <span class="n">TM</span> <span class="o">=</span> <span class="n">TM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>  
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">rP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rPa&#39;</span><span class="p">]</span>
                <span class="n">tP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tPa&#39;</span><span class="p">]</span>
                <span class="n">rM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rMa&#39;</span><span class="p">]</span>
                <span class="n">tM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tMa&#39;</span><span class="p">]</span>
                <span class="n">WP</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wPa&#39;</span><span class="p">]</span>
                <span class="n">WM</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wMa&#39;</span><span class="p">]</span>
            
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="p">)</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="p">)</span>
                
                <span class="c1"># Update reflection / transmission responses</span>
                <span class="n">RPa</span> <span class="o">=</span> <span class="n">RPa</span> <span class="o">+</span> <span class="n">TMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TPa</span>
                <span class="n">RMa</span> <span class="o">=</span> <span class="n">rM</span> <span class="o">+</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>
                <span class="n">TPa</span> <span class="o">=</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TPa</span>
                <span class="n">TMa</span> <span class="o">=</span> <span class="n">TMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>  
                
        <span class="c1"># Verbose: Inform the user if any wavefield contains NaNs of Infs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Contains_Nan_Inf</span><span class="p">(</span><span class="s1">&#39;RT_response_k1_w&#39;</span><span class="p">,(</span><span class="n">RP</span><span class="p">,</span><span class="s1">&#39;RP&#39;</span><span class="p">),(</span><span class="n">TP</span><span class="p">,</span><span class="s1">&#39;TP&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="n">RM</span><span class="p">,</span><span class="s1">&#39;RM&#39;</span><span class="p">),(</span><span class="n">TM</span><span class="p">,</span><span class="s1">&#39;TM&#39;</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Contains_Nan_Inf</span><span class="p">(</span><span class="s1">&#39;RT_response_k1_w&#39;</span><span class="p">,(</span><span class="n">RPa</span><span class="p">,</span><span class="s1">&#39;RPa&#39;</span><span class="p">),</span>
                                      <span class="p">(</span><span class="n">TPa</span><span class="p">,</span><span class="s1">&#39;TPa&#39;</span><span class="p">),(</span><span class="n">RMa</span><span class="p">,</span><span class="s1">&#39;RMa&#39;</span><span class="p">),(</span><span class="n">TMa</span><span class="p">,</span><span class="s1">&#39;TMa&#39;</span><span class="p">))</span>

                
        <span class="n">out</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;RP&#39;</span><span class="p">:</span><span class="n">RP</span>  <span class="p">,</span><span class="s1">&#39;TP&#39;</span><span class="p">:</span><span class="n">TP</span>  <span class="p">,</span><span class="s1">&#39;RM&#39;</span><span class="p">:</span><span class="n">RM</span>  <span class="p">,</span><span class="s1">&#39;TM&#39;</span><span class="p">:</span><span class="n">TM</span><span class="p">,</span>
             <span class="s1">&#39;RPa&#39;</span><span class="p">:</span><span class="n">RPa</span><span class="p">,</span><span class="s1">&#39;TPa&#39;</span><span class="p">:</span><span class="n">TPa</span><span class="p">,</span><span class="s1">&#39;RMa&#39;</span><span class="p">:</span><span class="n">RMa</span><span class="p">,</span><span class="s1">&#39;TMa&#39;</span><span class="p">:</span><span class="n">TMa</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
            
    <span class="c1"># Insert a layer in the model    </span>
<div class="viewcode-block" id="Layered_NRM_k1_w.Insert_layer"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.Insert_layer">[docs]</a>    <span class="k">def</span> <span class="nf">Insert_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;inserts a transparent interface at the depth level &#39;x3&#39;. If &#39;x3&#39; </span>
<span class="sd">        coincides with an interface of the model, the model&#39;s interface is left </span>
<span class="sd">        unchanged. If &#39;x3&#39; is a vector it is interpreted as multiple depth </span>
<span class="sd">        levels, at each one a transparent interface will be inserted.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        x3 : int, float, numpy.ndarray</span>
<span class="sd">            A depth level, or a vector of depth levels, at which a transparent </span>
<span class="sd">            interface will be inserted. The variable &#39;x3&#39; either must be a </span>
<span class="sd">            scalar, or have the shape (n,). Each element of &#39;x3&#39; must be </span>
<span class="sd">            real-valued and greater than, or equal to zero.</span>
<span class="sd">    </span>
<span class="sd">        UpdateSelf : bool, optional</span>
<span class="sd">            Set &#39;UpdateSelf=True&#39; to not only output an updated model but also </span>
<span class="sd">            update the &#39;self&#39; parameters.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **x3vec**: Updated depth vector.</span>
<span class="sd">                - **avec**:  Updated :math:`\\alpha` vector.</span>
<span class="sd">                - **bvec**:  Updated :math:`\\beta` vector.</span>
<span class="sd">                - **g1vec**: Updated :math:`\gamma_1` vector.</span>
<span class="sd">                - **g3vec**: Updated :math:`\gamma_3` vector.</span>
<span class="sd">                - **K3**:    Updated :math:`k_3(k_1)` vector.</span>
<span class="sd">                - **K3n**:   Updated :math:`k_3(-k_1)` vector.</span>
<span class="sd">            All medium parameter vectors are stored in arrays of shape (n,).</span>
<span class="sd">            The vertical wavenumbers are stored in arrays of shape (nf,nr,n).</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise a wavefield in a 1D reciprocal medium</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=10,</span>
<span class="sd">                 x3vec=np.array([10,150,200]),</span>
<span class="sd">                 avec=np.array([1,2,3]),bvec=np.array([0.4,3.14,2]),</span>
<span class="sd">                 g1vec=np.array([0.9,2.1,0.3]),g3vec=np.array([0.7,1.14,0.2]))</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Insert a transparent layer at x3=1</span>
<span class="sd">        &gt;&gt;&gt; out=F.Insert_layer(x3=1,UpdateSelf=False)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Updated depth vector</span>
<span class="sd">        &gt;&gt;&gt; out[&#39;x3vec&#39;]</span>
<span class="sd">        array([  1,  10, 150, 200])</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Updated alpha vector</span>
<span class="sd">        &gt;&gt;&gt; out[&#39;avec&#39;]</span>
<span class="sd">        array([1, 1, 2, 3])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if x3 is a scalar or an array of the shape (n,).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
                <span class="ow">or</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> 
                <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x3</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Insert_layer: The input variable </span><span class="se">\&#39;</span><span class="s1">x3</span><span class="se">\&#39;</span><span class="s1"> must be either &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;a scalar, or an array of shape (n,).&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">or</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x3</span><span class="p">])</span>
        
        <span class="c1"># Check if x3 is real-valued.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">x3</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Insert_layer: The input variable </span><span class="se">\&#39;</span><span class="s1">x3</span><span class="se">\&#39;</span><span class="s1"> must be &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;real-valued.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if all elements of x3 are greater than, or equal to zero.</span>
        <span class="k">if</span> <span class="n">x3</span><span class="p">[</span><span class="n">x3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Insert_layer: Each element of the input variable </span><span class="se">\&#39;</span><span class="s1">x3</span><span class="se">\&#39;</span><span class="s1"> &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;must be  greater than, or equal to zero.&#39;</span><span class="p">)</span>
        
        <span class="n">X3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span>
        <span class="n">Avec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span>
        <span class="n">Bvec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span>
        <span class="n">G1vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span>
        <span class="n">G3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span>
        <span class="n">K3</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K3</span>
        <span class="n">K3n</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K3n</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x3</span><span class="p">)):</span>
        
            <span class="c1"># Vector of depths smaller than or equal to x3[i]</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">X3vec</span><span class="o">&lt;=</span><span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
            
            <span class="c1"># Case1: x3[i] smaller than X3vec[0]</span>
            <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">X3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="p">,</span><span class="n">X3vec</span><span class="p">])</span>
                <span class="n">Avec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Avec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">Avec</span><span class="p">])</span>
                <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Bvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">Bvec</span><span class="p">])</span>
                <span class="n">G1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G1vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">G1vec</span><span class="p">])</span>
                <span class="n">G3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G3vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">G3vec</span><span class="p">])</span>
                <span class="n">K3</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3</span><span class="p">[:,:,:</span><span class="mi">1</span><span class="p">]</span>   <span class="p">,</span><span class="n">K3</span><span class="p">])</span>
                <span class="n">K3n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3n</span><span class="p">[:,:,:</span><span class="mi">1</span><span class="p">]</span>  <span class="p">,</span><span class="n">K3n</span><span class="p">])</span>
            
            <span class="c1"># Case2: x3[i] coincides with an element of X3vec</span>
            <span class="k">elif</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">X3vec</span> <span class="o">=</span> <span class="n">X3vec</span>
                <span class="n">Avec</span>  <span class="o">=</span> <span class="n">Avec</span>
                <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">Bvec</span>
                <span class="n">G1vec</span> <span class="o">=</span> <span class="n">G1vec</span>
                <span class="n">G3vec</span> <span class="o">=</span> <span class="n">G3vec</span>
                <span class="n">K3</span>    <span class="o">=</span> <span class="n">K3</span>
                <span class="n">K3n</span>   <span class="o">=</span> <span class="n">K3n</span>
            
            <span class="c1"># Case 3: x3[i] is larger than X3vec[-1]</span>
            <span class="k">elif</span> <span class="n">L</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">X3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">X3vec</span><span class="p">,</span><span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">Avec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Avec</span> <span class="p">,</span><span class="n">Avec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Bvec</span> <span class="p">,</span><span class="n">Bvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">G1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G1vec</span><span class="p">,</span><span class="n">G1vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">G3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G3vec</span><span class="p">,</span><span class="n">G3vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">K3</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3</span>   <span class="p">,</span><span class="n">K3</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">K3n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3n</span>  <span class="p">,</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:]])</span>
                
            <span class="c1"># Case 4: x3[i] is between X3vec[0] and X3vec[-1] AND does not </span>
            <span class="c1"># coincide with any element of X3vec</span>
            <span class="k">else</span><span class="p">:</span>
                
                <span class="n">b</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                <span class="n">ind</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                
                <span class="n">X3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">X3vec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>       <span class="p">,</span><span class="n">X3vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">Avec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Avec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span><span class="n">Avec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span><span class="n">Avec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Bvec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span><span class="n">Bvec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span><span class="n">Bvec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">G1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G1vec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">G1vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">G1vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">G3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G3vec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">G3vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">G3vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">K3</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3</span><span class="p">[:,:,:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>   <span class="p">,</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>   <span class="p">,</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">K3n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3n</span><span class="p">[:,:,:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="p">,</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>  <span class="p">,</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
            
        <span class="c1"># Update self: Apply layer insertion to the self-parameters    </span>
        <span class="k">if</span> <span class="n">UpdateSelf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K3</span>    <span class="o">=</span> <span class="n">K3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K3n</span>   <span class="o">=</span> <span class="n">K3n</span>
            
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x3vec&#39;</span><span class="p">:</span><span class="n">X3vec</span><span class="p">,</span><span class="s1">&#39;avec&#39;</span><span class="p">:</span><span class="n">Avec</span><span class="p">,</span><span class="s1">&#39;bvec&#39;</span><span class="p">:</span><span class="n">Bvec</span><span class="p">,</span>
               <span class="s1">&#39;g1vec&#39;</span><span class="p">:</span><span class="n">G1vec</span><span class="p">,</span><span class="s1">&#39;g3vec&#39;</span><span class="p">:</span><span class="n">G3vec</span><span class="p">,</span><span class="s1">&#39;K3&#39;</span><span class="p">:</span><span class="n">K3</span><span class="p">,</span><span class="s1">&#39;K3n&#39;</span><span class="p">:</span><span class="n">K3n</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.GreensFunction_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.GreensFunction_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">GreensFunction_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x3R</span><span class="p">,</span><span class="n">x3S</span><span class="p">,</span><span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span>
                           <span class="n">InternalMultiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the one-way Green\&#39;s functions for a receiver and source </span>
<span class="sd">        depth defined by the input variables \&#39;x3R\&#39; and \&#39;x3S\&#39;. The one-way </span>
<span class="sd">        wavefields are decomposed at the receiver- and at the source-side. We </span>
<span class="sd">        define the receiver and source depths just below \&#39;x3R\&#39; and \&#39;x3S\&#39;, </span>
<span class="sd">        respectively (this is important if the receiver or source depth </span>
<span class="sd">        coincides with an interface).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        x3R : int,float</span>
<span class="sd">            Receiver depth.</span>
<span class="sd">    </span>
<span class="sd">        x3S : int, float</span>
<span class="sd">            Source depth.</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for </span>
<span class="sd">            flux-normalisation set normalisation=&#39;flux&#39;.</span>
<span class="sd">            </span>
<span class="sd">        InternalMultiples : bool, optional</span>
<span class="sd">            To model internal multiples set &#39;InternalMultiples=True&#39;. To </span>
<span class="sd">            exclude internal multiples set &#39;InternalMultiples=False&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **GPP**: Green\&#39;s function :math:`G^{+,+}` (true medium).</span>
<span class="sd">                - **GPM**: Green\&#39;s function :math:`G^{+,-}` (true medium).</span>
<span class="sd">                - **GMP**: Green\&#39;s function :math:`G^{-,+}` (true medium).</span>
<span class="sd">                - **GMM**: Green\&#39;s function :math:`G^{-,-}` (true medium).</span>
<span class="sd">                - **GPPa**: Green\&#39;s function :math:`G^{+,+}` (adjoint medium).</span>
<span class="sd">                - **GPMa**: Green\&#39;s function :math:`G^{+,-}` (adjoint medium).</span>
<span class="sd">                - **GMPa**: Green\&#39;s function :math:`G^{-,+}` (adjoint medium).</span>
<span class="sd">                - **GMMa**: Green\&#39;s function :math:`G^{-,-}` (adjoint medium).</span>
<span class="sd">            All medium responses are stored in arrays of shape (nf,nr). The </span>
<span class="sd">            variables &#39;GPPa&#39;, &#39;GPMa&#39;, &#39;GMPa&#39; and &#39;GMMa&#39; are computed, only if </span>
<span class="sd">            one sets &#39;AdjointMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        - The superscript \&#39;+\&#39; and \&#39;-\&#39; refer to downgoing and upgoing waves, </span>
<span class="sd">        respectively.</span>
<span class="sd">        - The first superscript refers to the wavefield at the receiver-side.</span>
<span class="sd">        - The second superscript refers to the wavefield at the source-side.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; to be done</span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise a wavefield in a 1D reciprocal medium</span>
<span class="sd">        &gt;&gt;&gt; F = LM(nt=4096,dt=0.005,nr=2048,dx1=12.5,eps=2/(2049*0.005),</span>
<span class="sd">                   x3vec=np.array([1.1,2.2,3.7])*1e3,</span>
<span class="sd">                   avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">                   g1vec=np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">                   g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">                   ReciprocalMedium=False,AdjointMedium=True) </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; G = F.GreensFunction_p_w(x3R=0,x3S=0,normalisation=normalisation,</span>
<span class="sd">        &gt;&gt;&gt;                          InternalMultiples=InternalMultiples)</span>
<span class="sd">        &gt;&gt;&gt; RT=F.RT_response_p_w(normalisation=normalisation,</span>
<span class="sd">        &gt;&gt;&gt;                      InternalMultiples=InternalMultiples)</span>
<span class="sd">        &gt;&gt;&gt; np.linalg.norm(RT[&#39;RP&#39;]-G[&#39;GMP&#39;]</span>
<span class="sd">        0.0</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Insert transparent interfaces at source and receiver depth levels</span>
        <span class="c1"># The insertion implicitly checks that x3R and x3S are non-negative </span>
        <span class="c1"># real-valued scalars</span>
        <span class="c1"># If the receiver or source depth is greater than, or equal to the </span>
        <span class="c1"># deepest interface, we insert another transparent layer below the  </span>
        <span class="c1"># &#39;new&#39; deepest interface. This is necessary because the function </span>
        <span class="c1"># RT_response_k1_w does not compute the propagation through the deepest</span>
        <span class="c1"># layer. By adding a transparent interface below the source/receiver we</span>
        <span class="c1"># ensure that the propagation is computed correctly.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x3R</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x3S</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">xb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">x3R</span><span class="p">,</span><span class="n">x3S</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">Tmp_medium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x3R</span><span class="p">,</span><span class="n">x3S</span><span class="p">,</span><span class="n">xb</span><span class="p">]),</span>
                                           <span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Tmp_medium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x3R</span><span class="p">,</span><span class="n">x3S</span><span class="p">]),</span>
                                           <span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            
        <span class="n">X3vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;x3vec&#39;</span><span class="p">]</span>
        <span class="n">Avec</span>  <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;avec&#39;</span><span class="p">]</span>
        <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;bvec&#39;</span><span class="p">]</span>
        <span class="n">G1vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;g1vec&#39;</span><span class="p">]</span>
        <span class="n">G3vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;g3vec&#39;</span><span class="p">]</span>
        
        <span class="c1"># Get indices of the receiver and source interfaces</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x3R</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x3S</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">x3R</span> <span class="o">&gt;</span> <span class="n">x3S</span><span class="p">:</span>
            
            <span class="c1"># Overburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>

            <span class="c1"># Sandwiched layer stack</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Underburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            
            <span class="c1"># Exception if underburden is homogeneous</span>
            <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
            
            <span class="n">L3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>

            <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
            <span class="c1"># reading from dictionary</span>
            <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">]</span>
            <span class="n">TP2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TP&#39;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM1</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">GPP12</span> <span class="o">=</span>  <span class="n">TP2</span><span class="o">*</span><span class="n">M1</span>
            <span class="n">GPM12</span> <span class="o">=</span> <span class="o">-</span><span class="n">TP2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span> <span class="c1"># Multiply by -1 because upgoing</span>
                                <span class="c1"># sources are defined with </span>
                                <span class="c1"># negative amplitude</span>
                                            
            <span class="c1"># Compute reflection from below of parts 1+2 </span>
            <span class="n">RM12</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">TP2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TM&#39;</span><span class="p">]</span>
            
            <span class="c1"># Compute the Green&#39;s functions G13 for the complete medium</span>
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">RM12</span><span class="o">*</span><span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">GPP13</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GPP12</span>
            <span class="n">GPM13</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GPM12</span>
            <span class="n">GMP13</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GPP12</span>
            <span class="n">GMM13</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GPM12</span>
            
            <span class="c1"># Green;s functions in adjoint medium</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
                <span class="c1"># reading from dictionary</span>
                <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">]</span>
                <span class="n">TP2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TPa&#39;</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM1</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">GPP12</span> <span class="o">=</span>  <span class="n">TP2</span><span class="o">*</span><span class="n">M1</span>
                <span class="n">GPM12</span> <span class="o">=</span> <span class="o">-</span><span class="n">TP2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span> <span class="c1"># Multiply by -1 because upgoing</span>
                                    <span class="c1"># sources are defined with </span>
                                    <span class="c1"># negative amplitude</span>
                                                
                <span class="c1"># Compute reflection from below of parts 1+2 </span>
                <span class="n">RM12</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">TP2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TMa&#39;</span><span class="p">]</span>
                
                <span class="c1"># Compute the Green&#39;s functions G13 for the complete medium</span>
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">RM12</span><span class="o">*</span><span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">GPP13a</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GPP12</span>
                <span class="n">GPM13a</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GPM12</span>
                <span class="n">GMP13a</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GPP12</span>
                <span class="n">GMM13a</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GPM12</span>
                
            
            
        <span class="k">elif</span> <span class="n">x3R</span> <span class="o">==</span> <span class="n">x3S</span><span class="p">:</span>
            
            <span class="c1"># Overburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Underburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            
            <span class="c1"># Exception if underburden is homogeneous</span>
            <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
            
            <span class="n">L3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
          
            <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
            <span class="c1"># reading from dictionary</span>
            <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">]</span>
            <span class="n">RP3</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM1</span><span class="o">*</span><span class="n">RP3</span> <span class="p">)</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP3</span><span class="o">*</span><span class="n">RM1</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="n">M1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
            <span class="n">GPP13</span> <span class="o">=</span>  <span class="n">M1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
            <span class="n">GPM13</span> <span class="o">=</span> <span class="o">-</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span>     <span class="c1"># Multiply by -1 because upgoing</span>
                                <span class="c1"># sources are defined with </span>
                                <span class="c1"># negative amplitude</span>
            <span class="n">GMP13</span> <span class="o">=</span>  <span class="n">RP3</span><span class="o">*</span><span class="n">M1</span>
            <span class="n">GMM13</span> <span class="o">=</span> <span class="o">-</span><span class="n">M2</span>     <span class="c1"># Multiply by -1 because upgoing</span>
                            <span class="c1"># sources are defined with </span>
                            <span class="c1"># negative amplitude</span>
                            
            <span class="c1"># Green;s functions in adjoint medium</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
                <span class="c1"># reading from dictionary</span>
                <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">]</span>
                <span class="n">RP3</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM1</span><span class="o">*</span><span class="n">RP3</span> <span class="p">)</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP3</span><span class="o">*</span><span class="n">RM1</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="n">M1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                <span class="n">GPP13a</span> <span class="o">=</span>  <span class="n">M1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
                <span class="n">GPM13a</span> <span class="o">=</span> <span class="o">-</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span>     <span class="c1"># Multiply by -1 because upgoing</span>
                                     <span class="c1"># sources are defined with </span>
                                     <span class="c1"># negative amplitude</span>
                <span class="n">GMP13a</span> <span class="o">=</span>  <span class="n">RP3</span><span class="o">*</span><span class="n">M1</span>
                <span class="n">GMM13a</span> <span class="o">=</span> <span class="o">-</span><span class="n">M2</span>     <span class="c1"># Multiply by -1 because upgoing</span>
                                 <span class="c1"># sources are defined with </span>
                                 <span class="c1"># negative amplitude</span>
            
        <span class="k">elif</span> <span class="n">x3R</span> <span class="o">&lt;</span> <span class="n">x3S</span><span class="p">:</span>
            
            <span class="c1"># Overburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Sandwiched layer stack</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Underburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            
            <span class="c1"># Exception if underburden is homogeneous</span>
            <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">s</span><span class="p">:]</span>
                <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">s</span><span class="p">:]</span>
                <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">s</span><span class="p">:]</span>
                <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">s</span><span class="p">:]</span>
            
            <span class="n">L3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
            <span class="c1"># reading from dictionary</span>
            <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">]</span>
            <span class="n">TM2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TM&#39;</span><span class="p">]</span>
            <span class="n">RP3</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span>
            
            <span class="c1"># Compute reflection from above of part 2+3 </span>
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP3</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">RP23</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">TM2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RP3</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TP&#39;</span><span class="p">]</span>
            
            <span class="c1"># Compute the Green&#39;s functions G23 that exclude the medium above </span>
            <span class="c1"># the receiver: GMP23,GMM23</span>
            <span class="n">GMP23</span> <span class="o">=</span>  <span class="n">TM2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RP3</span>                   
            <span class="n">GMM23</span> <span class="o">=</span> <span class="o">-</span><span class="n">TM2</span><span class="o">*</span><span class="n">M1</span>         <span class="c1"># Multiply by -1 because upgoing</span>
                                    <span class="c1"># sources are defined with </span>
                                    <span class="c1"># negative amplitude</span>
                
            
            
            <span class="c1"># Compute the Green&#39;s functions G13 for the complete medium</span>
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP23</span><span class="o">*</span><span class="n">RM1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">GPP13</span> <span class="o">=</span> <span class="n">RM1</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GMP23</span>
            <span class="n">GPM13</span> <span class="o">=</span> <span class="n">RM1</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GMM23</span>
            <span class="n">GMP13</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GMP23</span>
            <span class="n">GMM13</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GMM23</span>
            
            <span class="c1"># Green;s functions in adjoint medium</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
                <span class="c1"># reading from dictionary</span>
                <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">]</span>
                <span class="n">TM2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TMa&#39;</span><span class="p">]</span>
                <span class="n">RP3</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span>
                
                <span class="c1"># Compute reflection from above of part 2+3 </span>
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP3</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">RP23</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">TM2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RP3</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TPa&#39;</span><span class="p">]</span>
                
                <span class="c1"># Compute the Green&#39;s functions G23 that exclude the medium above </span>
                <span class="c1"># the receiver: GMP23,GMM23</span>
                <span class="n">GMP23</span> <span class="o">=</span>  <span class="n">TM2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RP3</span>                   
                <span class="n">GMM23</span> <span class="o">=</span> <span class="o">-</span><span class="n">TM2</span><span class="o">*</span><span class="n">M1</span>         <span class="c1"># Multiply by -1 because upgoing</span>
                                        <span class="c1"># sources are defined with </span>
                                        <span class="c1"># negative amplitude</span>
                    
                
                
                <span class="c1"># Compute the Green&#39;s functions G13 for the complete medium</span>
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP23</span><span class="o">*</span><span class="n">RM1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">GPP13a</span> <span class="o">=</span> <span class="n">RM1</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GMP23</span>
                <span class="n">GPM13a</span> <span class="o">=</span> <span class="n">RM1</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GMM23</span>
                <span class="n">GMP13a</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GMP23</span>
                <span class="n">GMM13a</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GMM23</span>
                
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">GPP13a</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">GPM13a</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">GMP13a</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">GMM13a</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="c1"># Verbose: Inform the user if any wavefield contains NaNs of Infs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Contains_Nan_Inf</span><span class="p">(</span><span class="s1">&#39;GreensFunction_k1_w&#39;</span><span class="p">,</span>
                                  <span class="p">(</span><span class="n">GPP13</span><span class="p">,</span><span class="s1">&#39;GPP13&#39;</span><span class="p">),(</span><span class="n">GPM13</span><span class="p">,</span><span class="s1">&#39;GPM13&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="n">GMP13</span><span class="p">,</span><span class="s1">&#39;GMP13&#39;</span><span class="p">),(</span><span class="n">GMM13</span><span class="p">,</span><span class="s1">&#39;GMM13&#39;</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Contains_Nan_Inf</span><span class="p">(</span><span class="s1">&#39;GreensFunction_k1_w&#39;</span><span class="p">,</span>
                                  <span class="p">(</span><span class="n">GPP13a</span><span class="p">,</span><span class="s1">&#39;GPP13a&#39;</span><span class="p">),(</span><span class="n">GPM13a</span><span class="p">,</span><span class="s1">&#39;GPM13a&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="n">GMP13a</span><span class="p">,</span><span class="s1">&#39;GMP13a&#39;</span><span class="p">),(</span><span class="n">GMM13a</span><span class="p">,</span><span class="s1">&#39;GMM13a&#39;</span><span class="p">))</span>
                
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GPP&#39;</span><span class="p">:</span><span class="n">GPP13</span>  <span class="p">,</span><span class="s1">&#39;GPM&#39;</span><span class="p">:</span><span class="n">GPM13</span>  <span class="p">,</span><span class="s1">&#39;GMP&#39;</span><span class="p">:</span><span class="n">GMP13</span>  <span class="p">,</span><span class="s1">&#39;GMM&#39;</span><span class="p">:</span><span class="n">GMM13</span><span class="p">,</span>
               <span class="s1">&#39;GPPa&#39;</span><span class="p">:</span><span class="n">GPP13a</span><span class="p">,</span><span class="s1">&#39;GPMa&#39;</span><span class="p">:</span><span class="n">GPM13a</span><span class="p">,</span><span class="s1">&#39;GMPa&#39;</span><span class="p">:</span><span class="n">GMP13a</span><span class="p">,</span><span class="s1">&#39;GMMa&#39;</span><span class="p">:</span><span class="n">GMM13a</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.FocusingFunction_p_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.FocusingFunction_p_w">[docs]</a>    <span class="k">def</span> <span class="nf">FocusingFunction_p_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x3F</span><span class="p">,</span><span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span><span class="n">InternalMultiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the focusing functions between the top surface (:math:`x_3=0`) and the focusing depth defined by the input variable \&#39;x3F\&#39;. We define the focusing depth just below \&#39;x3F\&#39;. Hence, if the focusing depth coincides with an interface the focusing function focuses below that interface.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        x3F : int,float</span>
<span class="sd">            Focusing depth.</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for flux-normalisation set normalisation=&#39;flux&#39;. Until now, this function only models the focusing function for flux-normalisation.</span>
<span class="sd">            </span>
<span class="sd">        InternalMultiples : bool, optional</span>
<span class="sd">            To model internal multiples set &#39;InternalMultiples=True&#39;. To ignore internal multiples set &#39;InternalMultiples=False&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **FP**: Downgoing focusing function.</span>
<span class="sd">                - **RP**: Reflection response from above.</span>
<span class="sd">                - **TP**: Transmission response from above.</span>
<span class="sd">                - **FM**: Upgoing focusing function.</span>
<span class="sd">                - **RM**: Reflection response from below.</span>
<span class="sd">                - **TM**: Transmission response from below.</span>
<span class="sd">                - **FPa**: Downgoing focusing function (adjoint medium).</span>
<span class="sd">                - **RPa**: Reflection response from above (adjoint medium).</span>
<span class="sd">                - **TPa**: Transmission response from above (adjoint medium).</span>
<span class="sd">                - **FMa**: Upgoing focusing function (adjoint medium).</span>
<span class="sd">                - **RMa**: Reflection response from below (adjoint medium).</span>
<span class="sd">                - **TMa**: Transmission response from below (adjoint medium).</span>
<span class="sd">            All medium responses are stored in arrays of shape (nf,1). The variables &#39;FPa&#39;, &#39;RPa&#39;, &#39;TPa&#39;, &#39;FMa&#39;, &#39;RMa&#39; and &#39;TMa&#39; are computed only if one sets &#39;AdjointMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        - The downgoing focusing funtion :math:`\\tilde{F}_1^+` is computed by inverting the expressions for the transmission from above :math:`\\tilde{T}^+`:</span>
<span class="sd">            :math:`\\tilde{F}_{1,n}^+ = \\tilde{F}_{1,n-1}^+ (\\tilde{w}_n^+)^{-1} (1 - \\tilde{w}_n^+ \\tilde{R}_{n-1}^{\cap} \\tilde{w}_n^- \\tilde{r}_n^{\cup} )^{-1} (\\tilde{t}_n^+)^{-1}`</span>
<span class="sd">        - The upgoing focusing function is computed by applying the reflection response :math:`R^{\cup}` on the downgoing focusing funtion :math:`\\tilde{F}_1^+`:</span>
<span class="sd">            :math:`\\tilde{F}_{1,n}^- = \\tilde{R}^{\cup} \\tilde{F}_{1,n}^+`.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Layered_NRM_p_w import Layered_NRM_p_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        &gt;&gt;&gt; F=LM( nt=1024,dt=0.005,x3vec=np.array([10,150,200]),</span>
<span class="sd">        &gt;&gt;&gt;       avec=np.array([1,2,3]),bvec=np.array([0.4,3.14,2]),</span>
<span class="sd">        &gt;&gt;&gt;       g1vec=np.array([0.9,2.1,0.3]),g3vec=np.array([0.7,1.14,0.2]),</span>
<span class="sd">        &gt;&gt;&gt;       p1=2e-4,ReciprocalMedium=False,AdjointMedium=True )</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if normalisation is set correctly</span>
        <span class="k">if</span> <span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;flux&#39;</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FocusingFunction_p_w: This function only models the focusing function for flux-normalisation. (For pressure-normalistiont the required equations have to be derived.)&#39;</span><span class="p">)</span>
        
        <span class="c1"># Insert transparent interfaces at the focusing depth level.</span>
        <span class="c1"># The insertion implicitly checks that x3F is non-negative </span>
        <span class="c1"># and real-valued.</span>
        <span class="c1"># If the focusing depth is greater than, or equal to the deepest </span>
        <span class="c1"># interface, we insert another transparent layer below the focusing </span>
        <span class="c1"># depth to be able to compute scattering coefficients at the focusing </span>
        <span class="c1"># depth without getting an index error.</span>
        <span class="k">if</span> <span class="n">x3F</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">Tmp_medium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x3F</span><span class="p">,</span><span class="n">x3F</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span>
                                           <span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Tmp_medium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="n">x3F</span><span class="p">,</span><span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">X3vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;x3vec&#39;</span><span class="p">]</span>
        <span class="n">Bvec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;bvec&#39;</span><span class="p">]</span>
        <span class="n">G3vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;g3vec&#39;</span><span class="p">]</span>
        <span class="n">P3</span>    <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;p3&#39;</span><span class="p">]</span>
        <span class="n">P3n</span>   <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;p3n&#39;</span><span class="p">]</span>
        
        <span class="c1"># Index of the focusing depth</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x3F</span><span class="p">)</span>
        
        <span class="c1"># Only allow propagating waves to model the focusing function</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">P3</span><span class="p">[:</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">P3n</span><span class="p">[:</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FocusingFunction_p_w: (Here,) We only define the focusing function for propagating waves, i.e. not evanescent waves.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Vector with layer thicknesses</span>
        <span class="n">dx3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dx3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">X3vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Down- and upgoing focusing functions: Initial value</span>
        <span class="c1"># Here every frequency component has an amplitude equal to one. Hence,</span>
        <span class="c1"># the total wavefield has a strength of sqrt(nt)</span>
        <span class="c1"># When an ifft is applied the wavefield is scaled by 1/sqrt(nt).</span>
        <span class="c1"># Hence in the time domain the wavefield has an amplitude equal to one.</span>
        <span class="n">FP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">FM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Reflection responses: Initial value</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">RM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Here every frequency component has an amplitude equal to one. Hence,</span>
        <span class="c1"># the total wavefield has a strength of sqrt(nt)</span>
        <span class="c1"># When an ifft is applied the wavefield is scaled by 1/sqrt(nt).</span>
        <span class="c1"># Hence in the time domain the wavefield has an amplitude equal to one.</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">TM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Internal multiple operator: Initial value</span>
        <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">FPa</span> <span class="o">=</span> <span class="n">FP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">FMa</span> <span class="o">=</span> <span class="n">FM</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">RPa</span> <span class="o">=</span> <span class="n">RP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">RMa</span> <span class="o">=</span> <span class="n">RP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">TPa</span> <span class="o">=</span> <span class="n">TP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">TMa</span> <span class="o">=</span> <span class="n">TP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">FPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">FMa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">RPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">TPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">RMa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">TMa</span> <span class="o">=</span> <span class="kc">None</span>
    
        <span class="c1"># Loop over f+1 interfaces</span>
        <span class="c1"># Thus, the wavefield propagates to the focusing depth, and scatters</span>
        <span class="c1"># at the focusing depth.</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="c1"># Scattering coefficients</span>
            <span class="n">ScatCoeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_p_w</span><span class="p">(</span><span class="n">beta_u</span><span class="o">=</span><span class="n">Bvec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="p">,</span><span class="n">g3_u</span><span class="o">=</span><span class="n">G3vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="p">,</span><span class="n">p3_u</span><span class="o">=</span><span class="n">P3</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="p">,</span><span class="n">p3n_u</span><span class="o">=</span><span class="n">P3n</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                     <span class="n">beta_l</span><span class="o">=</span><span class="n">Bvec</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">g3_l</span><span class="o">=</span><span class="n">G3vec</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">p3_l</span><span class="o">=</span><span class="n">P3</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">p3n_l</span><span class="o">=</span><span class="n">P3n</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">)</span>
            
            <span class="n">rP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rP&#39;</span><span class="p">]</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tP&#39;</span><span class="p">]</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rM&#39;</span><span class="p">]</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tM&#39;</span><span class="p">]</span>
            
            <span class="c1"># Propagators</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_propagators_p_w</span><span class="p">(</span><span class="n">p3</span><span class="o">=</span><span class="n">P3</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">p3n</span><span class="o">=</span><span class="n">P3n</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">g3</span><span class="o">=</span><span class="n">G3vec</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">dx3</span><span class="o">=</span><span class="n">dx3vec</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">WP</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wP&#39;</span><span class="p">]</span>
            <span class="n">WM</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wM&#39;</span><span class="p">]</span>
        
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="p">)</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="p">)</span>
            
            <span class="c1"># Update focusing functions and reflection / transmission responses</span>
            <span class="n">FP</span> <span class="o">=</span> <span class="n">FP</span><span class="o">/</span><span class="n">WP</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="p">)</span><span class="o">/</span><span class="n">tP</span>
            <span class="n">RP</span> <span class="o">=</span> <span class="n">RP</span> <span class="o">+</span> <span class="n">TM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TP</span>
            <span class="n">RM</span> <span class="o">=</span> <span class="n">rM</span> <span class="o">+</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>
            <span class="n">TP</span> <span class="o">=</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TP</span>
            <span class="n">TM</span> <span class="o">=</span> <span class="n">TM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>  
            <span class="n">FM</span> <span class="o">=</span> <span class="n">RP</span><span class="o">*</span><span class="n">FP</span>
            
            <span class="c1"># Model focusing functions in the adjoint medium</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">rP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rPa&#39;</span><span class="p">]</span>
                <span class="n">tP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tPa&#39;</span><span class="p">]</span>
                <span class="n">rM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rMa&#39;</span><span class="p">]</span>
                <span class="n">tM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tMa&#39;</span><span class="p">]</span>
                <span class="n">WP</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wPa&#39;</span><span class="p">]</span>
                <span class="n">WM</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wMa&#39;</span><span class="p">]</span>
            
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="p">)</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="p">)</span>
                
                <span class="c1"># Update focusing functions and reflection / transmission responses</span>
                <span class="n">FPa</span> <span class="o">=</span> <span class="n">FPa</span><span class="o">/</span><span class="n">WP</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="p">)</span><span class="o">/</span><span class="n">tP</span>
                <span class="n">RPa</span> <span class="o">=</span> <span class="n">RPa</span> <span class="o">+</span> <span class="n">TMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TPa</span>
                <span class="n">RMa</span> <span class="o">=</span> <span class="n">rM</span> <span class="o">+</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>
                <span class="n">TPa</span> <span class="o">=</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TPa</span>
                <span class="n">TMa</span> <span class="o">=</span> <span class="n">TMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>  
                <span class="n">FMa</span> <span class="o">=</span> <span class="n">RPa</span><span class="o">*</span><span class="n">FPa</span>
                
        <span class="c1"># Verbose: Inform the user if any wavefield contains NaNs of Infs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="p">(</span>   <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FocusingFunction_p_w:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="mi">100</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;One of the modelled wavefields in the true medium contains a NaN (Not a Number) or an Inf (infinite) element.&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="p">(</span>   <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FocusingFunction_p_w:&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="mi">100</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;One of the modelled wavefields in the adoint medium contains a NaN (Not a Number) or an Inf (infinite) element.&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                
        <span class="n">out</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;FP&#39;</span><span class="p">:</span><span class="n">FP</span>  <span class="p">,</span><span class="s1">&#39;RP&#39;</span><span class="p">:</span><span class="n">RP</span>  <span class="p">,</span><span class="s1">&#39;TP&#39;</span><span class="p">:</span><span class="n">TP</span>  <span class="p">,</span><span class="s1">&#39;FM&#39;</span><span class="p">:</span><span class="n">FM</span>  <span class="p">,</span><span class="s1">&#39;RM&#39;</span><span class="p">:</span><span class="n">RM</span>  <span class="p">,</span><span class="s1">&#39;TM&#39;</span><span class="p">:</span><span class="n">TM</span><span class="p">,</span>
             <span class="s1">&#39;FPa&#39;</span><span class="p">:</span><span class="n">FPa</span><span class="p">,</span><span class="s1">&#39;RPa&#39;</span><span class="p">:</span><span class="n">RPa</span><span class="p">,</span><span class="s1">&#39;TPa&#39;</span><span class="p">:</span><span class="n">TPa</span><span class="p">,</span><span class="s1">&#39;FMa&#39;</span><span class="p">:</span><span class="n">FMa</span><span class="p">,</span><span class="s1">&#39;RMa&#39;</span><span class="p">:</span><span class="n">RMa</span><span class="p">,</span><span class="s1">&#39;TMa&#39;</span><span class="p">:</span><span class="n">TMa</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Christian Reinicke, Kees Wapenaar, and Evert Slob.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.2.
    </div>
  </body>
</html>