
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Layered_NRM_k1_w &#8212; Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</title>
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Layered_NRM_k1_w</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Routines for modelling wavefields in 1.5D non-reciprocal media.</span>

<span class="sd">.. module:: Wavefield_NRM_k1_w</span>

<span class="sd">:Authors:</span>
<span class="sd">    Christian Reinicke (c.reinicke@tudelft.nl), Kees Wapenaar (), and Evert Slob ()</span>
<span class="sd">    </span>
<span class="sd">:Copyright:</span>
<span class="sd">    Christian Reinicke (c.reinicke@tudelft.nl), Kees Wapenaar (), and Evert Slob ()</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">Wavefield_NRM_k1_w</span> <span class="k">import</span> <span class="n">Wavefield_NRM_k1_w</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>

<div class="viewcode-block" id="Layered_NRM_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w">[docs]</a><span class="k">class</span> <span class="nc">Layered_NRM_k1_w</span><span class="p">(</span><span class="n">Wavefield_NRM_k1_w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;is a class to model wavefields in 1.5D (non-)reciprocal media in the horizontal-wavenumber frequency domain.</span>
<span class="sd">        </span>
<span class="sd">    The class Layered_NRM_k1_w defines a 1.5D (non-)reciprocal medium and a scalar wavefield. We consider all horizontal-wavenumbers and all frequencies, that are sampled by the given number of samples and by the given sample intervals, in space (&#39;nr&#39;, &#39;dx1&#39;) as well as in time (&#39;nt&#39;, &#39;dt&#39;).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of time samples.</span>
<span class="sd">    </span>
<span class="sd">    dt : int, float</span>
<span class="sd">        Time sample interval in seconds.</span>
<span class="sd">        </span>
<span class="sd">    nr : int</span>
<span class="sd">        Number of space samples.</span>
<span class="sd">    </span>
<span class="sd">    dx1 : int, float</span>
<span class="sd">        Space sample interval in metres.</span>
<span class="sd">        </span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Set &#39;verbose=True&#39; to receive feedback in the command line.</span>
<span class="sd">        </span>
<span class="sd">    eps : int, float, optional</span>
<span class="sd">        A real-valued scalar can be assigned to &#39;eps&#39; to reduce the wrap-around effect of wavefields in the time domain. If the inverse Fourier transform is defined as,</span>
<span class="sd">            :math:`f(t)  = \int F(\omega) \; \mathrm{e}^{\mathrm{j} \omega t} \mathrm{d}\omega`,</span>
<span class="sd">        which is ensured if the function **K1W2X1T** is used, &#39;eps&#39;(:math:`=\epsilon`) should be positive to the suppress wrap-around effect from positive to negative time,</span>
<span class="sd">            :math:`f(t) \mathrm{e}^{- \epsilon t} = \int F(\omega + \mathrm{j} \epsilon) \; \mathrm{e}^{\mathrm{j} (\omega + \mathrm{j} \epsilon) t} \mathrm{d}\omega`.</span>
<span class="sd">        Recommended value eps = :math:`\\frac{3 nf}{dt}`.</span>
<span class="sd">        </span>
<span class="sd">    x3vec : numpy.ndarray</span>
<span class="sd">        Vertical spatial vector :math:`x_3`, for n layers &#39;x3vec&#39; must have the shape (n,). We define the :math:`x_3`-axis as downward-pointing. Implicitly, the first value on the :math:`x_3`-axis is zero (not stored in &#39;x3vec&#39;).</span>
<span class="sd">    </span>
<span class="sd">    avec : numpy.ndarray</span>
<span class="sd">        Medium parameter :math:`\\alpha` (real-valued), for n layers &#39;avec&#39; must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">    bvec : numpy.ndarray</span>
<span class="sd">        Medium parameter :math:`\\beta` (real-valued), for n layers &#39;bvec&#39; must have the shape (n,).</span>
<span class="sd">    </span>
<span class="sd">    g1vec : numpy.ndarray, optional</span>
<span class="sd">        Medium parameter :math:`\gamma_1` (real-valued for non-reciprocal media or imaginary-valued for reciprocal media), for n layers &#39;g1vec&#39; must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">    g3vec : numpy.ndarray, optional</span>
<span class="sd">        Medium parameter :math:`\gamma_3` (real-valued for non-reciprocal media or imaginary-valued for reciprocal media), for n layers &#39;g3vec&#39; must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">    ReciprocalMedium : bool, optional</span>
<span class="sd">        For non-reciprocal media set &#39;ReciprocalMedium=False&#39;, for reciprocal media set &#39;ReciprocalMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">    AdjointMedium : bool, optional</span>
<span class="sd">        Set &#39;AdjointMedium=True&#39; to compute scattering coefficients and propagators in an adjoint medium :math:`^{(a)}`. For reciprocal media, the scattering coefficients and propagators are identical in a medium and its adjoint. We have defined the scattering and propagation in the adjoint medium only for flux-normalisation.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    class</span>
<span class="sd">        A class to model a wavefield in a 1.5D non-reciprocal medium in the horizontal-wavenumber frequency domain. The following instances are defined:</span>
<span class="sd">            - **x3vec**: :math:`x_3`.</span>
<span class="sd">            - **avec**: :math:`\\alpha`.</span>
<span class="sd">            - **bvec**: :math:`\\beta`.</span>
<span class="sd">            - **g1vec**: :math:`\gamma_1`.</span>
<span class="sd">            - **g3vec**: :math:`\gamma_3`.</span>
<span class="sd">            - **ReciprocalMedium**: True for reciprocal media, False for non-reciprocal media.</span>
<span class="sd">            - **AdjointMedium**: If True, propagation and scatteing are defined in a medium and in its adjoint.</span>
<span class="sd">            - **k3**: Vertical-wavenumber for positive &#39;k1&#39;.</span>
<span class="sd">            - **k3n**: Vertical-wavenumber for negative &#39;k1&#39;.</span>
<span class="sd">            </span>
<span class="sd">    </span>
<span class="sd">    .. todo:: </span>
<span class="sd">        </span>
<span class="sd">        (1) In non-reciprocal media, when I use a complex-valued frequency </span>
<span class="sd">        :math:`\omega&#39;=\omega+\mathrm{j}\epsilon` the vertical wavenumber </span>
<span class="sd">        definition becomes </span>
<span class="sd">    </span>
<span class="sd">                :math:`k_3=\sqrt{(\\alpha \\beta -\gamma_1^2)\omega&#39; </span>
<span class="sd">                + 2\gamma_1 k_1 \omega&#39; -k_1^2} = </span>
<span class="sd">                \sqrt{(\\alpha \\beta - \gamma_1^2) (\omega -\epsilon^2) </span>
<span class="sd">                + 2\gamma_1 k_1 \omega -k_1^2 </span>
<span class="sd">                + \mathrm{j} 2 \epsilon </span>
<span class="sd">                [\omega (\\alpha \\beta -\gamma_1^2) + \gamma_1 k_1]}` .</span>
<span class="sd">        </span>
<span class="sd">            Hence, if </span>
<span class="sd">              </span>
<span class="sd">                :math:`\mathrm{sign}(\epsilon </span>
<span class="sd">                [\omega (\\alpha \\beta -\gamma_1^2) + \gamma_1 k_1]) &lt; 0`, </span>
<span class="sd">              </span>
<span class="sd">            the imaginary part of :math:`k_3` becomes negative, and the </span>
<span class="sd">            wavefield components :math:`\mathrm{e}^{\mathrm{j}k_3 x_3}` become </span>
<span class="sd">            unstable. I fix that by manually modifying the vertical wavenumber </span>
<span class="sd">            to </span>
<span class="sd">    </span>
<span class="sd">                :math:`k_{3,mod} = \sqrt{(\\alpha \\beta -\gamma_1^2) </span>
<span class="sd">                (\omega - \epsilon^2) + 2\gamma_1 k_1 \omega -k_1^2 </span>
<span class="sd">                + \mathrm{j} 2 \Vert \epsilon </span>
<span class="sd">                [\omega (\\alpha \\beta -\gamma_1^2) + \gamma_1 k_1] \Vert}` .</span>
<span class="sd">    </span>
<span class="sd">            For those :math:`\omega`-:math:`k_1` components for which the </span>
<span class="sd">            absolute value in :math:`k_{3,mod}` has an effect, I effectively </span>
<span class="sd">            change the sign of :math:`\epsilon`. Can we justify this fix? If </span>
<span class="sd">            not, it might be better to simply exclude those </span>
<span class="sd">            :math:`\omega`-:math:`k_1` components from the computation.</span>
<span class="sd">            </span>
<span class="sd">            In addition, the absolute value in :math:`k_{3,mod}` implies that </span>
<span class="sd">            :math:`\epsilon` should be positive. Hence, when applying an </span>
<span class="sd">            inverse Fourier transform to the time domain, one has to choose </span>
<span class="sd">            the convention, </span>
<span class="sd">            </span>
<span class="sd">                :math:`f(t)  = \int F(\omega) \; </span>
<span class="sd">                \mathrm{e}^{\mathrm{j} \omega t} \mathrm{d}\omega`.</span>
<span class="sd">            </span>
<span class="sd">            This can be done by complex-conjugating the modelled wavefield </span>
<span class="sd">            before applying the inverse Fourier transform. Note that the </span>
<span class="sd">            default settings of the 2D inverse Fourier transform function </span>
<span class="sd">            **K1W2X1T** handle all these sign choices correctly as long as </span>
<span class="sd">            :math:`\epsilon &gt;0`.</span>
<span class="sd">            </span>
<span class="sd">        (2) In reciprocal media, for Im(:math:`\gamma_i`) :math:`\\neq 0`, </span>
<span class="sd">        energy conservation does not hold for evanescent waves.</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    </span>
<span class="sd">    - We format the data as described below.</span>
<span class="sd">        - Wavefields are saved in an array of dimensions (nf,nr) in the frequency domain and (nt,nr) in the time domain.</span>
<span class="sd">        - Wavefields are in the :math:`k_1`-:math:`\omega` domain.</span>
<span class="sd">            - The zero frequency component is placed at the first index position of the first dimension.</span>
<span class="sd">            - The zero horizontal-wavenumber component is placed at the first index position of the second dimension.</span>
<span class="sd">        - If the wavefield is transformed to the space-time domain: </span>
<span class="sd">            - The zero time component is placed at the first index position of the first dimension, followed by nt/2-1 positive time samples and nt/2 negative time samples. </span>
<span class="sd">            - The zero offset component is placed at the first index position of the second dimension, followed by nr/2-1 positive offset samples and nr/2 negative offset samples.</span>
<span class="sd">        - For evanescent waves, Kees makes a sign choice for the vertical-wavenumber,</span>
<span class="sd">        \t:math:`k_3&#39; = -j \sqrt{k_1^2 - \omega^2 (\\alpha \\beta + \gamma_1^2 + \gamma_3^2)}`.</span>
<span class="sd">        - By default, **NumPy** makes the oppostie sign choice, </span>
<span class="sd">        \t:math:`k_3&#39; = +j \sqrt{k_1^2 - \omega^2 (\\alpha \\beta + \gamma_1^2 + \gamma_3^2)}`.</span>
<span class="sd">        - For convenience, we stick to **NumPy**&#39;s sign choice. Thus, we will also adapt the sign choice for the propagators,</span>
<span class="sd">              - Kees chose: :math:`\\tilde{w}^{\pm} = \mathrm{exp}(-j k_3&#39; \Delta x_3)`.</span>
<span class="sd">              - We choose: :math:`\\tilde{w}^{\pm} = \mathrm{exp}(+j k_3&#39; \Delta x_3)`.</span>
<span class="sd">        </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    Kees document as soon as it is published.</span>
<span class="sd">    </span>
<span class="sd">     </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # Initialise wavefield in a layered non-reciprocal medium</span>
<span class="sd">    &gt;&gt;&gt; F=LM(nt=1024, dt=0.005, nr=512, dx1=12.5 , </span>
<span class="sd">    &gt;&gt;&gt;      x3vec=np.array([1.1,2.2,3.7]), avec=np.array([1,2,3])*1e-3, </span>
<span class="sd">    &gt;&gt;&gt;      bvec=np.array([1.4,3.14,2])*1e-4, </span>
<span class="sd">    &gt;&gt;&gt;      g1vec=1j*np.array([0.8,2,1.3])*1e-4, </span>
<span class="sd">    &gt;&gt;&gt;      g3vec=1j*np.array([1.8,0.7,2.3])*1e-4, </span>
<span class="sd">    &gt;&gt;&gt;      ReciprocalMedium=True)  </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # Get a meshgrid of the vertical-wavenumber</span>
<span class="sd">    &gt;&gt;&gt; F.K3.shape</span>
<span class="sd">    (513, 512, 3)</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # Get the vertical-wavenumber for omega=delta omega,  and k1=0</span>
<span class="sd">    &gt;&gt;&gt; F.K3[1,0,0]</span>
<span class="sd">    (0.0003903913295999063+0j)</span>
<span class="sd">    </span>
<span class="sd">    **Wavefield Quantities**</span>
<span class="sd">    (Do not change the table!)</span>
<span class="sd">    </span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    |                           | *TE*               | *TM*               | *Ac. (fluid)* | *SH (solid)*       |</span>
<span class="sd">    +===========================+====================+====================+===============+====================+</span>
<span class="sd">    | **P**                     | :math:`E_2`        | :math:`H_2`        | :math:`p`     | :math:`v_2`        |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{Q}_1`      | :math:`H_3`        | :math:`-E_3`       | :math:`v_1`   | :math:`-\\tau_{21}` |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{Q}_3`      | :math:`-H_1`       | :math:`E_1`        | :math:`v_3`   | :math:`-\\tau_{23}` |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{\\alpha}`   | :math:`\epsilon`   | :math:`\mu`        | :math:`\kappa`| :math:`\\rho`       |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{\\beta}`    | :math:`\mu`        | :math:`\epsilon`   | :math:`\\rho`  | :math:`1/\mu`      |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{\gamma}_1` | :math:`\\xi_{23}`   | :math:`-\zeta_{23}`| :math:`d_1`   | :math:`e_1`        |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{\gamma}_3` | :math:`-\\xi_{21}`  | :math:`\zeta_{21}` | :math:`d_3`   | :math:`e_3`        |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{\delta}_1` | :math:`\zeta_{32}` | :math:`-\\xi_{32}`  | :math:`e_1`   | :math:`d_1`        |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{\delta}_3` | :math:`-\zeta_{12}`| :math:`\\xi_{12}`   | :math:`e_3`   | :math:`d_3`        |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{B}`        | :math:`-J_2^e`     | :math:`-J_2^m`     | :math:`q`     | :math:`f_2`        |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{C}_1`      | :math:`-J_3^m`     | :math:`J_3^e`      | :math:`f_1`   | :math:`2h_{21}`    |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>
<span class="sd">    | :math:`\mathbf{C}_3`      | :math:`J_1^m`      | :math:`-J_1^e`     | :math:`f_3`   | :math:`2h_{23}`    |</span>
<span class="sd">    +---------------------------+--------------------+--------------------+---------------+--------------------+</span>

<span class="sd">    </span>

<span class="sd">   &quot;&quot;&quot;</span>    
  
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">nr</span><span class="p">,</span><span class="n">dx1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">avec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">bvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">g1vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">g3vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="n">ReciprocalMedium</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">AdjointMedium</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="c1"># Inherit __init__ from Wavefield_NRM_k1_w</span>
        <span class="n">Wavefield_NRM_k1_w</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">nr</span><span class="p">,</span><span class="n">dx1</span><span class="p">,</span><span class="n">verbose</span><span class="p">,</span><span class="n">eps</span><span class="p">)</span>
        
        <span class="c1"># Check if medium parameters are passed as arrays</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g1vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g3vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: x3vec, avec, bvec, g1vec and g3vec have to be of the type numpy.ndarray.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Set gamma_1 and gamma_3 by default equal to zero</span>
        <span class="k">if</span> <span class="n">g1vec</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">avec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">g3vec</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">avec</span><span class="p">)</span>
            
        <span class="c1"># Force the medium parameters to have identical shape</span>
        <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">avec</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">bvec</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">g1vec</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">shape</span><span class="o">!=</span><span class="n">g3vec</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: x3vec, avec, bvec, g1vec and g3vec have to be of identical shape.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Force the medium parameters to be 1-dimensional, i.e. e.g. avec.shape=(n,)</span>
        <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: x3vec.ndim, avec.ndim, bvec.ndim, g1vec.ndim and g3vec.ndim must be one.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if x3vec is positive and constantly increasing</span>
        <span class="k">if</span> <span class="n">x3vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">x3vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: x3vec must only contain constantly increasing values greater than, or equal to zero.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if Medium choices are bools</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ReciprocalMedium</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">AdjointMedium</span><span class="p">,</span><span class="nb">bool</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: </span><span class="se">\&#39;</span><span class="s1">ReciprocalMedium</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">AdjointMedium</span><span class="se">\&#39;</span><span class="s1"> must be of the type bool.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if medium parameters correspond to a lossless (non-)reciprocal medium</span>
        <span class="k">if</span> <span class="n">ReciprocalMedium</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">avec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">bvec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">g1vec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">g3vec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: In lossless non-reciprocal media the imaginary value of avec, bvec, g1vec and g3vec has to be zero.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ReciprocalMedium</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">avec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">bvec</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">g1vec</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">g3vec</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Layered_NRM_k1_w: In lossless reciprocal media the imaginary value of avec and bvec has to be zero, the real value of g1vec and g3vec has to be zero.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Set medium parameters </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span> <span class="o">=</span> <span class="n">x3vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avec</span> <span class="o">=</span> <span class="n">avec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bvec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span> <span class="o">=</span> <span class="n">g1vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span> <span class="o">=</span> <span class="n">g3vec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="o">=</span> <span class="n">ReciprocalMedium</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="o">=</span> <span class="n">AdjointMedium</span>
        
        <span class="c1"># Calculate vertical ray-parameter p3=p3(+p1) p3n=p3(-p1) </span>
        <span class="c1"># Note: By default python uses opposite sign convention for evanescent waves as Kees: (-1)**0.5=1j</span>
        <span class="n">K3</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">K3n</span> <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">W</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
        <span class="n">K1</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;K1gridfft&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bvec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">K3n</span> <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bvec</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span>  <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span>
                    <span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span>
                    
            <span class="c1"># This is a manual fix to avoid exponential growth of the wavefield</span>
            <span class="c1"># I believe this fix sign-inverts epsilon for the unstable</span>
            <span class="c1"># w-k1 components. I am not sure if that is a problem. </span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    
                    <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span>  <span class="o">=</span> <span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>  <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
                    <span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
                    
        <span class="bp">self</span><span class="o">.</span><span class="n">K3</span>  <span class="o">=</span> <span class="n">K3</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K3n</span> <span class="o">=</span> <span class="n">K3n</span><span class="o">**</span><span class="mf">0.5</span>
        
    <span class="c1"># The initial fk mask function was mathematically more elegant but very </span>
    <span class="c1"># very slow and unflexible. Therefore, I replaced it.</span>
<span class="c1">#    def FK1_mask_k1_w(self,RelativeTaperLength=2**(-5),wmax=None):</span>
<span class="c1">#        &quot;&quot;&quot;returns a mask that mutes evanescent waves in the :math:`k_1`-:math:`\omega` domain.</span>
<span class="c1">#        </span>
<span class="c1">#        Parameters</span>
<span class="c1">#        ----------</span>
<span class="c1">#            </span>
<span class="c1">#        RelativeTaperLength : int, float, optional</span>
<span class="c1">#            The product of \&#39;RelativeTaperLength\&#39; and the number of spatial samples \&#39;nr\&#39; determines the taper length. The default value is \&#39;RelativeTaperLength\&#39;:math:`=2^{-5}.`</span>
<span class="c1">#            </span>
<span class="c1">#        wmax : int, float, complex, optional</span>
<span class="c1">#            Cut-off frequency :math:`\omega_{\mathrm{max}}` in :math:`s^{-1}`.</span>
<span class="c1">#            </span>
<span class="c1">#        Returns</span>
<span class="c1">#        -------</span>
<span class="c1">#        </span>
<span class="c1">#        dict</span>
<span class="c1">#            A dictionary that contains the ,</span>
<span class="c1">#                - **FK**: Sharp-edged :math:`\omega`-:math:`k_1` mask, mutes the evanescent wavefield in each layer indivually. Shape (nf,nr,n).</span>
<span class="c1">#                - **FK_global**: Sharp-edged :math:`\omega`-:math:`k_1` mask, mutes the evanescent wavefield in the entire model. Shape (nf,nr).</span>
<span class="c1">#                - **FK_tap**: Tapered :math:`\omega`-:math:`k_1` mask, mutes the evanescent wavefield in each layer indivually. Shape (nf,nr,n).</span>
<span class="c1">#                - **FK_global_tap**: Tapered :math:`\omega`-:math:`k_1` mask, mutes the evanescent wavefield in the entire model. Shape (nf,nr).</span>
<span class="c1">#                - **FKn**: Sharp-edged :math:`\omega`-:math:`k_1` mask, mutes the evanescent wavefield in each layer indivually (for sign-inverted :math:`k_1`). Shape (nf,nr,n).</span>
<span class="c1">#                - **FKn_global**: Sharp-edged :math:`\omega`-:math:`k_1` mask, mutes the evanescent wavefield in the entire model (for sign-inverted :math:`k_1`). Shape (nf,nr).</span>
<span class="c1">#                - **FKn_tap**: Tapered :math:`\omega`-:math:`k_1` mask, mutes the evanescent wavefield in each layer indivually (for sign-inverted :math:`k_1`). Shape (nf,nr,n).</span>
<span class="c1">#                - **FKn_global_tap**: Tapered :math:`\omega`-:math:`k_1` mask, mutes the evanescent wavefield in the entire model (for sign-inverted :math:`k_1`). Shape (nf,nr).</span>
<span class="c1">#                - **taperlen**: Taper length in number of samples.</span>
<span class="c1">#            All masks are stored as complex valued arrays because they will be applied to complex-valued arrays.</span>
<span class="c1">#            </span>
<span class="c1">#        Examples</span>
<span class="c1">#        --------</span>
<span class="c1">#        </span>
<span class="c1">#        &gt;&gt;&gt; # Initialise wavefield</span>
<span class="c1">#        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="c1">#        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="c1">#        &gt;&gt;&gt;      avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="c1">#        &gt;&gt;&gt;      g1vec=1j*np.array([0.8,2,1.3])*1e-4,</span>
<span class="c1">#        &gt;&gt;&gt;      g3vec=1j*np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="c1">#        &gt;&gt;&gt;      ReciprocalMedium=True)</span>
<span class="c1">#        </span>
<span class="c1">#        &gt;&gt;&gt; # Create fk mask with a cut-off frequency at 200 1/s</span>
<span class="c1">#        &gt;&gt;&gt; Mask=F.FK1_mask_k1_w(wmax=200)</span>
<span class="c1">#        &gt;&gt;&gt; Tapered_fk_mask = Mask[&#39;FK_tap&#39;]</span>
<span class="c1">#        </span>
<span class="c1">#        .. todo::</span>
<span class="c1">#        </span>
<span class="c1">#        Tapering of the edge of the :math:`\omega`-:math:`k_1` mask is done by </span>
<span class="c1">#        matrix-matrix multiplication (numpy.dot) with a smoothing matrix *S*. </span>
<span class="c1">#        This operation is very inefficient, and needs to be opimised.</span>
<span class="c1">#        </span>
<span class="c1">#            </span>
<span class="c1">#        &quot;&quot;&quot;</span>
<span class="c1">#        # Check if RelativeTaperLength is a float or an int</span>
<span class="c1">#        if not ( isinstance(RelativeTaperLength,int) </span>
<span class="c1">#              or isinstance(RelativeTaperLength,float) ):</span>
<span class="c1">#            sys.exit(&#39;FK1_mask_k1_w: \&#39;RelativeTaperLength\&#39; must be of the type int or float.&#39;)</span>
<span class="c1">#            </span>
<span class="c1">#        # Check that RelativeTaperLength is not smaller than zero</span>
<span class="c1">#        if RelativeTaperLength &lt; 0:</span>
<span class="c1">#            sys.exit(&#39;FK1_mask_k1_w: \&#39;RelativeTaperLength\&#39; must be greater than, or equal to zero.&#39;)</span>
<span class="c1">#            </span>
<span class="c1">#        # Check if wmax is a float or an int or a complex</span>
<span class="c1">#        if wmax is not None:</span>
<span class="c1">#            if not ( isinstance(wmax,int) </span>
<span class="c1">#                  or isinstance(wmax,float) </span>
<span class="c1">#                  or isinstance(wmax,complex)):</span>
<span class="c1">#                sys.exit(&#39;FK1_mask_k1_w: \&#39;wmax\&#39; must be of the type int, float or complex.&#39;)</span>
<span class="c1">#       </span>
<span class="c1">#            # Check that wmax is not smaller than zero</span>
<span class="c1">#            if wmax.real &lt; 0:</span>
<span class="c1">#                sys.exit(&#39;FK1_mask_k1_w: \&#39;wmax\&#39; must be greater than, or equal to zero.&#39;)</span>
<span class="c1">#            </span>
<span class="c1">#        # Sharp-edged FK mask</span>
<span class="c1">#        FK  = np.ones((self.nf,self.nr,self.x3vec.size),dtype=complex)</span>
<span class="c1">#        FKn = np.ones((self.nf,self.nr,self.x3vec.size),dtype=complex)</span>
<span class="c1">#        </span>
<span class="c1">#        # For complex-valued frequencies:</span>
<span class="c1">#        if self.eps is not None:</span>
<span class="c1">#            # Compute K3 without adding an imaginary constant</span>
<span class="c1">#            # Hence we have to subtract epsilon from the frequencies</span>
<span class="c1">#            K3  = np.zeros((self.nf,self.nr,self.x3vec.size),dtype=complex)</span>
<span class="c1">#            K3n = K3.copy()</span>
<span class="c1">#            W   = self.W_K1_grid()[&#39;Wgrid&#39;] - 1j*self.eps</span>
<span class="c1">#            K1  = self.W_K1_grid()[&#39;K1gridfft&#39;]</span>
<span class="c1">#            if self.ReciprocalMedium is True:</span>
<span class="c1">#                tmp = self.avec*self.bvec + self.g1vec**2 + self.g3vec**2</span>
<span class="c1">#                for layer in range(self.x3vec.size):</span>
<span class="c1">#                    K3[:,:,layer] = tmp[layer]*W**2 - K1**2</span>
<span class="c1">#                K3n = K3.copy()</span>
<span class="c1">#            elif self.ReciprocalMedium is False:</span>
<span class="c1">#                tmp = self.avec*self.bvec - self.g1vec**2</span>
<span class="c1">#                for layer in range(self.x3vec.size):</span>
<span class="c1">#                    K3[:,:,layer]  = tmp[layer]*W**2 + 2*self.g1vec[layer]*K1*W - K1**2</span>
<span class="c1">#                    K3n[:,:,layer] = tmp[layer]*W**2 - 2*self.g1vec[layer]*K1*W - K1**2</span>
<span class="c1">#            K3  = K3**0.5</span>
<span class="c1">#            K3n = K3n**0.5</span>
<span class="c1">#            </span>
<span class="c1">#        # For real-valued frequencies:</span>
<span class="c1">#        else:</span>
<span class="c1">#            K3 = self.K3</span>
<span class="c1">#            K3n = self.K3n</span>
<span class="c1">#            </span>
<span class="c1">#        FK[K3.imag   != 0] = 0</span>
<span class="c1">#        FKn[K3n.imag != 0] = 0</span>
<span class="c1">#        FK_global  = np.prod(FK,-1)</span>
<span class="c1">#        FKn_global = np.prod(FKn,-1)</span>
<span class="c1">#        </span>
<span class="c1">#        # Tapered FK mask: Cosine taper</span>
<span class="c1">#        taperlen = int(RelativeTaperLength*self.nr)</span>
<span class="c1">#        if taperlen != 0:</span>
<span class="c1">#            </span>
<span class="c1">#            # Construct matrix to smooth sharp edges along the k1 dimension</span>
<span class="c1">#            S   = np.zeros((self.nr,self.nr),dtype=complex)</span>
<span class="c1">#            tap = (        np.cos(np.linspace(-np.pi/2,0,taperlen))</span>
<span class="c1">#                   /np.sum(np.cos(np.linspace(-np.pi/2,0,taperlen))) )</span>
<span class="c1">#                   </span>
<span class="c1">#            # Smooth positive k1 values</span>
<span class="c1">#            col = np.zeros(self.nr)</span>
<span class="c1">#            col[:taperlen]=tap</span>
<span class="c1">#            for i in range(self.nk-1):</span>
<span class="c1">#                S[:,i]=np.roll(col,i)</span>
<span class="c1">#                </span>
<span class="c1">#            # Smooth negative k1 values</span>
<span class="c1">#            col = np.zeros(self.nr)</span>
<span class="c1">#            col[0] = tap[0]</span>
<span class="c1">#            col[-taperlen+1:] = tap[-1:0:-1]</span>
<span class="c1">#            for i in range(self.nk-1,self.nr):</span>
<span class="c1">#                S[:,i]=np.roll(col,i)</span>
<span class="c1">#        </span>
<span class="c1">#            # Apply Smooth matrix to the sharp-edged FK mask   </span>
<span class="c1">#            FK_tap  = np.ones((self.nf,self.nr,self.x3vec.size),</span>
<span class="c1">#                                  dtype=complex)</span>
<span class="c1">#            FKn_tap = np.ones((self.nf,self.nr,self.x3vec.size),</span>
<span class="c1">#                                  dtype=complex)</span>
<span class="c1">#            for layer in range(self.x3vec.size):</span>
<span class="c1">#                FK_tap[:,:,layer]  = ( FK[:,:,layer]</span>
<span class="c1">#                                      *FK[:,:,layer].dot(S))</span>
<span class="c1">#                FKn_tap[:,:,layer] = ( FKn[:,:,layer]</span>
<span class="c1">#                                      *FKn[:,:,layer].dot(S))</span>
<span class="c1">#                FK_global_tap  = FK_global.dot(S)</span>
<span class="c1">#                FKn_global_tap = FKn_global.dot(S)</span>
<span class="c1">#        else:</span>
<span class="c1">#            FK_tap  = FK.copy()</span>
<span class="c1">#            FKn_tap = FKn.copy()</span>
<span class="c1">#            FK_global_tap  = FK_global.copy()</span>
<span class="c1">#            FKn_global_tap = FKn_global.copy()</span>
<span class="c1">#        </span>
<span class="c1">#        # Mask to cut-off frequencies greater than wmax</span>
<span class="c1">#        if (wmax is not None) and (taperlen != 0):</span>
<span class="c1">#            ind = int(np.ceil(wmax.real/self.Dw()))</span>
<span class="c1">#            </span>
<span class="c1">#            if ind &gt; 0:</span>
<span class="c1">#                M   = np.ones((self.nf,self.nr,1),dtype=complex)</span>
<span class="c1">#                M[ind:,:,0] = 0</span>
<span class="c1">#                M = np.repeat(M,FK.shape[-1],axis=2)</span>
<span class="c1">#                FK         = M*FK</span>
<span class="c1">#                FK_global  = M[:,:,0] * FK_global</span>
<span class="c1">#                FKn        = M*FKn</span>
<span class="c1">#                FKn_global = M[:,:,0] * FKn_global</span>
<span class="c1">#                </span>
<span class="c1">#                if taperlen &lt; ind:</span>
<span class="c1">#                    M[ind-taperlen:ind,0,0] = (</span>
<span class="c1">#                        np.cos(np.linspace(0,np.pi/2,taperlen+1))[1:])</span>
<span class="c1">#                    M[:,:,0]   = np.repeat(M[:,:1,0],FK.shape[1],axis=1)</span>
<span class="c1">#                    M          = np.repeat(M[:,:,:1],FK.shape[2],axis=2)</span>
<span class="c1">#                FK_tap         = M*FK_tap</span>
<span class="c1">#                FK_global_tap  = M[:,:,0] * FK_global_tap</span>
<span class="c1">#                FKn_tap        = M*FKn_tap</span>
<span class="c1">#                FKn_global_tap = M[:,:,0] * FKn_global_tap</span>
<span class="c1">#            else:</span>
<span class="c1">#                FK        = 0*FK</span>
<span class="c1">#                FK_global = 0*FK_global</span>
<span class="c1">#                FK_tap        = 0*FK_tap</span>
<span class="c1">#                FK_global_tap = 0*FK_global_tap</span>
<span class="c1">#                </span>
<span class="c1">#                FKn        = 0*FKn</span>
<span class="c1">#                FKn_global = 0*FKn_global</span>
<span class="c1">#                FKn_tap        = 0*FKn_tap</span>
<span class="c1">#                FKn_global_tap = 0*FKn_global_tap</span>
<span class="c1">#        </span>
<span class="c1">#        out = {&#39;FK&#39;:FK,&#39;FK_global&#39;:FK_global,&#39;FK_tap&#39;:FK_tap,</span>
<span class="c1">#               &#39;FK_global_tap&#39;:FK_global_tap,</span>
<span class="c1">#               &#39;FKn&#39;:FKn,&#39;FKn_global&#39;:FKn_global,&#39;FKn_tap&#39;:FKn_tap,</span>
<span class="c1">#               &#39;FKn_global_tap&#39;:FKn_global_tap,&#39;taperlen&#39;:taperlen}</span>
<span class="c1">#        return out</span>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.FK1_mask_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.FK1_mask_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">FK1_mask_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">RelativeTaperLength</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">),</span><span class="n">wmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">Opening</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a mask that mutes evanescent waves in the :math:`k_1`-</span>
<span class="sd">        :math:`\omega` domain.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            </span>
<span class="sd">        RelativeTaperLength : int, float, optional</span>
<span class="sd">            The product of \&#39;RelativeTaperLength\&#39; and the number of temporal </span>
<span class="sd">            samples \&#39;nt\&#39; determines the taper length. The default value is </span>
<span class="sd">            \&#39;RelativeTaperLength\&#39;:math:`=2^{-5}.`</span>
<span class="sd">            </span>
<span class="sd">        wmax : int, float, complex, optional</span>
<span class="sd">            Cut-off frequency :math:`\omega_{\mathrm{max}}` in :math:`s^{-1}`.</span>
<span class="sd">            </span>
<span class="sd">        Opening : int, float, optional</span>
<span class="sd">            Factor, greater than zero, to widen or tighten the :math:`\omega`-</span>
<span class="sd">            :math:`k_1` mask. If equal to one, the opening corresponds to the </span>
<span class="sd">            transition from propagating to evanescent waves. </span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        </span>
<span class="sd">        dict</span>
<span class="sd">            A dictionary that contains the ,</span>
<span class="sd">                - **FK**: Sharp-edged :math:`\omega`-:math:`k_1` mask, mutes </span>
<span class="sd">                the evanescent wavefield in each layer indivually. Shape </span>
<span class="sd">                (nf,nr,n).</span>
<span class="sd">                </span>
<span class="sd">                - **FK_global**: Sharp-edged :math:`\omega`-:math:`k_1` mask, </span>
<span class="sd">                mutes the evanescent wavefield in the entire model. Shape </span>
<span class="sd">                (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">                - **FK_tap**: Tapered :math:`\omega`-:math:`k_1` mask, mutes </span>
<span class="sd">                the evanescent wavefield in each layer indivually. Shape </span>
<span class="sd">                (nf,nr,n).</span>
<span class="sd">                </span>
<span class="sd">                - **FK_global_tap**: Tapered :math:`\omega`-:math:`k_1` mask, </span>
<span class="sd">                mutes the evanescent wavefield in the entire model. Shape </span>
<span class="sd">                (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">                - **FKn**: Sharp-edged :math:`\omega`-:math:`k_1` mask, mutes </span>
<span class="sd">                the evanescent wavefield in each layer indivually (for sign-</span>
<span class="sd">                inverted :math:`k_1`). Shape (nf,nr,n).</span>
<span class="sd">                </span>
<span class="sd">                - **FKn_global**: Sharp-edged :math:`\omega`-:math:`k_1` mask, </span>
<span class="sd">                mutes the evanescent wavefield in the entire model (for sign-</span>
<span class="sd">                inverted :math:`k_1`). Shape (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">                - **FKn_tap**: Tapered :math:`\omega`-:math:`k_1` mask, mutes </span>
<span class="sd">                the evanescent wavefield in each layer indivually (for sign-</span>
<span class="sd">                inverted :math:`k_1`). Shape (nf,nr,n).</span>
<span class="sd">                </span>
<span class="sd">                - **FKn_global_tap**: Tapered :math:`\omega`-:math:`k_1` mask,</span>
<span class="sd">                mutes the evanescent wavefield in the entire model (for sign-</span>
<span class="sd">                inverted :math:`k_1`). Shape (nf,nr).</span>
<span class="sd">                </span>
<span class="sd">                - **taperlen**: Taper length in number of samples.</span>
<span class="sd">                </span>
<span class="sd">            All masks are stored as complex valued arrays because they will be </span>
<span class="sd">            applied to complex-valued arrays.</span>
<span class="sd">            </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise wavefield</span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">        &gt;&gt;&gt;      avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g1vec=1j*np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g3vec=1j*np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      ReciprocalMedium=True)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Create fk mask with a cut-off frequency at 200 1/s</span>
<span class="sd">        &gt;&gt;&gt; Mask=F.FK1_mask2_k1_w(wmax=200)</span>
<span class="sd">        &gt;&gt;&gt; Tapered_fk_mask = Mask[&#39;FK_tap&#39;]</span>
<span class="sd">        </span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if RelativeTaperLength is a float or an int</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">RelativeTaperLength</span><span class="se">\&#39;</span><span class="s1"> must be of the &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;type int or float.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check that RelativeTaperLength is not smaller than zero</span>
        <span class="k">if</span> <span class="n">RelativeTaperLength</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">RelativeTaperLength</span><span class="se">\&#39;</span><span class="s1"> must be greater &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;than, or equal to zero.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check if wmax is a float or an int or a complex</span>
        <span class="k">if</span> <span class="n">wmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wmax</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
                  <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wmax</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> 
                  <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wmax</span><span class="p">,</span><span class="nb">complex</span><span class="p">)):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">wmax</span><span class="se">\&#39;</span><span class="s1"> must be of the type int, &#39;</span>
                         <span class="o">+</span><span class="s1">&#39;float or complex.&#39;</span><span class="p">)</span>
       
            <span class="c1"># Check that wmax is not smaller than zero</span>
            <span class="k">if</span> <span class="n">wmax</span><span class="o">.</span><span class="n">real</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">wmax</span><span class="se">\&#39;</span><span class="s1"> must be greater than, or &#39;</span>
                         <span class="o">+</span><span class="s1">&#39;equal to zero.&#39;</span><span class="p">)</span>
                
        <span class="c1"># Check if Opening is a scalar</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Opening</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
              <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Opening</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">Opening</span><span class="se">\&#39;</span><span class="s1"> must be of the &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;type int or float.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check that Opening is not smaller than zero</span>
        <span class="k">if</span> <span class="n">Opening</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FK1_mask2_k1_w: </span><span class="se">\&#39;</span><span class="s1">Opening</span><span class="se">\&#39;</span><span class="s1"> must be greater &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;than, or equal to zero.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Help variable (k3 squared)</span>
        <span class="n">Q</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">Qn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            
        <span class="c1"># Sharp-edged FK mask</span>
        <span class="n">FK</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">FKn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Frequency and wavenumber meshgrid</span>
        <span class="n">W</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="n">K1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;K1gridfft&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bvec</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">Q</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">Opening</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">Qn</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bvec</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">Q</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span> <span class="n">Opening</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> 
                                 <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
                <span class="n">Qn</span><span class="p">[:,:,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">Opening</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">tmp</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="o">**</span><span class="mi">2</span> 
                                 <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span><span class="o">*</span><span class="n">K1</span><span class="o">*</span><span class="n">W</span> <span class="o">-</span> <span class="n">K1</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
                    
        <span class="n">FK</span><span class="p">[</span><span class="n">Q</span>   <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">FKn</span><span class="p">[</span><span class="n">Qn</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">FK_global</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">FK</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">FKn_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">FKn</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">FK_tap</span>         <span class="o">=</span> <span class="n">FK</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">FKn_tap</span>        <span class="o">=</span> <span class="n">FKn</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">FK_global_tap</span>  <span class="o">=</span> <span class="n">FK_global</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">FKn_global_tap</span> <span class="o">=</span> <span class="n">FKn_global</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Taper length</span>
        <span class="n">taperlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">RelativeTaperLength</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">taperlen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Define sine taper</span>
            <span class="c1"># If complex-valued frequencies are used they must be included in</span>
            <span class="c1"># the taper. Otherwise the amplitudes are falsified.</span>
            <span class="n">w</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Wvec</span><span class="p">()[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">def</span> <span class="nf">SineTaper</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
                <span class="n">w0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                <span class="n">tap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">taperlen</span><span class="p">]</span><span class="o">-</span><span class="n">w0</span><span class="p">)</span>
                              <span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">taperlen</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="p">)</span>
                              <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">tap</span><span class="o">**</span><span class="mi">2</span>
                        
            <span class="c1"># Define taper for each wavenumber</span>
            <span class="k">for</span> <span class="n">WavNum</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">):</span>
                
                <span class="c1"># FK_global</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FK_global</span><span class="p">[:,</span><span class="n">WavNum</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i1</span>  <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
                
                    <span class="k">if</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">taperlen</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">:</span>
                        <span class="n">FK_global_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="n">taperlen</span><span class="p">,</span><span class="n">WavNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                      
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">FK_global_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:,</span><span class="n">WavNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="n">i1</span><span class="p">]</span>
                   
                <span class="c1"># FKn_global</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FKn_global</span><span class="p">[:,</span><span class="n">WavNum</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i1</span>  <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
                
                    <span class="k">if</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">taperlen</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">:</span>
                        <span class="n">FKn_global_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="n">taperlen</span><span class="p">,</span><span class="n">WavNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                       
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">FKn_global_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:,</span><span class="n">WavNum</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="n">i1</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="c1"># FK</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FK</span><span class="p">[:,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">i1</span>  <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
                    
                        <span class="k">if</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">taperlen</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">:</span>
                            <span class="n">FK_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="n">taperlen</span><span class="p">,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                        
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">FK_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="n">i1</span><span class="p">]</span>
                            
                    <span class="c1"># FKn</span>
                    <span class="n">i1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">FKn</span><span class="p">[:,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">i1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">i1</span>  <span class="o">=</span> <span class="n">i1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    
                    
                        <span class="k">if</span> <span class="n">i1</span> <span class="o">+</span> <span class="n">taperlen</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">:</span>
                            <span class="n">FKn_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i1</span><span class="o">+</span><span class="n">taperlen</span><span class="p">,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)</span>
                        
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">FKn_tap</span><span class="p">[</span><span class="n">i1</span><span class="p">:,</span><span class="n">WavNum</span><span class="p">,</span><span class="n">layer</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i1</span><span class="p">)[:</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="o">-</span><span class="n">i1</span><span class="p">]</span>
        
        <span class="c1"># Mask to cut-off frequencies greater than wmax</span>
        <span class="k">if</span> <span class="n">wmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">wmax</span><span class="o">.</span><span class="n">real</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()))</span>
            
            <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">M</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">M</span><span class="p">[</span><span class="n">ind</span><span class="p">:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">FK</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">FK</span>         <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">FK</span>
                <span class="n">FK_global</span>  <span class="o">=</span> <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">FK_global</span>
                <span class="n">FKn</span>        <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">FKn</span>
                <span class="n">FKn_global</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">FKn_global</span>
                
                <span class="k">if</span> <span class="n">taperlen</span> <span class="o">&lt;</span> <span class="n">ind</span><span class="p">:</span>
                    <span class="n">M</span><span class="p">[</span><span class="n">ind</span><span class="o">-</span><span class="n">taperlen</span><span class="p">:</span><span class="n">ind</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">SineTaper</span><span class="p">(</span><span class="n">ind</span><span class="o">-</span><span class="n">taperlen</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>
                    <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">M</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">FK</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">M</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">M</span><span class="p">[:,:,:</span><span class="mi">1</span><span class="p">],</span><span class="n">FK</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">FK_tap</span>         <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">FK_tap</span>
                <span class="n">FK_global_tap</span>  <span class="o">=</span> <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">FK_global_tap</span>
                <span class="n">FKn_tap</span>        <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="n">FKn_tap</span>
                <span class="n">FKn_global_tap</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">FKn_global_tap</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">FK</span>        <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FK</span>
                <span class="n">FK_global</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FK_global</span>
                <span class="n">FK_tap</span>        <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FK_tap</span>
                <span class="n">FK_global_tap</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FK_global_tap</span>
                
                <span class="n">FKn</span>        <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FKn</span>
                <span class="n">FKn_global</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FKn_global</span>
                <span class="n">FKn_tap</span>        <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FKn_tap</span>
                <span class="n">FKn_global_tap</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">FKn_global_tap</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;FK&#39;</span><span class="p">:</span><span class="n">FK</span><span class="p">,</span><span class="s1">&#39;FK_global&#39;</span><span class="p">:</span><span class="n">FK_global</span><span class="p">,</span><span class="s1">&#39;FK_tap&#39;</span><span class="p">:</span><span class="n">FK_tap</span><span class="p">,</span>
               <span class="s1">&#39;FK_global_tap&#39;</span><span class="p">:</span><span class="n">FK_global_tap</span><span class="p">,</span>
               <span class="s1">&#39;FKn&#39;</span><span class="p">:</span><span class="n">FKn</span><span class="p">,</span><span class="s1">&#39;FKn_global&#39;</span><span class="p">:</span><span class="n">FKn_global</span><span class="p">,</span><span class="s1">&#39;FKn_tap&#39;</span><span class="p">:</span><span class="n">FKn_tap</span><span class="p">,</span>
               <span class="s1">&#39;FKn_global_tap&#39;</span><span class="p">:</span><span class="n">FKn_global_tap</span><span class="p">,</span><span class="s1">&#39;taperlen&#39;</span><span class="p">:</span><span class="n">taperlen</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
        
<div class="viewcode-block" id="Layered_NRM_k1_w.L_eigenvectors_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.L_eigenvectors_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">L_eigenvectors_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">beta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the eigenvector matrix &#39;L&#39; and its inverse &#39;Linv&#39;, either in flux- or in pressure-normalisation for the vertical-wavenumber &#39;K3&#39; inside a homogeneous layer. Here, the vertical-wavenumber is a meshgrid that contains all combinations of frequencies :math:`\omega` and horizontal-wavenumbers :math:`k_1`. If \&#39;AdjointMedium=True\&#39;, **L_eigenvectors_k1_w** also computes the eigenvector matrix in the adjoint medium &#39;La&#39; and its inverse &#39;Lainv&#39;. </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        beta : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta`  (real-valued).</span>
<span class="sd">        </span>
<span class="sd">        g3 : int, float</span>
<span class="sd">            Medium parameter :math:`\gamma_3`.</span>
<span class="sd">        </span>
<span class="sd">        K3 : numpy.ndarray</span>
<span class="sd">            Vertical-wavenumber :math:`k_3(+k_1)` for all frequencies :math:`\omega` and horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">        </span>
<span class="sd">        K3n : numpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Vertical-wavenumber :math:`k_3(-k_1)` for all frequencies :math:`\omega` and sign-inverted horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for flux-normalisation set normalisation=&#39;flux&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **L**: The eigenvector matrix.</span>
<span class="sd">                - **Linv**: The inverse of the eigenvector matrix.</span>
<span class="sd">                - **La**: The eigenvector matrix (adjoint medium).</span>
<span class="sd">                - **Lainv**: The inverse of the eigenvector matrix (adjoint medium).</span>
<span class="sd">            All eigenvector matrices are stored in a in a (nf,nr,2,2)-array. The first two dimensions correspond to all combinations of frequencies :math:`\omega` and horizontal-wavenumbers :math:`k_1`. The last two dimension are the actual eigenvector matrices for all :math:`\omega`-:math:`k_1` components.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            - The eigenvector matrix &#39;L&#39; and its inverse &#39;Linv&#39; are different for reciprocal and non-reciprocal media.</span>
<span class="sd">            - For reciprocal media, the eigenvectors of the adjoint medium are identical to the eigenvectors of the true medium.</span>
<span class="sd">            - We have defined the eigenvectors of the adjoint medium only for flux-normalisation.</span>
<span class="sd">            - At zero frequency (:math:`\omega=0 \;\mathrm{s}^{-1}`), the eigenvector matrices \&#39;L\&#39; and their inverse \&#39;Linv\&#39; contain elements with poles. For computational convenience, we set the poles equal to zero. However, the resulting zero frequency component of all outputs is meaningless.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise wavefield in a layered non-reciprocal medium</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">        &gt;&gt;&gt;      avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g1vec=1j*np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g3vec=1j*np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      ReciprocalMedium=True)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Compute eigenvectors in pressure-normalisation</span>
<span class="sd">        &gt;&gt;&gt; Leig=F.L_eigenvectors_k1_w(F.bvec[0],F.g3vec[0],</span>
<span class="sd">        &gt;&gt;&gt;                            F.K3[:,:,0],normalisation=&#39;pressure&#39;)</span>
<span class="sd">        &gt;&gt;&gt; L=Leig[&#39;L&#39;]</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # For pressure normalisation, the top-left element of L equals</span>
<span class="sd">        &gt;&gt;&gt; # 1 for all frequencies and all horizontal-wavenumbers</span>
<span class="sd">        &gt;&gt;&gt; L[101,200,0,0]</span>
<span class="sd">        (1+0j)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # For pressure normalisation, the bottom-left element of L does not</span>
<span class="sd">        &gt;&gt;&gt; # equal 1 for all frequencies and all horizontal-wavenumbers</span>
<span class="sd">        &gt;&gt;&gt; L[101,200,1,0]</span>
<span class="sd">        12.370632073930679j</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if required input variables are given</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">g3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">K3</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;L_eigenvectors_k1_w: The input variables </span><span class="se">\&#39;</span><span class="s1">beta</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">g3</span><span class="se">\&#39;</span><span class="s1"> and  </span><span class="se">\&#39;</span><span class="s1">K3</span><span class="se">\&#39;</span><span class="s1"> must be set.&#39;</span><span class="p">)</span>
         
        <span class="c1"># Check if normalisation is set correctly</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;L_eigenvectors_k1_w: The input variable </span><span class="se">\&#39;</span><span class="s1">normalisation</span><span class="se">\&#39;</span><span class="s1"> must be set, either to </span><span class="se">\&#39;</span><span class="s1">flux</span><span class="se">\&#39;</span><span class="s1">, or to </span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check if the vertical-wavenumber for a negative horizontal-wavenumber is given</span>
        <span class="k">if</span>  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">K3n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;L_eigenvectors_k1_w: The input variable </span><span class="se">\&#39;</span><span class="s1">K3n</span><span class="se">\&#39;</span><span class="s1"> (vertical-wavenumber K3 for a negative horizontal-wavenumber k1) must be given to compute the eigenvector matrix of the adjoint medium </span><span class="se">\&#39;</span><span class="s1">La</span><span class="se">\&#39;</span><span class="s1"> and its inverse</span><span class="se">\&#39;</span><span class="s1">Lainv</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Initialise L and Linv</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">Linv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">La</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Lainv</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Construct a vertical ray-parameter</span>
        <span class="c1"># Exclude poles at zero-frequency</span>
        <span class="n">Om</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
        <span class="n">P3</span>           <span class="o">=</span> <span class="n">K3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">P3</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>     <span class="o">=</span> <span class="n">K3</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">/</span><span class="n">Om</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
        <span class="n">P3</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>      <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Construct an inverse vertical ray-parameter</span>
        <span class="c1"># Exclude pole at zero frequency and zero horizontal-wavenumber</span>
        <span class="c1"># K3[0,0] = 0</span>
        <span class="c1"># P3[0,:] = 0</span>
        <span class="n">P3inv</span> <span class="o">=</span> <span class="n">P3</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">P3inv</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">Om</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">/</span><span class="n">K3</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The eigenvectors L and their inverse Linv have a pole at zero frequency. Here, &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;we set the zero frequency component of L and Linv to zero (which is wrong but &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;convenient for the computation).</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">):</span>
            <span class="c1"># L matrix</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">P3inv</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">fac</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">fac</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P3</span><span class="o">+</span><span class="n">g3</span><span class="p">)</span><span class="o">/</span><span class="n">beta</span><span class="o">*</span><span class="n">fac</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">P3</span><span class="o">-</span><span class="n">g3</span><span class="p">)</span><span class="o">/</span><span class="n">beta</span><span class="o">*</span><span class="n">fac</span>
            
            <span class="c1"># Inverse L matrix</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w (AdjointMedium is True) and (ReciprocalMedium is True)&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For reciprocal media, the eigenvector matrix of a medium and its adjoint medium &#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;are identical.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
               
                <span class="n">La</span> <span class="o">=</span> <span class="n">L</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">Lainv</span> <span class="o">=</span> <span class="n">Linv</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>            
            <span class="c1"># L matrix</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P3</span><span class="o">+</span><span class="n">g3</span><span class="p">)</span><span class="o">/</span><span class="n">beta</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">P3</span><span class="o">-</span><span class="n">g3</span><span class="p">)</span><span class="o">/</span><span class="n">beta</span>
            
            <span class="c1"># Inverse L matrix</span>
            <span class="n">fac</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">P3inv</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">fac</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">fac</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">fac</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">fac</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w (AdjointMedium is True) and (normalisation=</span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We have defined the eigenvector matrix of the adjoint medium </span><span class="se">\&#39;</span><span class="s1">La</span><span class="se">\&#39;</span><span class="s1"> and its &#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inverse </span><span class="se">\&#39;</span><span class="s1">Lainv</span><span class="se">\&#39;</span><span class="s1"> only for flux-normalisation.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">):</span>
            <span class="c1"># L matrix</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">P3inv</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P3</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
            
            <span class="c1"># Inverse L matrix</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w (AdjointMedium is True) and (ReciprocalMedium is False)&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For non-reciprocal media, the eigenvector matrix of a medium and its adjoint &#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;medium are different.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    
                <span class="c1"># Construct a vertical ray-parameter  for sign-inverted </span>
                <span class="c1"># horizontal-wavenumbers</span>
                <span class="c1"># Exclude poles at zero-frequency</span>
                <span class="n">Om</span>           <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
                <span class="n">P3n</span>           <span class="o">=</span> <span class="n">K3n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">P3n</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>     <span class="o">=</span> <span class="n">K3n</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">/</span><span class="n">Om</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
                <span class="n">P3n</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>      <span class="o">=</span> <span class="mi">0</span>
                
                <span class="c1"># Construct an inverse vertical ray-parameter  for sign-inverted </span>
                <span class="c1"># horizontal-wavenumbers</span>
                <span class="c1"># Exclude pole at zero frequency and zero horizontal-wavenumber</span>
                <span class="c1"># K3[0,0] = 0</span>
                <span class="c1"># P3[0,:] = 0</span>
                <span class="n">P3ninv</span> <span class="o">=</span> <span class="n">P3n</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">P3ninv</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">Om</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">/</span><span class="n">K3n</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span>
                
                <span class="c1"># L matrix (adjoint medium) = N Transpose( Inverse( L(-k1) )) N</span>
                <span class="n">La</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">La</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">P3ninv</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="n">La</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">La</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">La</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P3n</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="n">La</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">La</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">La</span> <span class="o">=</span> <span class="n">La</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
                
                <span class="c1">#  Inverse L matrix (adjoint medium) = N Transpose( L(-k1)) N</span>
                <span class="n">Lainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P3n</span><span class="o">/</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">P3ninv</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">Lainv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Lainv</span> <span class="o">=</span> <span class="n">Lainv</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span>
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="c1"># L matrix</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">P3</span><span class="o">/</span><span class="n">beta</span>
            <span class="n">L</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">P3</span><span class="o">/</span><span class="n">beta</span>
            
            <span class="c1"># Inverse L matrix</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">P3inv</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">Linv</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">beta</span><span class="o">*</span><span class="n">P3inv</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">Linv</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">L_eigenvectors_k1_w (AdjointMedium is True) and (normalisation=</span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------------------------------&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We have defined the eigenvector matrix of the adjoint medium </span><span class="se">\&#39;</span><span class="s1">La</span><span class="se">\&#39;</span><span class="s1"> and its &#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;inverse </span><span class="se">\&#39;</span><span class="s1">Lainv</span><span class="se">\&#39;</span><span class="s1"> only for flux-normalisation.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;L&#39;</span><span class="p">:</span><span class="n">L</span><span class="p">,</span><span class="s1">&#39;Linv&#39;</span><span class="p">:</span><span class="n">Linv</span><span class="p">,</span><span class="s1">&#39;La&#39;</span><span class="p">:</span><span class="n">La</span><span class="p">,</span><span class="s1">&#39;Lainv&#39;</span><span class="p">:</span><span class="n">Lainv</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
          
<div class="viewcode-block" id="Layered_NRM_k1_w.RT_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.RT_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">RT_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">beta_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g3_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3n_u</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">beta_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g3_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3n_l</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the scattering coefficients at an horizontal interface.</span>
<span class="sd">        </span>
<span class="sd">        The scattering coefficients can be computed either in flux- or in pressure-normalisation. The variables with subscript &#39;u&#39; refer to the medium parameters in the upper half-space, the variables with subscript &#39;l&#39; refer to the medium parameters in the lower half-space. The vertical-wavenumbers \&#39;K3\&#39;:math:`=k_3(k_1,\omega)` and \&#39;K3n\&#39;:math:`=k_3(-k_1,\omega)` are stored as :math:`k_1`-:math:`\omega` meshgirds to compute the scattering coefficients for all sampled frequencies and horizontal-wavenumbers in a vectorsied manner. Set \&#39;AdjointMedium=True\&#39; to compute the scattering coefficients also in the adjoint medium.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        beta_u : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta` (real-valued) (upper half-space).</span>
<span class="sd">        </span>
<span class="sd">        g3_u : int, float</span>
<span class="sd">            Medium parameter :math:`\gamma_3` (upper half-space).</span>
<span class="sd">        </span>
<span class="sd">        K3_u : numpy.ndarray</span>
<span class="sd">            Vertical-wavenumber :math:`k_{3,u}(+k_1)` for all frequencies :math:`\omega` and horizontal-wavenumbers :math:`k_1` (upper half-space).</span>
<span class="sd">        </span>
<span class="sd">        K3n_u : numpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Vertical-wavenumber :math:`k_{3,u}(-k_1)` for all frequencies :math:`\omega` and sign-inverted horizontal-wavenumbers :math:`k_1` (upper half-space).</span>
<span class="sd">            </span>
<span class="sd">        beta_l : int, float</span>
<span class="sd">            Medium parameter :math:`\\beta` (real-valued) (lower half-space).</span>
<span class="sd">        </span>
<span class="sd">        g3_l : int, float</span>
<span class="sd">            Medium parameter :math:`\gamma_3` (lower half-space).</span>
<span class="sd">        </span>
<span class="sd">        K3_l : numpy.ndarray</span>
<span class="sd">            Vertical-wavenumber :math:`k_{3,l}(+k_1)` for all frequencies :math:`\omega` and horizontal-wavenumbers :math:`k_1` (lower half-space).</span>
<span class="sd">        </span>
<span class="sd">        K3n_l : numpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Vertical-wavenumber :math:`k_{3,l}(-k_1)` for all frequencies :math:`\omega` and sign-inverted horizontal-wavenumbers :math:`k_1` (lower half-space).</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for flux-normalisation set normalisation=&#39;flux&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **rP**: Reflection coefficient from above.</span>
<span class="sd">                - **tP**: Transmission coefficient from above &#39;tP&#39;.</span>
<span class="sd">                - **rM**: Reflection coefficient from below.</span>
<span class="sd">                - **tM**: Transmission coefficient from below.</span>
<span class="sd">                - **rPa**: Reflection coefficient from above (adjoint medium).</span>
<span class="sd">                - **tPa**: Transmission coefficient from above (adjoint medium).</span>
<span class="sd">                - **rMa**: Reflection coefficient from below (adjoint medium).</span>
<span class="sd">                - **tMa**: Transmission coefficient from below (adjoint medium).</span>
<span class="sd">            All scattering coefficients are stored as arrays with the shape (nf,nr).</span>
<span class="sd">            </span>
<span class="sd">        .. todo:: </span>
<span class="sd">        </span>
<span class="sd">            (1) For :math:`k_1,\omega=(0,0)` there is a zero division in the </span>
<span class="sd">            computation of the scattering coefficients. I have fixed that, </span>
<span class="sd">            however, I believe that the fix is (mathmatically) wrong. Check that!</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">    </span>
<span class="sd">        - For reciprocal media, the scattering coefficients of the adjoint medium are identical to the scattering coefficients of the true medium.</span>
<span class="sd">        - We have defined the scattering coefficients of the adjoint medium only for flux-normalisation.</span>
<span class="sd">        </span>
<span class="sd">            </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">    </span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise wavefield F in a reciprocal medium </span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">        &gt;&gt;&gt;      avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g1vec=1j*np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g3vec=1j*np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      ReciprocalMedium=True)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Compute scattering coefficients at the first interface in flux</span>
<span class="sd">        &gt;&gt;&gt; # normalisation</span>
<span class="sd">        &gt;&gt;&gt; Scat=F.RT_k1_w(beta_u=F.bvec[0],g3_u=F.g3vec[0],K3_u=F.K3[:,:,0],</span>
<span class="sd">        &gt;&gt;&gt;                K3n_u=F.K3n[:,:,0],</span>
<span class="sd">        &gt;&gt;&gt;                beta_l=F.bvec[1],g3_l=F.g3vec[1],K3_l=F.K3[:,:,1],</span>
<span class="sd">        &gt;&gt;&gt;                K3n_l=F.K3n[:,:,1],normalisation=&#39;flux&#39;)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Read the scattering coeffcients, and </span>
<span class="sd">        &gt;&gt;&gt; tP = Scat[&#39;tP&#39;]</span>
<span class="sd">        &gt;&gt;&gt; rM = Scat[&#39;rM&#39;]</span>
<span class="sd">        &gt;&gt;&gt; rP = Scat[&#39;rP&#39;]</span>
<span class="sd">        &gt;&gt;&gt; tM = Scat[&#39;tM&#39;] </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; tP.shape</span>
<span class="sd">        (513, 512)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; np.linalg.norm(tP-tM)</span>
<span class="sd">        0.0</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if required input variables are given</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">beta_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">g3_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">K3_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> 
         <span class="ow">or</span> <span class="p">(</span><span class="n">beta_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">g3_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">K3_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_k1_w: The input variables </span><span class="se">\&#39;</span><span class="s1">beta_u</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">g3_u</span><span class="se">\&#39;</span><span class="s1">,  &#39;</span><span class="o">+</span>
                     <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">K3_u</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">beta_l</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">g3_l</span><span class="se">\&#39;</span><span class="s1">,  </span><span class="se">\&#39;</span><span class="s1">K3_l</span><span class="se">\&#39;</span><span class="s1"> must be set.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check if normalisation is set correctly</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_k1_w: The input variable </span><span class="se">\&#39;</span><span class="s1">normalisation</span><span class="se">\&#39;</span><span class="s1"> must be&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; set, either to </span><span class="se">\&#39;</span><span class="s1">flux</span><span class="se">\&#39;</span><span class="s1">, or to </span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Check if the vertical-wavenumber for a sign-inverted horizontal-</span>
        <span class="c1"># wavenumber is given</span>
        <span class="k">if</span>  <span class="p">(</span>    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> 
             <span class="ow">and</span> <span class="p">((</span><span class="n">K3n_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">K3n_l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">))</span> 
             <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> 
             <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_k1_w: The input variables </span><span class="se">\&#39;</span><span class="s1">K3n_u</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">K3n_l</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; (vertical-wavenumber :math:`k_3` for a sign-inverted&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; horizontal-wavenumber :math:`k_1`) must be set to&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; compute the scattering coefficients in the adjoint&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; medium </span><span class="se">\&#39;</span><span class="s1">rPa</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">tPa</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">rMa</span><span class="se">\&#39;</span><span class="s1"> and </span><span class="se">\&#39;</span><span class="s1">tMa</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Initialise scattering coefficients in adjoint medium    </span>
        <span class="n">rPa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tPa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rMa</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tMa</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="c1"># Frequency meshgrid</span>
        <span class="n">Om</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
        
        <span class="c1"># For zero frequency and zero horizontal-wavenumber we will encounter</span>
        <span class="c1"># divisions by zero. </span>
        <span class="c1"># To avoid this problem we modify the (w,k1)=(0,0) element of K3,</span>
        <span class="c1"># such that there is no division by zero, and such that the resulting</span>
        <span class="c1"># scattering coefficients are correct</span>
        <span class="c1"># The (w,k1)=(0,0) element of K3 is actually a ray-parameter P3</span>
        <span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">K3_u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span>
        <span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">K3_l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span>
        <span class="n">K3n_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">K3n_u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span>
        <span class="n">K3n_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">K3n_l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Dw</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">):</span>
            
            <span class="c1"># True medium</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">-</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">+</span> <span class="p">(</span><span class="n">K3_l</span><span class="o">+</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span>
            <span class="n">rP</span> <span class="o">=</span>  <span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">+</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="p">(</span><span class="n">K3_l</span><span class="o">+</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span> <span class="o">*</span> <span class="n">denom</span> 
            <span class="n">rM</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">-</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="p">(</span><span class="n">K3_l</span><span class="o">-</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">beta_l</span><span class="o">*</span><span class="n">K3_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="n">tP</span>
            
            <span class="c1"># Correct the zero frequency, zero horizontal-wavenumber component</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">+</span> <span class="p">(</span><span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span>
            <span class="n">rP</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="p">(</span><span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span> <span class="o">*</span> <span class="n">denom</span> 
            <span class="n">rM</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="p">(</span><span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tP</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">beta_l</span><span class="o">*</span><span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tM</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tP</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Adjoint medium</span>
                <span class="n">rPa</span> <span class="o">=</span> <span class="n">rP</span> 
                <span class="n">tPa</span> <span class="o">=</span> <span class="n">tP</span> 
                <span class="n">rMa</span> <span class="o">=</span> <span class="n">rM</span> 
                <span class="n">tMa</span> <span class="o">=</span> <span class="n">tM</span> 
    
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">RT_k1_w: (AdjointMedium is True) and (ReciprocalMedium is True)&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="mi">72</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For reciprocal media, the scattering coefficients in a medium and its adjoint medium are identical.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            
            <span class="c1"># True medium</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">-</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">+</span> <span class="p">(</span><span class="n">K3_l</span><span class="o">+</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span>
            <span class="n">rP</span> <span class="o">=</span>  <span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">+</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="p">(</span><span class="n">K3_l</span><span class="o">+</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">-</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="p">(</span><span class="n">K3_l</span><span class="o">-</span><span class="n">Om</span><span class="o">*</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3_u</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3_l</span><span class="o">*</span><span class="n">beta_u</span> <span class="o">*</span> <span class="n">denom</span>
            
            <span class="c1"># Correct the zero frequency, zero horizontal-wavenumber component</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">+</span> <span class="p">(</span><span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span>
            <span class="n">rP</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>  <span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="p">(</span><span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span> <span class="o">*</span> <span class="n">denom</span> 
            <span class="n">rM</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span> <span class="p">(</span><span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g3_u</span><span class="p">)</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="p">(</span><span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">g3_l</span><span class="p">)</span><span class="o">*</span><span class="n">beta_u</span> <span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tP</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3_u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tM</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3_l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">beta_u</span> <span class="o">*</span> <span class="n">denom</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">RT_k1_w: (AdjointMedium is True) and (normalisation=</span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="mi">72</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We have defined the scattering coefficients of the adjoint medium only for flux-normalisation.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;flux&#39;</span><span class="p">):</span>
            
            <span class="c1"># True medium (no need to coorect (w,k1)=(0,0) element)</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">+</span> <span class="n">K3_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span>
            <span class="n">rP</span> <span class="o">=</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="n">K3_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span> <span class="o">*</span><span class="n">denom</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">beta_l</span><span class="o">*</span><span class="n">K3_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="o">-</span><span class="n">rP</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="n">tP</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Adjoint medium (no need to coorect (w,k1)=(0,0) element)</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">K3n_u</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">+</span> <span class="n">K3n_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span>
                <span class="n">rPa</span> <span class="o">=</span> <span class="p">(</span><span class="n">K3n_u</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="n">K3n_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
                <span class="n">tPa</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">K3n_u</span><span class="o">*</span><span class="n">beta_l</span><span class="o">*</span><span class="n">K3n_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">denom</span>
                <span class="n">rMa</span> <span class="o">=</span> <span class="o">-</span><span class="n">rPa</span>
                <span class="n">tMa</span> <span class="o">=</span> <span class="n">tPa</span> 
            
        <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            
            <span class="c1"># True medium  (no need to coorect (w,k1)=(0,0) element)</span>
            <span class="n">denom</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">+</span> <span class="n">K3_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span>
            <span class="n">rP</span> <span class="o">=</span> <span class="p">(</span><span class="n">K3_u</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">-</span> <span class="n">K3_l</span><span class="o">*</span><span class="n">beta_u</span><span class="p">)</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3_u</span><span class="o">*</span><span class="n">beta_l</span> <span class="o">*</span> <span class="n">denom</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="o">-</span><span class="n">rP</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">K3_l</span><span class="o">*</span><span class="n">beta_u</span> <span class="o">*</span> <span class="n">denom</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">RT_k1_w: (AdjointMedium is True) and (normalisation=</span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">)&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="mi">72</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We have defined the scattering coefficients of the adjoint medium only for flux-normalisation.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rP&#39;</span><span class="p">:</span><span class="n">rP</span><span class="p">,</span><span class="s1">&#39;tP&#39;</span><span class="p">:</span><span class="n">tP</span><span class="p">,</span><span class="s1">&#39;rM&#39;</span><span class="p">:</span><span class="n">rM</span><span class="p">,</span><span class="s1">&#39;tM&#39;</span><span class="p">:</span><span class="n">tM</span><span class="p">,</span><span class="s1">&#39;rPa&#39;</span><span class="p">:</span><span class="n">rPa</span><span class="p">,</span><span class="s1">&#39;tPa&#39;</span><span class="p">:</span><span class="n">tPa</span><span class="p">,</span><span class="s1">&#39;rMa&#39;</span><span class="p">:</span><span class="n">rMa</span><span class="p">,</span><span class="s1">&#39;tMa&#39;</span><span class="p">:</span><span class="n">tMa</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.W_propagators_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.W_propagators_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">W_propagators_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">K3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">K3n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dx3</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the downgoing propagator &#39;wP&#39; and the upgoing progagator &#39;wM&#39; for all sampled vertical-wavenumbers &#39;K3&#39; and a vertical distance &#39;dx3&#39; (downward pointing :math:`x_3`-axis).</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        K3 : numpy.ndarray</span>
<span class="sd">            Vertical-wavenumber meshgrid :math:`k_3` for all frquencies :math:`\omega` and all horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">        </span>
<span class="sd">        K3n : inumpy.ndarray, optional (required if &#39;AdjointMedium=True&#39;)</span>
<span class="sd">            Vertical-wavenumber meshgrid :math:`k_3` for all frquencies :math:`\omega` and all sign-inverted horizontal-wavenumbers :math:`k_1`.</span>
<span class="sd">            </span>
<span class="sd">        g3 : int, float</span>
<span class="sd">            Medium parameter :math:`\gamma_3`.</span>
<span class="sd">            </span>
<span class="sd">        dx3 : int, float</span>
<span class="sd">            Vertical propagation distance :math:`\Delta x_3` (downward pointing :math:`x_3`-axis).</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **wP**: Downward propagator :math:`\\tilde{w}^+`.</span>
<span class="sd">                - **wM**: Upward propagator :math:`\\tilde{w}^-`.</span>
<span class="sd">                - **wPa**: Downward propagator :math:`\\tilde{w}^{+(a)}` (adjoint medium). </span>
<span class="sd">                - **wMa**: Upward propagator :math:`\\tilde{w}^{-(a)}` (adjoint medium). </span>
<span class="sd">            All propagators are stored in an arrays of shape (nf,nr). The variables &#39;wPa&#39; and &#39;wMa&#39; are computed for the setting &#39;AdjointMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        .. todo::</span>
<span class="sd">            </span>
<span class="sd">            In a non-reciprocal medium, for a complex-valued frequency </span>
<span class="sd">            :math:`\omega&#39;=\omega+\mathrm{j}\epsilon` one of the propagators </span>
<span class="sd">            has an exponentially growing term. Does that cause errors? If yes, </span>
<span class="sd">            can wefix that manually?</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise a wavefield</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=12.5,x3vec=np.array([1.1,2.2,3.7]),</span>
<span class="sd">        &gt;&gt;&gt;      avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g1vec=1j*np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      g3vec=1j*np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">        &gt;&gt;&gt;      ReciprocalMedium=True,AdjointMedium=True)</span>

<span class="sd">        &gt;&gt;&gt; # Compute the propagators of the first layer</span>
<span class="sd">        &gt;&gt;&gt; Prop = F.W_propagators_k1_w(K3=F.K3[:,:,0],K3n=F.K3n[:,:,0],</span>
<span class="sd">        &gt;&gt;&gt;                             g3=F.g3vec[0],dx3=F.x3vec[0])</span>

<span class="sd">        &gt;&gt;&gt; wP = Prop[&#39;wP&#39;]</span>
<span class="sd">        &gt;&gt;&gt; wM = Prop[&#39;wM&#39;]</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # In reciprocal media the down- and upgoing propagators are identical</span>
<span class="sd">        &gt;&gt;&gt; np.linalg.norm(wP-wM)</span>
<span class="sd">        0.0</span>
<span class="sd">        </span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if required input variables are given</span>
        <span class="k">if</span> <span class="p">(</span>    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">K3</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span> 
             <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">g3</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dx3</span><span class="p">))</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;W_propagators_k1_w: The input variables </span><span class="se">\&#39;</span><span class="s1">g3</span><span class="se">\&#39;</span><span class="s1"> and  &#39;</span><span class="o">+</span>
                     <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">dx3</span><span class="se">\&#39;</span><span class="s1"> must be scalars. The input variable </span><span class="se">\&#39;</span><span class="s1">K3</span><span class="se">\&#39;</span><span class="s1"> must&#39;</span><span class="o">+</span>
                     <span class="s1">&#39; have the shape (nf,nr)=(</span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1">).&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span>
            
        <span class="c1"># If AdjointMedium=True it is required to set K3n=K3(-k1)</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">K3n</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">)):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;W_propagators_k1_w: If </span><span class="se">\&#39;</span><span class="s1">AdjointMedium=True</span><span class="se">\&#39;</span><span class="s1"> the input&#39;</span><span class="o">+</span>
                     <span class="s1">&#39;variable </span><span class="se">\&#39;</span><span class="s1">K3n</span><span class="se">\&#39;</span><span class="s1"> must be given, and it must have the &#39;</span><span class="o">+</span>
                      <span class="s1">&#39;shape (nf,nr)=(</span><span class="si">%d</span><span class="s1">,</span><span class="si">%d</span><span class="s1">).&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            
            <span class="n">wP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">K3</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
            <span class="n">wM</span> <span class="o">=</span> <span class="n">wP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">wPa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">K3n</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
                <span class="n">wMa</span> <span class="o">=</span> <span class="n">wPa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">wPa</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">wMa</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            
            <span class="c1"># Frequency meshgrid</span>
            <span class="n">Om</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_K1_grid</span><span class="p">()[</span><span class="s1">&#39;Wgrid&#39;</span><span class="p">]</span>
            
            <span class="n">wP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">K3</span><span class="o">+</span><span class="n">Om</span><span class="o">*</span><span class="n">g3</span><span class="p">)</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
            <span class="n">wM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">K3</span><span class="o">-</span><span class="n">Om</span><span class="o">*</span><span class="n">g3</span><span class="p">)</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
        
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">wPa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">K3n</span><span class="o">-</span><span class="n">Om</span><span class="o">*</span><span class="n">g3</span><span class="p">)</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
                <span class="n">wMa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">K3n</span><span class="o">+</span><span class="n">Om</span><span class="o">*</span><span class="n">g3</span><span class="p">)</span><span class="o">*</span><span class="n">dx3</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="n">wPa</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">wMa</span> <span class="o">=</span> <span class="kc">None</span>
                
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;wP&#39;</span><span class="p">:</span><span class="n">wP</span><span class="p">,</span><span class="s1">&#39;wM&#39;</span><span class="p">:</span><span class="n">wM</span><span class="p">,</span><span class="s1">&#39;wPa&#39;</span><span class="p">:</span><span class="n">wPa</span><span class="p">,</span><span class="s1">&#39;wMa&#39;</span><span class="p">:</span><span class="n">wMa</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.Contains_Nan_Inf"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.Contains_Nan_Inf">[docs]</a>    <span class="k">def</span> <span class="nf">Contains_Nan_Inf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">FuncName</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;checks if the given arrays contain NaN or Inf elements. If an array</span>
<span class="sd">        contains NaN or Inf elements a command line statement is printed.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        </span>
<span class="sd">        FuncName : str</span>
<span class="sd">            Name of the function in which **Contains_Nan_Inf** is called.</span>
<span class="sd">            </span>
<span class="sd">        *args : tuple</span>
<span class="sd">            Undetermined number of input tuples. The first tuple element is an</span>
<span class="sd">            array, the second tuple element is the name of the array.</span>
<span class="sd">            </span>
<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        </span>
<span class="sd">        Message : str or None</span>
<span class="sd">            If any of the input arrays contains a NaN or Inf, a message is </span>
<span class="sd">            printed in the command line.</span>
<span class="sd">            </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        This function is only meant for internal usage. Therefore, there are no</span>
<span class="sd">        checks of the input variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
            <span class="n">Var</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Name</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="p">:</span>
                
                <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="n">FuncName</span><span class="o">+</span><span class="s1">&#39;:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="mi">72</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;At least one element of the modelled wavefields&#39;</span> 
                          <span class="o">+</span> <span class="s1">&#39;contains a NaN (Not a Number) or an Inf &#39;</span>
                          <span class="o">+</span> <span class="s1">&#39;(infinite).</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">keep</span> <span class="o">+=</span> <span class="mi">1</span>
                
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - &#39;</span><span class="o">+</span><span class="n">Name</span><span class="o">+</span><span class="s1">&#39; contains </span><span class="si">%d</span><span class="s1"> NaN.&#39;</span>
                          <span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Var</span><span class="p">))))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Var</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - &#39;</span><span class="o">+</span><span class="n">Name</span><span class="o">+</span><span class="s1">&#39; contains </span><span class="si">%d</span><span class="s1"> Inf.&#39;</span>
                          <span class="o">%</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">Var</span><span class="p">))))</span>
        <span class="k">return</span></div>
            
    
<div class="viewcode-block" id="Layered_NRM_k1_w.RT_response_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.RT_response_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">RT_response_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x3vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g1vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span><span class="n">InternalMultiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the reflection and transmission responses from above and </span>
<span class="sd">        from below. The medium parameters defined in **Layered_NRM_k1_w** are </span>
<span class="sd">        used, except if the medium parameters are given via the input </span>
<span class="sd">        variables. </span>
<span class="sd">        </span>
<span class="sd">        The medium responses are associated to measurements at :math:`x_3=0` </span>
<span class="sd">        and at :math:`x_3=` &#39;x3vec[-2]&#39; :math:`+\epsilon`, where </span>
<span class="sd">        :math:`\epsilon` is an infinitesimally small positive constant. Hence, </span>
<span class="sd">        the propagation from :math:`x_3=0` to the shallowest interface is </span>
<span class="sd">        included. However, the propagation through the deepest layer is </span>
<span class="sd">        excluded.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        x3vec : numpy.ndarray, optional</span>
<span class="sd">            Vertical spatial vector :math:`x_3`, for n layers &#39;x3vec&#39; must have </span>
<span class="sd">            the shape (n,). We define the :math:`x_3`-axis as </span>
<span class="sd">            downward-pointing. Implicitly, the first value on the </span>
<span class="sd">            :math:`x_3`-axis is zero (not stored in &#39;x3vec&#39;).</span>
<span class="sd">    </span>
<span class="sd">        avec : numpy.ndarray, optional</span>
<span class="sd">            Medium parameter :math:`\\alpha` (real-valued), for n layers &#39;avec&#39; </span>
<span class="sd">            must have the shape (n,).</span>
<span class="sd">            </span>
<span class="sd">        bvec : numpy.ndarray, optional</span>
<span class="sd">            Medium parameter :math:`\\beta` (real-valued), for n layers &#39;bvec&#39; </span>
<span class="sd">            must have the shape (n,).</span>
<span class="sd">        </span>
<span class="sd">        g1vec : numpy.ndarray, optional</span>
<span class="sd">            Medium parameter :math:`\gamma_1` (real-valued for non-reciprocal </span>
<span class="sd">            media or imaginary-valued for reciprocal media), for n layers </span>
<span class="sd">            &#39;g1vec&#39; must have the shape (n,).</span>
<span class="sd">            </span>
<span class="sd">        g3vec : numpy.ndarray, optional</span>
<span class="sd">            Medium parameter :math:`\gamma_3` (real-valued for non-reciprocal </span>
<span class="sd">            media or imaginary-valued for reciprocal media), for n layers </span>
<span class="sd">            &#39;g3vec&#39; must have the shape (n,).</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for </span>
<span class="sd">            flux-normalisation set normalisation=&#39;flux&#39;.</span>
<span class="sd">            </span>
<span class="sd">        InternalMultiples : bool, optional</span>
<span class="sd">            To model internal multiples set &#39;InternalMultiples=True&#39;. To </span>
<span class="sd">            ignore internal multiples set &#39;InternalMultiples=False&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **RP**: Reflection response from above.</span>
<span class="sd">                - **TP**: Transmission response from above.</span>
<span class="sd">                - **RM**: Reflection response from below.</span>
<span class="sd">                - **TM**: Transmission response from below.</span>
<span class="sd">                - **RPa**: Reflection response from above (adjoint medium).</span>
<span class="sd">                - **TPa**: Transmission response from above (adjoint medium).</span>
<span class="sd">                - **RMa**: Reflection response from below (adjoint medium).</span>
<span class="sd">                - **TMa**: Transmission response from below (adjoint medium).</span>
<span class="sd">            All medium responses are stored in arrays of shape (nf,nr). The </span>
<span class="sd">            variables &#39;RPa&#39;, &#39;TPa&#39;, &#39;RMa&#39; and &#39;TMa&#39; are computed only if one </span>
<span class="sd">            sets &#39;AdjointMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise a wavefield in a 1D reciprocal medium</span>
<span class="sd">        &gt;&gt;&gt; F = LM(nt=4096,dt=0.005,nr=2048,dx1=12.5,eps=2/(2049*0.005),</span>
<span class="sd">                   x3vec=np.array([1.1,2.2,3.7])*1e3,</span>
<span class="sd">                   avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">                   g1vec=np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">                   g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">                   ReciprocalMedium=False,AdjointMedium=True) </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Model the medium responses</span>
<span class="sd">        &gt;&gt;&gt; RT = F.RT_response_k1_w(normalisation=&#39;flux&#39;,InternalMultiples=True)</span>
<span class="sd">        &gt;&gt;&gt; RP = RT[&#39;RP&#39;]</span>
<span class="sd">        &gt;&gt;&gt; # Make a Ricker wavelet</span>
<span class="sd">        &gt;&gt;&gt; Wav=F.RickerWavelet_w(f0=30)</span>
<span class="sd">        &gt;&gt;&gt; # Compute gain function (correct for complex-valued frequency)</span>
<span class="sd">        &gt;&gt;&gt; gain = F.Gain_t()</span>
<span class="sd">        &gt;&gt;&gt; # Apply wavelet, transform to the space-time domain and apply gain</span>
<span class="sd">        &gt;&gt;&gt; rP = np.fft.fftshift(gain*F.K1W2X1T(Wav*RP),axes=(0,1))</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Plot reflection response</span>
<span class="sd">        &gt;&gt;&gt; T   = F.Tvec()[&#39;tvec&#39;]</span>
<span class="sd">        &gt;&gt;&gt; X1  = F.Xvec()[&#39;xvec&#39;]</span>
<span class="sd">        &gt;&gt;&gt; ex  = (X1[0,0], X1[-1,0], T[-1,0], T[0,0])</span>
<span class="sd">        &gt;&gt;&gt; asp = X1[-1,0]/T[-1,0]</span>
<span class="sd">        &gt;&gt;&gt; plt.figure(); plt.imshow(rP,cmap=&#39;seismic&#39;,vmin=-1e-3,vmax=1e-3,</span>
<span class="sd">                                     extent=ex,aspect=asp)</span>
<span class="sd">        &gt;&gt;&gt; plt.xlabel(&#39;Offset (m)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; plt.ylabel(&#39;Time (s)&#39;)</span>
<span class="sd">        </span>
<span class="sd">        .. image:: ../pictures/cropped/Rplus_k1_w.png</span>
<span class="sd">            :height: 200px</span>
<span class="sd">            :width: 200 px</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if normalisation is set correctly</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;flux&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_response_k1_w: The input variable </span><span class="se">\&#39;</span><span class="s1">normalisation</span><span class="se">\&#39;</span><span class="s1"> &#39;</span><span class="o">+</span>
                     <span class="s1">&#39;must be set, either to </span><span class="se">\&#39;</span><span class="s1">flux</span><span class="se">\&#39;</span><span class="s1">, or to </span><span class="se">\&#39;</span><span class="s1">pressure</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
            
        <span class="c1"># Medium responses of the adjoint medium can only be computed in </span>
        <span class="c1"># flux-normalisation</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">normalisation</span> <span class="ow">is</span> <span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;RT_response_k1_w: We have defined the scattering &#39;</span><span class="o">+</span>
                     <span class="s1">&#39;coefficients of the adjoint medium only for &#39;</span>     <span class="o">+</span>
                     <span class="s1">&#39;flux-normalisation.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if a layer stack is given</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x3vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">avec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g1vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> 
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g3vec</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            
            <span class="c1"># Create a wavefield in a sub-medium</span>
            <span class="c1"># I do this because when the sub-wavefield is initialised all </span>
            <span class="c1"># parameters are automatically tested for correctness</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span> <span class="o">=</span> <span class="n">Layered_NRM_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">dx1</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span><span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
                                            <span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span>
                                            <span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span><span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                            <span class="n">ReciprocalMedium</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ReciprocalMedium</span><span class="p">,</span>
                                            <span class="n">AdjointMedium</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span><span class="p">)</span>
            
            <span class="n">x3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">x3vec</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">bvec</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">g3vec</span>
            <span class="n">K3</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">K3</span>
            <span class="n">K3n</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SubSelf</span><span class="o">.</span><span class="n">K3n</span>
                
        <span class="c1"># Else compute response of entire medium</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span>
            <span class="n">K3</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K3</span>
            <span class="n">K3n</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K3n</span>
            
        
        <span class="c1"># Number of layers</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x3vec</span><span class="p">)</span>
        
        <span class="c1"># Vector with layer thicknesses</span>
        <span class="n">dx3vec</span> <span class="o">=</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dx3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">x3vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Reflection responses: Initial value</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">RM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Here every frequency component has an amplitude equal to one. Hence,</span>
        <span class="c1"># the total wavefield has a strength of sqrt(nt*nr)</span>
        <span class="c1"># When an ifft is applied the wavefield is scaled by 1/sqrt(nt*nr).</span>
        <span class="c1"># Hence in the time domain the wavefield has an amplitude equal to one.</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">TM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Internal multiple operator: Initial value</span>
        <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">RPa</span> <span class="o">=</span> <span class="n">RP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">RMa</span> <span class="o">=</span> <span class="n">RM</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">TPa</span> <span class="o">=</span> <span class="n">TP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">TMa</span> <span class="o">=</span> <span class="n">TM</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">RPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">TPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">RMa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">TMa</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># Loop over N-1 interfaces</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="c1"># Scattering coefficients</span>
            <span class="n">ScatCoeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_k1_w</span><span class="p">(</span><span class="n">beta_u</span><span class="o">=</span><span class="n">bvec</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">g3_u</span><span class="o">=</span><span class="n">g3vec</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                     <span class="n">K3_u</span><span class="o">=</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span><span class="n">K3n_u</span><span class="o">=</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span>
                                     <span class="n">beta_l</span><span class="o">=</span><span class="n">bvec</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">g3_l</span><span class="o">=</span><span class="n">g3vec</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">K3_l</span><span class="o">=</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">K3n_l</span><span class="o">=</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">)</span>
            
            <span class="n">rP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rP&#39;</span><span class="p">]</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tP&#39;</span><span class="p">]</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rM&#39;</span><span class="p">]</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tM&#39;</span><span class="p">]</span>
            
            <span class="c1"># Propagators</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_propagators_k1_w</span><span class="p">(</span><span class="n">K3</span><span class="o">=</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span><span class="n">K3n</span><span class="o">=</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">n</span><span class="p">],</span>
                                        <span class="n">g3</span><span class="o">=</span><span class="n">g3vec</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">dx3</span><span class="o">=</span><span class="n">dx3vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>    <span class="p">)</span>
            <span class="n">WP</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wP&#39;</span><span class="p">]</span>
            <span class="n">WM</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wM&#39;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="p">)</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="p">)</span>
            
            <span class="c1"># Update reflection / transmission responses</span>
            <span class="n">RP</span> <span class="o">=</span> <span class="n">RP</span> <span class="o">+</span> <span class="n">TM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TP</span>
            <span class="n">RM</span> <span class="o">=</span> <span class="n">rM</span> <span class="o">+</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>
            <span class="n">TP</span> <span class="o">=</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TP</span>
            <span class="n">TM</span> <span class="o">=</span> <span class="n">TM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>  
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">rP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rPa&#39;</span><span class="p">]</span>
                <span class="n">tP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tPa&#39;</span><span class="p">]</span>
                <span class="n">rM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rMa&#39;</span><span class="p">]</span>
                <span class="n">tM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tMa&#39;</span><span class="p">]</span>
                <span class="n">WP</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wPa&#39;</span><span class="p">]</span>
                <span class="n">WM</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wMa&#39;</span><span class="p">]</span>
            
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="p">)</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="p">)</span>
                
                <span class="c1"># Update reflection / transmission responses</span>
                <span class="n">RPa</span> <span class="o">=</span> <span class="n">RPa</span> <span class="o">+</span> <span class="n">TMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TPa</span>
                <span class="n">RMa</span> <span class="o">=</span> <span class="n">rM</span> <span class="o">+</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>
                <span class="n">TPa</span> <span class="o">=</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TPa</span>
                <span class="n">TMa</span> <span class="o">=</span> <span class="n">TMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>  
                
        <span class="c1"># Verbose: Inform the user if any wavefield contains NaNs of Infs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Contains_Nan_Inf</span><span class="p">(</span><span class="s1">&#39;RT_response_k1_w&#39;</span><span class="p">,(</span><span class="n">RP</span><span class="p">,</span><span class="s1">&#39;RP&#39;</span><span class="p">),(</span><span class="n">TP</span><span class="p">,</span><span class="s1">&#39;TP&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="n">RM</span><span class="p">,</span><span class="s1">&#39;RM&#39;</span><span class="p">),(</span><span class="n">TM</span><span class="p">,</span><span class="s1">&#39;TM&#39;</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Contains_Nan_Inf</span><span class="p">(</span><span class="s1">&#39;RT_response_k1_w&#39;</span><span class="p">,(</span><span class="n">RPa</span><span class="p">,</span><span class="s1">&#39;RPa&#39;</span><span class="p">),</span>
                                      <span class="p">(</span><span class="n">TPa</span><span class="p">,</span><span class="s1">&#39;TPa&#39;</span><span class="p">),(</span><span class="n">RMa</span><span class="p">,</span><span class="s1">&#39;RMa&#39;</span><span class="p">),(</span><span class="n">TMa</span><span class="p">,</span><span class="s1">&#39;TMa&#39;</span><span class="p">))</span>

                
        <span class="n">out</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;RP&#39;</span><span class="p">:</span><span class="n">RP</span>  <span class="p">,</span><span class="s1">&#39;TP&#39;</span><span class="p">:</span><span class="n">TP</span>  <span class="p">,</span><span class="s1">&#39;RM&#39;</span><span class="p">:</span><span class="n">RM</span>  <span class="p">,</span><span class="s1">&#39;TM&#39;</span><span class="p">:</span><span class="n">TM</span><span class="p">,</span>
             <span class="s1">&#39;RPa&#39;</span><span class="p">:</span><span class="n">RPa</span><span class="p">,</span><span class="s1">&#39;TPa&#39;</span><span class="p">:</span><span class="n">TPa</span><span class="p">,</span><span class="s1">&#39;RMa&#39;</span><span class="p">:</span><span class="n">RMa</span><span class="p">,</span><span class="s1">&#39;TMa&#39;</span><span class="p">:</span><span class="n">TMa</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
            
    <span class="c1"># Insert a layer in the model    </span>
<div class="viewcode-block" id="Layered_NRM_k1_w.Insert_layer"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.Insert_layer">[docs]</a>    <span class="k">def</span> <span class="nf">Insert_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;inserts a transparent interface at the depth level &#39;x3&#39;. If &#39;x3&#39; </span>
<span class="sd">        coincides with an interface of the model, the model&#39;s interface is left </span>
<span class="sd">        unchanged. If &#39;x3&#39; is a vector it is interpreted as multiple depth </span>
<span class="sd">        levels, at each one a transparent interface will be inserted.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        x3 : int, float, numpy.ndarray</span>
<span class="sd">            A depth level, or a vector of depth levels, at which a transparent </span>
<span class="sd">            interface will be inserted. The variable &#39;x3&#39; either must be a </span>
<span class="sd">            scalar, or have the shape (n,). Each element of &#39;x3&#39; must be </span>
<span class="sd">            real-valued and greater than, or equal to zero.</span>
<span class="sd">    </span>
<span class="sd">        UpdateSelf : bool, optional</span>
<span class="sd">            Set &#39;UpdateSelf=True&#39; to not only output an updated model but also </span>
<span class="sd">            update the &#39;self&#39; parameters.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **x3vec**: Updated depth vector.</span>
<span class="sd">                - **avec**:  Updated :math:`\\alpha` vector.</span>
<span class="sd">                - **bvec**:  Updated :math:`\\beta` vector.</span>
<span class="sd">                - **g1vec**: Updated :math:`\gamma_1` vector.</span>
<span class="sd">                - **g3vec**: Updated :math:`\gamma_3` vector.</span>
<span class="sd">                - **K3**:    Updated :math:`k_3(k_1)` vector.</span>
<span class="sd">                - **K3n**:   Updated :math:`k_3(-k_1)` vector.</span>
<span class="sd">            All medium parameter vectors are stored in arrays of shape (n,).</span>
<span class="sd">            The vertical wavenumbers are stored in arrays of shape (nf,nr,n).</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise a wavefield in a 1D reciprocal medium</span>
<span class="sd">        &gt;&gt;&gt; F=LM(nt=1024,dt=0.005,nr=512,dx1=10,</span>
<span class="sd">                 x3vec=np.array([10,150,200]),</span>
<span class="sd">                 avec=np.array([1,2,3]),bvec=np.array([0.4,3.14,2]),</span>
<span class="sd">                 g1vec=np.array([0.9,2.1,0.3]),g3vec=np.array([0.7,1.14,0.2]))</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Insert a transparent layer at x3=1</span>
<span class="sd">        &gt;&gt;&gt; out=F.Insert_layer(x3=1,UpdateSelf=False)</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Updated depth vector</span>
<span class="sd">        &gt;&gt;&gt; out[&#39;x3vec&#39;]</span>
<span class="sd">        array([  1,  10, 150, 200])</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Updated alpha vector</span>
<span class="sd">        &gt;&gt;&gt; out[&#39;avec&#39;]</span>
<span class="sd">        array([1, 1, 2, 3])</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if x3 is a scalar or an array of the shape (n,).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> 
                <span class="ow">or</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span> 
                <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x3</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Insert_layer: The input variable </span><span class="se">\&#39;</span><span class="s1">x3</span><span class="se">\&#39;</span><span class="s1"> must be either &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;a scalar, or an array of shape (n,).&#39;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">or</span>  <span class="nb">isinstance</span><span class="p">(</span><span class="n">x3</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">x3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x3</span><span class="p">])</span>
        
        <span class="c1"># Check if x3 is real-valued.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">x3</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Insert_layer: The input variable </span><span class="se">\&#39;</span><span class="s1">x3</span><span class="se">\&#39;</span><span class="s1"> must be &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;real-valued.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check if all elements of x3 are greater than, or equal to zero.</span>
        <span class="k">if</span> <span class="n">x3</span><span class="p">[</span><span class="n">x3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Insert_layer: Each element of the input variable </span><span class="se">\&#39;</span><span class="s1">x3</span><span class="se">\&#39;</span><span class="s1"> &#39;</span>
                     <span class="o">+</span><span class="s1">&#39;must be  greater than, or equal to zero.&#39;</span><span class="p">)</span>
        
        <span class="n">X3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span>
        <span class="n">Avec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avec</span>
        <span class="n">Bvec</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span>
        <span class="n">G1vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span>
        <span class="n">G3vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span>
        <span class="n">K3</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K3</span>
        <span class="n">K3n</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">K3n</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x3</span><span class="p">)):</span>
        
            <span class="c1"># Vector of depths smaller than or equal to x3[i]</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">X3vec</span><span class="o">&lt;=</span><span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> 
            
            <span class="c1"># Case1: x3[i] smaller than X3vec[0]</span>
            <span class="k">if</span> <span class="n">L</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">X3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="p">,</span><span class="n">X3vec</span><span class="p">])</span>
                <span class="n">Avec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Avec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">Avec</span><span class="p">])</span>
                <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Bvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span><span class="n">Bvec</span><span class="p">])</span>
                <span class="n">G1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G1vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">G1vec</span><span class="p">])</span>
                <span class="n">G3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G3vec</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">G3vec</span><span class="p">])</span>
                <span class="n">K3</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3</span><span class="p">[:,:,:</span><span class="mi">1</span><span class="p">]</span>   <span class="p">,</span><span class="n">K3</span><span class="p">])</span>
                <span class="n">K3n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3n</span><span class="p">[:,:,:</span><span class="mi">1</span><span class="p">]</span>  <span class="p">,</span><span class="n">K3n</span><span class="p">])</span>
            
            <span class="c1"># Case2: x3[i] coincides with an element of X3vec</span>
            <span class="k">elif</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">X3vec</span> <span class="o">=</span> <span class="n">X3vec</span>
                <span class="n">Avec</span>  <span class="o">=</span> <span class="n">Avec</span>
                <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">Bvec</span>
                <span class="n">G1vec</span> <span class="o">=</span> <span class="n">G1vec</span>
                <span class="n">G3vec</span> <span class="o">=</span> <span class="n">G3vec</span>
                <span class="n">K3</span>    <span class="o">=</span> <span class="n">K3</span>
                <span class="n">K3n</span>   <span class="o">=</span> <span class="n">K3n</span>
            
            <span class="c1"># Case 3: x3[i] is larger than X3vec[-1]</span>
            <span class="k">elif</span> <span class="n">L</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">X3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">X3vec</span><span class="p">,</span><span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="n">Avec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Avec</span> <span class="p">,</span><span class="n">Avec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Bvec</span> <span class="p">,</span><span class="n">Bvec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">G1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G1vec</span><span class="p">,</span><span class="n">G1vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">G3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G3vec</span><span class="p">,</span><span class="n">G3vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">K3</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3</span>   <span class="p">,</span><span class="n">K3</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">K3n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3n</span>  <span class="p">,</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="o">-</span><span class="mi">1</span><span class="p">:]])</span>
                
            <span class="c1"># Case 4: x3[i] is between X3vec[0] and X3vec[-1] AND does not </span>
            <span class="c1"># coincide with any element of X3vec</span>
            <span class="k">else</span><span class="p">:</span>
                
                <span class="n">b</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
                <span class="n">ind</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                
                <span class="n">X3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">X3vec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">x3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>       <span class="p">,</span><span class="n">X3vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">Avec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Avec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span><span class="n">Avec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span><span class="n">Avec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">Bvec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span><span class="n">Bvec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span><span class="n">Bvec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">G1vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G1vec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">G1vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">G1vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">G3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">G3vec</span><span class="p">[:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">G3vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">G3vec</span><span class="p">[</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">K3</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3</span><span class="p">[:,:,:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>   <span class="p">,</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>   <span class="p">,</span><span class="n">K3</span><span class="p">[:,:,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
                <span class="n">K3n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">K3n</span><span class="p">[:,:,:</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>  <span class="p">,</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ind</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>  <span class="p">,</span><span class="n">K3n</span><span class="p">[:,:,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">:]])</span>
            
        <span class="c1"># Update self: Apply layer insertion to the self-parameters    </span>
        <span class="k">if</span> <span class="n">UpdateSelf</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K3</span>    <span class="o">=</span> <span class="n">K3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">K3n</span>   <span class="o">=</span> <span class="n">K3n</span>
            
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x3vec&#39;</span><span class="p">:</span><span class="n">X3vec</span><span class="p">,</span><span class="s1">&#39;avec&#39;</span><span class="p">:</span><span class="n">Avec</span><span class="p">,</span><span class="s1">&#39;bvec&#39;</span><span class="p">:</span><span class="n">Bvec</span><span class="p">,</span>
               <span class="s1">&#39;g1vec&#39;</span><span class="p">:</span><span class="n">G1vec</span><span class="p">,</span><span class="s1">&#39;g3vec&#39;</span><span class="p">:</span><span class="n">G3vec</span><span class="p">,</span><span class="s1">&#39;K3&#39;</span><span class="p">:</span><span class="n">K3</span><span class="p">,</span><span class="s1">&#39;K3n&#39;</span><span class="p">:</span><span class="n">K3n</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.GreensFunction_k1_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.GreensFunction_k1_w">[docs]</a>    <span class="k">def</span> <span class="nf">GreensFunction_k1_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x3R</span><span class="p">,</span><span class="n">x3S</span><span class="p">,</span><span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span>
                           <span class="n">InternalMultiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the one-way Green\&#39;s functions for a receiver and source </span>
<span class="sd">        depth defined by the input variables \&#39;x3R\&#39; and \&#39;x3S\&#39;. The one-way </span>
<span class="sd">        wavefields are decomposed at the receiver- and at the source-side. We </span>
<span class="sd">        define the receiver and source depths just below \&#39;x3R\&#39; and \&#39;x3S\&#39;, </span>
<span class="sd">        respectively (this is important if the receiver or source depth </span>
<span class="sd">        coincides with an interface).</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        x3R : int,float</span>
<span class="sd">            Receiver depth.</span>
<span class="sd">    </span>
<span class="sd">        x3S : int, float</span>
<span class="sd">            Source depth.</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for </span>
<span class="sd">            flux-normalisation set normalisation=&#39;flux&#39;.</span>
<span class="sd">            </span>
<span class="sd">        InternalMultiples : bool, optional</span>
<span class="sd">            To model internal multiples set &#39;InternalMultiples=True&#39;. To </span>
<span class="sd">            exclude internal multiples set &#39;InternalMultiples=False&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **GPP**: Green\&#39;s function :math:`G^{+,+}` (true medium).</span>
<span class="sd">                - **GPM**: Green\&#39;s function :math:`G^{+,-}` (true medium).</span>
<span class="sd">                - **GMP**: Green\&#39;s function :math:`G^{-,+}` (true medium).</span>
<span class="sd">                - **GMM**: Green\&#39;s function :math:`G^{-,-}` (true medium).</span>
<span class="sd">                - **GPPa**: Green\&#39;s function :math:`G^{+,+}` (adjoint medium).</span>
<span class="sd">                - **GPMa**: Green\&#39;s function :math:`G^{+,-}` (adjoint medium).</span>
<span class="sd">                - **GMPa**: Green\&#39;s function :math:`G^{-,+}` (adjoint medium).</span>
<span class="sd">                - **GMMa**: Green\&#39;s function :math:`G^{-,-}` (adjoint medium).</span>
<span class="sd">            All medium responses are stored in arrays of shape (nf,nr). The </span>
<span class="sd">            variables &#39;GPPa&#39;, &#39;GPMa&#39;, &#39;GMPa&#39; and &#39;GMMa&#39; are computed, only if </span>
<span class="sd">            one sets &#39;AdjointMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        - The superscript \&#39;+\&#39; and \&#39;-\&#39; refer to downgoing and upgoing waves, </span>
<span class="sd">        respectively.</span>
<span class="sd">        - The first superscript refers to the wavefield at the receiver-side.</span>
<span class="sd">        - The second superscript refers to the wavefield at the source-side.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; to be done</span>
<span class="sd">        &gt;&gt;&gt; from Layered_NRM_k1_w import Layered_NRM_k1_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Initialise a wavefield in a 1D reciprocal medium</span>
<span class="sd">        &gt;&gt;&gt; F = LM(nt=4096,dt=0.005,nr=2048,dx1=12.5,eps=2/(2049*0.005),</span>
<span class="sd">                   x3vec=np.array([1.1,2.2,3.7])*1e3,</span>
<span class="sd">                   avec=np.array([1,2,3])*1e-3,bvec=np.array([1.4,3.14,2])*1e-4,</span>
<span class="sd">                   g1vec=np.array([0.8,2,1.3])*1e-4,</span>
<span class="sd">                   g3vec=np.array([1.8,0.7,2.3])*1e-4,</span>
<span class="sd">                   ReciprocalMedium=False,AdjointMedium=True) </span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; G = F.GreensFunction_p_w(x3R=0,x3S=0,normalisation=normalisation,</span>
<span class="sd">        &gt;&gt;&gt;                          InternalMultiples=InternalMultiples)</span>
<span class="sd">        &gt;&gt;&gt; RT=F.RT_response_p_w(normalisation=normalisation,</span>
<span class="sd">        &gt;&gt;&gt;                      InternalMultiples=InternalMultiples)</span>
<span class="sd">        &gt;&gt;&gt; np.linalg.norm(RT[&#39;RP&#39;]-G[&#39;GMP&#39;]</span>
<span class="sd">        0.0</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Insert transparent interfaces at source and receiver depth levels</span>
        <span class="c1"># The insertion implicitly checks that x3R and x3S are non-negative </span>
        <span class="c1"># real-valued scalars</span>
        <span class="c1"># If the receiver or source depth is greater than, or equal to the </span>
        <span class="c1"># deepest interface, we insert another transparent layer below the  </span>
        <span class="c1"># &#39;new&#39; deepest interface. This is necessary because the function </span>
        <span class="c1"># RT_response_k1_w does not compute the propagation through the deepest</span>
        <span class="c1"># layer. By adding a transparent interface below the source/receiver we</span>
        <span class="c1"># ensure that the propagation is computed correctly.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x3R</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x3S</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">xb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">x3R</span><span class="p">,</span><span class="n">x3S</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">Tmp_medium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x3R</span><span class="p">,</span><span class="n">x3S</span><span class="p">,</span><span class="n">xb</span><span class="p">]),</span>
                                           <span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Tmp_medium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x3R</span><span class="p">,</span><span class="n">x3S</span><span class="p">]),</span>
                                           <span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            
        <span class="n">X3vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;x3vec&#39;</span><span class="p">]</span>
        <span class="n">Avec</span>  <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;avec&#39;</span><span class="p">]</span>
        <span class="n">Bvec</span>  <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;bvec&#39;</span><span class="p">]</span>
        <span class="n">G1vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;g1vec&#39;</span><span class="p">]</span>
        <span class="n">G3vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;g3vec&#39;</span><span class="p">]</span>
        
        <span class="c1"># Get indices of the receiver and source interfaces</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x3R</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x3S</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">x3R</span> <span class="o">&gt;</span> <span class="n">x3S</span><span class="p">:</span>
            
            <span class="c1"># Overburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>

            <span class="c1"># Sandwiched layer stack</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Underburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            
            <span class="c1"># Exception if underburden is homogeneous</span>
            <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
            
            <span class="n">L3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>

            <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
            <span class="c1"># reading from dictionary</span>
            <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">]</span>
            <span class="n">TP2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TP&#39;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM1</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">GPP12</span> <span class="o">=</span>  <span class="n">TP2</span><span class="o">*</span><span class="n">M1</span>
            <span class="n">GPM12</span> <span class="o">=</span> <span class="o">-</span><span class="n">TP2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span> <span class="c1"># Multiply by -1 because upgoing</span>
                                <span class="c1"># sources are defined with </span>
                                <span class="c1"># negative amplitude</span>
                                            
            <span class="c1"># Compute reflection from below of parts 1+2 </span>
            <span class="n">RM12</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">TP2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TM&#39;</span><span class="p">]</span>
            
            <span class="c1"># Compute the Green&#39;s functions G13 for the complete medium</span>
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">RM12</span><span class="o">*</span><span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">GPP13</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GPP12</span>
            <span class="n">GPM13</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GPM12</span>
            <span class="n">GMP13</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GPP12</span>
            <span class="n">GMM13</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GPM12</span>
            
            <span class="c1"># Green;s functions in adjoint medium</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
                <span class="c1"># reading from dictionary</span>
                <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">]</span>
                <span class="n">TP2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TPa&#39;</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM1</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">GPP12</span> <span class="o">=</span>  <span class="n">TP2</span><span class="o">*</span><span class="n">M1</span>
                <span class="n">GPM12</span> <span class="o">=</span> <span class="o">-</span><span class="n">TP2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span> <span class="c1"># Multiply by -1 because upgoing</span>
                                    <span class="c1"># sources are defined with </span>
                                    <span class="c1"># negative amplitude</span>
                                                
                <span class="c1"># Compute reflection from below of parts 1+2 </span>
                <span class="n">RM12</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">TP2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TMa&#39;</span><span class="p">]</span>
                
                <span class="c1"># Compute the Green&#39;s functions G13 for the complete medium</span>
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">RM12</span><span class="o">*</span><span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">GPP13a</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GPP12</span>
                <span class="n">GPM13a</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GPM12</span>
                <span class="n">GMP13a</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GPP12</span>
                <span class="n">GMM13a</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GPM12</span>
                
            
            
        <span class="k">elif</span> <span class="n">x3R</span> <span class="o">==</span> <span class="n">x3S</span><span class="p">:</span>
            
            <span class="c1"># Overburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Underburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            
            <span class="c1"># Exception if underburden is homogeneous</span>
            <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
                <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="p">:]</span>
            
            <span class="n">L3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
          
            <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
            <span class="c1"># reading from dictionary</span>
            <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">]</span>
            <span class="n">RP3</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM1</span><span class="o">*</span><span class="n">RP3</span> <span class="p">)</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP3</span><span class="o">*</span><span class="n">RM1</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="n">M1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
            <span class="n">GPP13</span> <span class="o">=</span>  <span class="n">M1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
            <span class="n">GPM13</span> <span class="o">=</span> <span class="o">-</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span>     <span class="c1"># Multiply by -1 because upgoing</span>
                                <span class="c1"># sources are defined with </span>
                                <span class="c1"># negative amplitude</span>
            <span class="n">GMP13</span> <span class="o">=</span>  <span class="n">RP3</span><span class="o">*</span><span class="n">M1</span>
            <span class="n">GMM13</span> <span class="o">=</span> <span class="o">-</span><span class="n">M2</span>     <span class="c1"># Multiply by -1 because upgoing</span>
                            <span class="c1"># sources are defined with </span>
                            <span class="c1"># negative amplitude</span>
                            
            <span class="c1"># Green;s functions in adjoint medium</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
                <span class="c1"># reading from dictionary</span>
                <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">]</span>
                <span class="n">RP3</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span>
                
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM1</span><span class="o">*</span><span class="n">RP3</span> <span class="p">)</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP3</span><span class="o">*</span><span class="n">RM1</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">nr</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="n">M1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                <span class="n">GPP13a</span> <span class="o">=</span>  <span class="n">M1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> 
                <span class="n">GPM13a</span> <span class="o">=</span> <span class="o">-</span><span class="n">M1</span><span class="o">*</span><span class="n">RM1</span>     <span class="c1"># Multiply by -1 because upgoing</span>
                                     <span class="c1"># sources are defined with </span>
                                     <span class="c1"># negative amplitude</span>
                <span class="n">GMP13a</span> <span class="o">=</span>  <span class="n">RP3</span><span class="o">*</span><span class="n">M1</span>
                <span class="n">GMM13a</span> <span class="o">=</span> <span class="o">-</span><span class="n">M2</span>     <span class="c1"># Multiply by -1 because upgoing</span>
                                 <span class="c1"># sources are defined with </span>
                                 <span class="c1"># negative amplitude</span>
            
        <span class="k">elif</span> <span class="n">x3R</span> <span class="o">&lt;</span> <span class="n">x3S</span><span class="p">:</span>
            
            <span class="c1"># Overburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[:</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Sandwiched layer stack</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">s</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">L2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Underburden</span>
            <span class="n">x3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">X3vec</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
            
            <span class="c1"># Exception if underburden is homogeneous</span>
            <span class="k">if</span> <span class="n">x3vec</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x3vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">avec</span>  <span class="o">=</span> <span class="n">Avec</span><span class="p">[</span><span class="n">s</span><span class="p">:]</span>
                <span class="n">bvec</span>  <span class="o">=</span> <span class="n">Bvec</span><span class="p">[</span><span class="n">s</span><span class="p">:]</span>
                <span class="n">g1vec</span> <span class="o">=</span> <span class="n">G1vec</span><span class="p">[</span><span class="n">s</span><span class="p">:]</span>
                <span class="n">g3vec</span> <span class="o">=</span> <span class="n">G3vec</span><span class="p">[</span><span class="n">s</span><span class="p">:]</span>
            
            <span class="n">L3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_response_k1_w</span><span class="p">(</span><span class="n">x3vec</span><span class="o">=</span><span class="n">x3vec</span><span class="p">,</span><span class="n">avec</span><span class="o">=</span><span class="n">avec</span><span class="p">,</span><span class="n">bvec</span><span class="o">=</span><span class="n">bvec</span><span class="p">,</span>
                                      <span class="n">g1vec</span><span class="o">=</span><span class="n">g1vec</span><span class="p">,</span><span class="n">g3vec</span><span class="o">=</span><span class="n">g3vec</span><span class="p">,</span>
                                      <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">,</span>
                                      <span class="n">InternalMultiples</span><span class="o">=</span><span class="n">InternalMultiples</span><span class="p">)</span>
            
            <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
            <span class="c1"># reading from dictionary</span>
            <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">]</span>
            <span class="n">TM2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TM&#39;</span><span class="p">]</span>
            <span class="n">RP3</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span>
            
            <span class="c1"># Compute reflection from above of part 2+3 </span>
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP3</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RM&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">RP23</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RP&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">TM2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RP3</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TP&#39;</span><span class="p">]</span>
            
            <span class="c1"># Compute the Green&#39;s functions G23 that exclude the medium above </span>
            <span class="c1"># the receiver: GMP23,GMM23</span>
            <span class="n">GMP23</span> <span class="o">=</span>  <span class="n">TM2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RP3</span>                   
            <span class="n">GMM23</span> <span class="o">=</span> <span class="o">-</span><span class="n">TM2</span><span class="o">*</span><span class="n">M1</span>         <span class="c1"># Multiply by -1 because upgoing</span>
                                    <span class="c1"># sources are defined with </span>
                                    <span class="c1"># negative amplitude</span>
                
            
            
            <span class="c1"># Compute the Green&#39;s functions G13 for the complete medium</span>
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP23</span><span class="o">*</span><span class="n">RM1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">GPP13</span> <span class="o">=</span> <span class="n">RM1</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GMP23</span>
            <span class="n">GPM13</span> <span class="o">=</span> <span class="n">RM1</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GMM23</span>
            <span class="n">GMP13</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GMP23</span>
            <span class="n">GMM13</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GMM23</span>
            
            <span class="c1"># Green;s functions in adjoint medium</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Get variables that are used multiple times to avoid multiple </span>
                <span class="c1"># reading from dictionary</span>
                <span class="n">RM1</span> <span class="o">=</span> <span class="n">L1</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">]</span>
                <span class="n">TM2</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TMa&#39;</span><span class="p">]</span>
                <span class="n">RP3</span> <span class="o">=</span> <span class="n">L3</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span>
                
                <span class="c1"># Compute reflection from above of part 2+3 </span>
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP3</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RMa&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">RP23</span> <span class="o">=</span> <span class="n">L2</span><span class="p">[</span><span class="s1">&#39;RPa&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">TM2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RP3</span><span class="o">*</span><span class="n">L2</span><span class="p">[</span><span class="s1">&#39;TPa&#39;</span><span class="p">]</span>
                
                <span class="c1"># Compute the Green&#39;s functions G23 that exclude the medium above </span>
                <span class="c1"># the receiver: GMP23,GMM23</span>
                <span class="n">GMP23</span> <span class="o">=</span>  <span class="n">TM2</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">RP3</span>                   
                <span class="n">GMM23</span> <span class="o">=</span> <span class="o">-</span><span class="n">TM2</span><span class="o">*</span><span class="n">M1</span>         <span class="c1"># Multiply by -1 because upgoing</span>
                                        <span class="c1"># sources are defined with </span>
                                        <span class="c1"># negative amplitude</span>
                    
                
                
                <span class="c1"># Compute the Green&#39;s functions G13 for the complete medium</span>
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RP23</span><span class="o">*</span><span class="n">RM1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">GPP13a</span> <span class="o">=</span> <span class="n">RM1</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GMP23</span>
                <span class="n">GPM13a</span> <span class="o">=</span> <span class="n">RM1</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">GMM23</span>
                <span class="n">GMP13a</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GMP23</span>
                <span class="n">GMM13a</span> <span class="o">=</span> <span class="n">M2</span><span class="o">*</span><span class="n">GMM23</span>
                
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">GPP13a</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">GPM13a</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">GMP13a</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">GMM13a</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="c1"># Verbose: Inform the user if any wavefield contains NaNs of Infs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Contains_Nan_Inf</span><span class="p">(</span><span class="s1">&#39;GreensFunction_k1_w&#39;</span><span class="p">,</span>
                                  <span class="p">(</span><span class="n">GPP13</span><span class="p">,</span><span class="s1">&#39;GPP13&#39;</span><span class="p">),(</span><span class="n">GPM13</span><span class="p">,</span><span class="s1">&#39;GPM13&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="n">GMP13</span><span class="p">,</span><span class="s1">&#39;GMP13&#39;</span><span class="p">),(</span><span class="n">GMM13</span><span class="p">,</span><span class="s1">&#39;GMM13&#39;</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Contains_Nan_Inf</span><span class="p">(</span><span class="s1">&#39;GreensFunction_k1_w&#39;</span><span class="p">,</span>
                                  <span class="p">(</span><span class="n">GPP13a</span><span class="p">,</span><span class="s1">&#39;GPP13a&#39;</span><span class="p">),(</span><span class="n">GPM13a</span><span class="p">,</span><span class="s1">&#39;GPM13a&#39;</span><span class="p">),</span>
                                  <span class="p">(</span><span class="n">GMP13a</span><span class="p">,</span><span class="s1">&#39;GMP13a&#39;</span><span class="p">),(</span><span class="n">GMM13a</span><span class="p">,</span><span class="s1">&#39;GMM13a&#39;</span><span class="p">))</span>
                
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;GPP&#39;</span><span class="p">:</span><span class="n">GPP13</span>  <span class="p">,</span><span class="s1">&#39;GPM&#39;</span><span class="p">:</span><span class="n">GPM13</span>  <span class="p">,</span><span class="s1">&#39;GMP&#39;</span><span class="p">:</span><span class="n">GMP13</span>  <span class="p">,</span><span class="s1">&#39;GMM&#39;</span><span class="p">:</span><span class="n">GMM13</span><span class="p">,</span>
               <span class="s1">&#39;GPPa&#39;</span><span class="p">:</span><span class="n">GPP13a</span><span class="p">,</span><span class="s1">&#39;GPMa&#39;</span><span class="p">:</span><span class="n">GPM13a</span><span class="p">,</span><span class="s1">&#39;GMPa&#39;</span><span class="p">:</span><span class="n">GMP13a</span><span class="p">,</span><span class="s1">&#39;GMMa&#39;</span><span class="p">:</span><span class="n">GMM13a</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div>
    
<div class="viewcode-block" id="Layered_NRM_k1_w.FocusingFunction_p_w"><a class="viewcode-back" href="../Layered_NRM_k1_w.html#Layered_NRM_k1_w.Layered_NRM_k1_w.FocusingFunction_p_w">[docs]</a>    <span class="k">def</span> <span class="nf">FocusingFunction_p_w</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x3F</span><span class="p">,</span><span class="n">normalisation</span><span class="o">=</span><span class="s1">&#39;flux&#39;</span><span class="p">,</span><span class="n">InternalMultiples</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;computes the focusing functions between the top surface (:math:`x_3=0`) and the focusing depth defined by the input variable \&#39;x3F\&#39;. We define the focusing depth just below \&#39;x3F\&#39;. Hence, if the focusing depth coincides with an interface the focusing function focuses below that interface.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">    </span>
<span class="sd">        x3F : int,float</span>
<span class="sd">            Focusing depth.</span>
<span class="sd">            </span>
<span class="sd">        normalisation : str, optional</span>
<span class="sd">            For pressure-normalisation set normalisation=&#39;pressure&#39;, for flux-normalisation set normalisation=&#39;flux&#39;. Until now, this function only models the focusing function for flux-normalisation.</span>
<span class="sd">            </span>
<span class="sd">        InternalMultiples : bool, optional</span>
<span class="sd">            To model internal multiples set &#39;InternalMultiples=True&#39;. To ignore internal multiples set &#39;InternalMultiples=False&#39;.</span>
<span class="sd">            </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">    </span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary that contains </span>
<span class="sd">                - **FP**: Downgoing focusing function.</span>
<span class="sd">                - **RP**: Reflection response from above.</span>
<span class="sd">                - **TP**: Transmission response from above.</span>
<span class="sd">                - **FM**: Upgoing focusing function.</span>
<span class="sd">                - **RM**: Reflection response from below.</span>
<span class="sd">                - **TM**: Transmission response from below.</span>
<span class="sd">                - **FPa**: Downgoing focusing function (adjoint medium).</span>
<span class="sd">                - **RPa**: Reflection response from above (adjoint medium).</span>
<span class="sd">                - **TPa**: Transmission response from above (adjoint medium).</span>
<span class="sd">                - **FMa**: Upgoing focusing function (adjoint medium).</span>
<span class="sd">                - **RMa**: Reflection response from below (adjoint medium).</span>
<span class="sd">                - **TMa**: Transmission response from below (adjoint medium).</span>
<span class="sd">            All medium responses are stored in arrays of shape (nf,1). The variables &#39;FPa&#39;, &#39;RPa&#39;, &#39;TPa&#39;, &#39;FMa&#39;, &#39;RMa&#39; and &#39;TMa&#39; are computed only if one sets &#39;AdjointMedium=True&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        </span>
<span class="sd">        - The downgoing focusing funtion :math:`\\tilde{F}_1^+` is computed by inverting the expressions for the transmission from above :math:`\\tilde{T}^+`:</span>
<span class="sd">            :math:`\\tilde{F}_{1,n}^+ = \\tilde{F}_{1,n-1}^+ (\\tilde{w}_n^+)^{-1} (1 - \\tilde{w}_n^+ \\tilde{R}_{n-1}^{\cap} \\tilde{w}_n^- \\tilde{r}_n^{\cup} )^{-1} (\\tilde{t}_n^+)^{-1}`</span>
<span class="sd">        - The upgoing focusing function is computed by applying the reflection response :math:`R^{\cup}` on the downgoing focusing funtion :math:`\\tilde{F}_1^+`:</span>
<span class="sd">            :math:`\\tilde{F}_{1,n}^- = \\tilde{R}^{\cup} \\tilde{F}_{1,n}^+`.</span>
<span class="sd">        </span>
<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        Kees document as soon as it is published.</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from Layered_NRM_p_w import Layered_NRM_p_w as LM</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>

<span class="sd">        &gt;&gt;&gt; F=LM( nt=1024,dt=0.005,x3vec=np.array([10,150,200]),</span>
<span class="sd">        &gt;&gt;&gt;       avec=np.array([1,2,3]),bvec=np.array([0.4,3.14,2]),</span>
<span class="sd">        &gt;&gt;&gt;       g1vec=np.array([0.9,2.1,0.3]),g3vec=np.array([0.7,1.14,0.2]),</span>
<span class="sd">        &gt;&gt;&gt;       p1=2e-4,ReciprocalMedium=False,AdjointMedium=True )</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># Check if normalisation is set correctly</span>
        <span class="k">if</span> <span class="n">normalisation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;flux&#39;</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FocusingFunction_p_w: This function only models the focusing function for flux-normalisation. (For pressure-normalistiont the required equations have to be derived.)&#39;</span><span class="p">)</span>
        
        <span class="c1"># Insert transparent interfaces at the focusing depth level.</span>
        <span class="c1"># The insertion implicitly checks that x3F is non-negative </span>
        <span class="c1"># and real-valued.</span>
        <span class="c1"># If the focusing depth is greater than, or equal to the deepest </span>
        <span class="c1"># interface, we insert another transparent layer below the focusing </span>
        <span class="c1"># depth to be able to compute scattering coefficients at the focusing </span>
        <span class="c1"># depth without getting an index error.</span>
        <span class="k">if</span> <span class="n">x3F</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x3vec</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">Tmp_medium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x3F</span><span class="p">,</span><span class="n">x3F</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span>
                                           <span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Tmp_medium</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Insert_layer</span><span class="p">(</span><span class="n">x3</span><span class="o">=</span><span class="n">x3F</span><span class="p">,</span><span class="n">UpdateSelf</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">X3vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;x3vec&#39;</span><span class="p">]</span>
        <span class="n">Bvec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;bvec&#39;</span><span class="p">]</span>
        <span class="n">G3vec</span> <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;g3vec&#39;</span><span class="p">]</span>
        <span class="n">P3</span>    <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;p3&#39;</span><span class="p">]</span>
        <span class="n">P3n</span>   <span class="o">=</span> <span class="n">Tmp_medium</span><span class="p">[</span><span class="s1">&#39;p3n&#39;</span><span class="p">]</span>
        
        <span class="c1"># Index of the focusing depth</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x3F</span><span class="p">)</span>
        
        <span class="c1"># Only allow propagating waves to model the focusing function</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">P3</span><span class="p">[:</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">P3n</span><span class="p">[:</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;FocusingFunction_p_w: (Here,) We only define the focusing function for propagating waves, i.e. not evanescent waves.&#39;</span><span class="p">)</span>
        
        <span class="c1"># Vector with layer thicknesses</span>
        <span class="n">dx3vec</span> <span class="o">=</span> <span class="n">X3vec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dx3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">X3vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">X3vec</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Down- and upgoing focusing functions: Initial value</span>
        <span class="c1"># Here every frequency component has an amplitude equal to one. Hence,</span>
        <span class="c1"># the total wavefield has a strength of sqrt(nt)</span>
        <span class="c1"># When an ifft is applied the wavefield is scaled by 1/sqrt(nt).</span>
        <span class="c1"># Hence in the time domain the wavefield has an amplitude equal to one.</span>
        <span class="n">FP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">FM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Reflection responses: Initial value</span>
        <span class="n">RP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">RM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Here every frequency component has an amplitude equal to one. Hence,</span>
        <span class="c1"># the total wavefield has a strength of sqrt(nt)</span>
        <span class="c1"># When an ifft is applied the wavefield is scaled by 1/sqrt(nt).</span>
        <span class="c1"># Hence in the time domain the wavefield has an amplitude equal to one.</span>
        <span class="n">TP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">TM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="c1"># Internal multiple operator: Initial value</span>
        <span class="n">M1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">M2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nf</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">FPa</span> <span class="o">=</span> <span class="n">FP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">FMa</span> <span class="o">=</span> <span class="n">FM</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">RPa</span> <span class="o">=</span> <span class="n">RP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">RMa</span> <span class="o">=</span> <span class="n">RP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">TPa</span> <span class="o">=</span> <span class="n">TP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">TMa</span> <span class="o">=</span> <span class="n">TP</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">FPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">FMa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">RPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">TPa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">RMa</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">TMa</span> <span class="o">=</span> <span class="kc">None</span>
    
        <span class="c1"># Loop over f+1 interfaces</span>
        <span class="c1"># Thus, the wavefield propagates to the focusing depth, and scatters</span>
        <span class="c1"># at the focusing depth.</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            
            <span class="c1"># Scattering coefficients</span>
            <span class="n">ScatCoeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RT_p_w</span><span class="p">(</span><span class="n">beta_u</span><span class="o">=</span><span class="n">Bvec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="p">,</span><span class="n">g3_u</span><span class="o">=</span><span class="n">G3vec</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="p">,</span><span class="n">p3_u</span><span class="o">=</span><span class="n">P3</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>  <span class="p">,</span><span class="n">p3n_u</span><span class="o">=</span><span class="n">P3n</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                     <span class="n">beta_l</span><span class="o">=</span><span class="n">Bvec</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">g3_l</span><span class="o">=</span><span class="n">G3vec</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">p3_l</span><span class="o">=</span><span class="n">P3</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">p3n_l</span><span class="o">=</span><span class="n">P3n</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">normalisation</span><span class="o">=</span><span class="n">normalisation</span><span class="p">)</span>
            
            <span class="n">rP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rP&#39;</span><span class="p">]</span>
            <span class="n">tP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tP&#39;</span><span class="p">]</span>
            <span class="n">rM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rM&#39;</span><span class="p">]</span>
            <span class="n">tM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tM&#39;</span><span class="p">]</span>
            
            <span class="c1"># Propagators</span>
            <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W_propagators_p_w</span><span class="p">(</span><span class="n">p3</span><span class="o">=</span><span class="n">P3</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">p3n</span><span class="o">=</span><span class="n">P3n</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">g3</span><span class="o">=</span><span class="n">G3vec</span><span class="p">[</span><span class="n">n</span><span class="p">],</span><span class="n">dx3</span><span class="o">=</span><span class="n">dx3vec</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
            <span class="n">WP</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wP&#39;</span><span class="p">]</span>
            <span class="n">WM</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wM&#39;</span><span class="p">]</span>
        
            <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="p">)</span>
                <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="p">)</span>
            
            <span class="c1"># Update focusing functions and reflection / transmission responses</span>
            <span class="n">FP</span> <span class="o">=</span> <span class="n">FP</span><span class="o">/</span><span class="n">WP</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="p">)</span><span class="o">/</span><span class="n">tP</span>
            <span class="n">RP</span> <span class="o">=</span> <span class="n">RP</span> <span class="o">+</span> <span class="n">TM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TP</span>
            <span class="n">RM</span> <span class="o">=</span> <span class="n">rM</span> <span class="o">+</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>
            <span class="n">TP</span> <span class="o">=</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TP</span>
            <span class="n">TM</span> <span class="o">=</span> <span class="n">TM</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>  
            <span class="n">FM</span> <span class="o">=</span> <span class="n">RP</span><span class="o">*</span><span class="n">FP</span>
            
            <span class="c1"># Model focusing functions in the adjoint medium</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">rP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rPa&#39;</span><span class="p">]</span>
                <span class="n">tP</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tPa&#39;</span><span class="p">]</span>
                <span class="n">rM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;rMa&#39;</span><span class="p">]</span>
                <span class="n">tM</span> <span class="o">=</span> <span class="n">ScatCoeffs</span><span class="p">[</span><span class="s1">&#39;tMa&#39;</span><span class="p">]</span>
                <span class="n">WP</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wPa&#39;</span><span class="p">]</span>
                <span class="n">WM</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="s1">&#39;wMa&#39;</span><span class="p">]</span>
            
                <span class="k">if</span> <span class="n">InternalMultiples</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">M1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="p">)</span>
                    <span class="n">M2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="p">)</span>
                
                <span class="c1"># Update focusing functions and reflection / transmission responses</span>
                <span class="n">FPa</span> <span class="o">=</span> <span class="n">FPa</span><span class="o">/</span><span class="n">WP</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="p">)</span><span class="o">/</span><span class="n">tP</span>
                <span class="n">RPa</span> <span class="o">=</span> <span class="n">RPa</span> <span class="o">+</span> <span class="n">TMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">rP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TPa</span>
                <span class="n">RMa</span> <span class="o">=</span> <span class="n">rM</span> <span class="o">+</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">RMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>
                <span class="n">TPa</span> <span class="o">=</span> <span class="n">tP</span><span class="o">*</span><span class="n">WP</span><span class="o">*</span><span class="n">M1</span><span class="o">*</span><span class="n">TPa</span>
                <span class="n">TMa</span> <span class="o">=</span> <span class="n">TMa</span><span class="o">*</span><span class="n">WM</span><span class="o">*</span><span class="n">M2</span><span class="o">*</span><span class="n">tM</span>  
                <span class="n">FMa</span> <span class="o">=</span> <span class="n">RPa</span><span class="o">*</span><span class="n">FPa</span>
                
        <span class="c1"># Verbose: Inform the user if any wavefield contains NaNs of Infs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="p">(</span>   <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FocusingFunction_p_w:&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="mi">100</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;One of the modelled wavefields in the true medium contains a NaN (Not a Number) or an Inf (infinite) element.&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TP</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TP contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TP</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TM contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TM</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">AdjointMedium</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="p">(</span>   <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> 
                    <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;FocusingFunction_p_w:&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="mi">100</span><span class="o">*</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;One of the modelled wavefields in the adoint medium contains a NaN (Not a Number) or an Inf (infinite) element.&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TPa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TPa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TPa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">FMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - FMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">FMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - RMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">RMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">TMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; NaN.&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TMa</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> - TMa contains &#39;</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">TMa</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39; Inf.&#39;</span><span class="p">)</span>
                
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

                
        <span class="n">out</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;FP&#39;</span><span class="p">:</span><span class="n">FP</span>  <span class="p">,</span><span class="s1">&#39;RP&#39;</span><span class="p">:</span><span class="n">RP</span>  <span class="p">,</span><span class="s1">&#39;TP&#39;</span><span class="p">:</span><span class="n">TP</span>  <span class="p">,</span><span class="s1">&#39;FM&#39;</span><span class="p">:</span><span class="n">FM</span>  <span class="p">,</span><span class="s1">&#39;RM&#39;</span><span class="p">:</span><span class="n">RM</span>  <span class="p">,</span><span class="s1">&#39;TM&#39;</span><span class="p">:</span><span class="n">TM</span><span class="p">,</span>
             <span class="s1">&#39;FPa&#39;</span><span class="p">:</span><span class="n">FPa</span><span class="p">,</span><span class="s1">&#39;RPa&#39;</span><span class="p">:</span><span class="n">RPa</span><span class="p">,</span><span class="s1">&#39;TPa&#39;</span><span class="p">:</span><span class="n">TPa</span><span class="p">,</span><span class="s1">&#39;FMa&#39;</span><span class="p">:</span><span class="n">FMa</span><span class="p">,</span><span class="s1">&#39;RMa&#39;</span><span class="p">:</span><span class="n">RMa</span><span class="p">,</span><span class="s1">&#39;TMa&#39;</span><span class="p">:</span><span class="n">TMa</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Non-reciprocal wavefields (1.5 D) 28-03-2018 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Christian Reinicke, Kees Wapenaar, and Evert Slob.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.2.
    </div>
  </body>
</html>